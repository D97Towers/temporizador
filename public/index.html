<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Temporizador de Juegos</title>
  <!-- Deployment trigger: v1.9 - FONT AWESOME UPDATE + FAVICON: Updated to 6.4.0 and added favicon -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>⏱️</text></svg>">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      color: #333;
      box-sizing: border-box;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 10px;
      box-sizing: border-box;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      color: white;
      position: relative;
      padding-left: 80px;
      padding-right: 20px;
    }


    /* Estilos para sidebar con footer separado */
    .sidebar {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .nav-buttons {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .sidebar-footer {
      margin-top: auto;
      padding-top: 20px;
    }

    /* Desktop sidebar layout */
    .desktop-nav-container {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 80px);
    }

    .desktop-nav {
      flex: 1;
    }

    .desktop-sidebar-footer {
      margin-top: auto;
      padding-top: 20px;
    }

    /* Estilos para botones de logout en sidebar */
    .logout-btn-sidebar {
      background: transparent !important;
      border: none !important;
      color: white !important;
      margin-top: 0 !important;
      border-radius: 8px !important;
    }

    .logout-btn-sidebar:hover {
      background: rgba(255, 255, 255, 0.1) !important;
      border: none !important;
    }

    .logout-btn-desktop {
      background: transparent !important;
      border: none !important;
      color: white !important;
      margin-top: 0 !important;
      border-radius: 8px !important;
    }

    .logout-btn-desktop:hover {
      background: rgba(255, 255, 255, 0.1) !important;
      border: none !important;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    /* Navegación principal */
         .main-nav {
           display: flex;
           justify-content: flex-start;
           gap: 10px;
           margin-top: 20px;
           flex-wrap: wrap;
           margin-left: 20px;
         }

         /* Desktop Sidebar */
         .desktop-sidebar {
           display: none;
         }

         .main-content {
           width: 100%;
         }

         /* Desktop - mostrar sidebar y ocultar menú móvil */
         @media (min-width: 769px) {
           .desktop-sidebar {
             display: flex;
             flex-direction: column;
             position: fixed;
             left: 0;
             top: 0;
             width: 250px;
             height: 100vh;
             background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
             z-index: 100;
             box-shadow: 2px 0 10px rgba(0,0,0,0.3);
           }

           .sidebar-header {
             padding: 30px 20px 20px;
             border-bottom: 1px solid rgba(255,255,255,0.1);
           }

           .sidebar-header h2 {
      color: white;
             font-size: 1.5rem;
             font-weight: 600;
             text-align: center;
             margin: 0;
           }

           .desktop-nav {
             padding: 20px 0;
             flex: 1;
           }

           .desktop-nav-btn {
             display: flex;
             align-items: center;
             gap: 12px;
             width: 100%;
             padding: 15px 20px;
             background: none;
             border: none;
             color: rgba(255,255,255,0.9);
             font-size: 14px;
             font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
             text-align: left;
             border-left: 3px solid transparent;
           }

           .desktop-nav-btn:hover {
             background: rgba(255,255,255,0.15);
             color: white;
             transform: translateX(5px);
           }

           .desktop-nav-btn.active {
             background: rgba(255,255,255,0.2);
             color: white;
             border-left-color: white;
             font-weight: 600;
           }

           .desktop-nav-btn i {
             font-size: 16px;
             width: 20px;
           }

           .main-content {
             margin-left: 250px;
             width: calc(100% - 250px);
           }
           
           .mobile-menu-toggle {
             display: none !important;
           }
           
        /* Ocultar botón X en móvil */
        .close-button {
             display: none !important;
           }
           
           .header {
             padding-left: 20px !important;
             text-align: center !important;
           }
         }

         /* Menú lateral para móviles */
         .mobile-menu-toggle {
           display: none;
           background: transparent !important;
      color: white;
           border: none !important;
           padding: 8px;
      border-radius: 0;
      cursor: pointer;
      width: auto;
      height: auto;
           transition: all 0.3s ease;
           box-shadow: none !important;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
         .hamburger-lines {
           display: flex;
           flex-direction: column;
           gap: 3px;
           width: 18px;
         }

         .hamburger-lines span {
           width: 100%;
           height: 2px;
           background-color: white;
           border-radius: 1px;
           transition: all 0.3s ease;
         }

         .mobile-menu-toggle:hover {
           background: rgba(255, 255, 255, 0.1) !important;
           opacity: 0.8;
         }

         /* Asegurar que el botón no se vea afectado por otros estilos */
         .mobile-menu-toggle * {
           text-align: center !important;
           position: static !important;
         }

         /* Sobrescribir estilos globales de botones */
         .mobile-menu-toggle {
           width: auto !important;
           max-width: none !important;
           min-width: auto !important;
           flex: none !important;
           box-sizing: border-box !important;
         }

         .sidebar {
           position: fixed;
           top: 0;
           left: -300px;
           width: 280px;
           height: 100vh;
           background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
           padding: 80px 20px 20px;
           z-index: 1000;
           transition: left 0.3s ease;
           box-shadow: 2px 0 10px rgba(0,0,0,0.3);
         }

         .sidebar.open {
           left: 0;
         }

         .sidebar .nav-btn {
           width: 100%;
           margin-bottom: 10px;
           justify-content: flex-start;
           min-width: auto;
         }

         .sidebar-overlay {
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background: rgba(0, 0, 0, 0.5);
           z-index: 999;
           opacity: 0;
           visibility: hidden;
           transition: all 0.3s ease;
         }

         .sidebar-overlay.active {
           opacity: 1;
           visibility: visible;
         }

         /* Sistema de búsqueda de niños */
         .child-search-container {
           position: relative;
         }

         .child-search-results {
           position: absolute;
           top: 100%;
           left: 0;
           right: 0;
           background: white;
           border: 1px solid #ddd;
           border-radius: 8px;
           max-height: 200px;
           overflow-y: auto;
      z-index: 100;
           display: none;
           box-shadow: 0 4px 12px rgba(0,0,0,0.15);
         }

         .child-search-results.show {
           display: block;
         }

         .child-search-item {
           padding: 12px 15px;
           cursor: pointer;
           border-bottom: 1px solid #f0f0f0;
           display: flex;
           align-items: center;
           gap: 10px;
           transition: background-color 0.2s ease;
         }

         .child-search-item:hover {
           background-color: #f8f9fa;
         }

         .child-search-item:last-child {
           border-bottom: none;
         }

         .child-search-item .child-avatar {
           width: 30px;
           height: 30px;
           border-radius: 50%;
           background: linear-gradient(135deg, #667eea, #764ba2);
           color: white;
      display: flex;
      align-items: center;
      justify-content: center;
           font-weight: bold;
           font-size: 14px;
         }

         .child-search-item .child-info {
           flex: 1;
         }

         .child-search-item .child-name {
           font-weight: 600;
           color: #333;
           margin-bottom: 2px;
         }

         .child-search-item .child-parents {
           font-size: 12px;
           color: #666;
         }

         .child-search-item .child-stats {
           font-size: 11px;
           color: #999;
           text-align: right;
         }

         .no-results {
           padding: 15px;
           text-align: center;
           color: #666;
           font-style: italic;
         }

    .nav-btn {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      padding: 12px 20px;
      border-radius: 25px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      min-width: 140px;
      justify-content: center;
    }

    .nav-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
      transform: translateY(-2px);
    }

    .nav-btn.active {
      background: rgba(255, 255, 255, 0.9);
      color: #667eea;
      border-color: white;
    }

    .shortcut-key {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 10px;
      font-weight: bold;
      margin-left: 8px;
      opacity: 0.8;
    }

    /* Secciones */
    .section {
      display: none;
    }

    .section.active {
      display: block;
    }

    /* Dashboard de estadísticas */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      transition: transform 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-5px);
    }

    .stat-number {
      font-size: 2.5rem;
      font-weight: bold;
      color: #667eea;
      margin-bottom: 10px;
    }

    .stat-label {
      color: #666;
      font-size: 1rem;
      margin-bottom: 5px;
    }

    .stat-description {
      color: #999;
      font-size: 0.9rem;
    }

    .chart-container {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }

    .chart-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: #333;
      margin-bottom: 15px;
      text-align: center;
    }

    .ranking-list {
      list-style: none;
      padding: 0;
    }

    .ranking-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      margin-bottom: 8px;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #667eea;
    }

    .ranking-item:nth-child(1) {
      border-left-color: #ffd700;
      background: linear-gradient(135deg, #fff9c4, #f8f9fa);
    }

    .ranking-item:nth-child(2) {
      border-left-color: #c0c0c0;
      background: linear-gradient(135deg, #f0f0f0, #f8f9fa);
    }

    .ranking-item:nth-child(3) {
      border-left-color: #cd7f32;
      background: linear-gradient(135deg, #ffe4b5, #f8f9fa);
    }

    .ranking-position {
      font-weight: bold;
      color: #667eea;
      font-size: 1.2rem;
      min-width: 30px;
    }

    .ranking-name {
      flex: 1;
      margin: 0 15px;
      font-weight: 500;
    }

    .ranking-time {
      color: #666;
      font-weight: 600;
    }
    
    /* Sync button removed for better UX - data syncs automatically */

    .header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    /* Control de notificaciones de voz */
    .voice-control {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
      z-index: 10;
    }

    .voice-toggle-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 10px 16px;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 500;
      backdrop-filter: blur(10px);
      min-width: 140px;
      justify-content: center;
      white-space: nowrap;
    }

    .voice-toggle-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
    }

    .voice-toggle-btn.muted {
      background: rgba(255, 0, 0, 0.2);
      border-color: rgba(255, 0, 0, 0.4);
    }

    .voice-toggle-btn.muted i {
      color: #ff6b6b;
    }

    /* Responsive para botón de voz */
    @media (max-width: 768px) {
      .voice-control {
        position: absolute;
        top: 20px;
        right: 20px;
        justify-content: center;
        z-index: 10;
      }
      
      .voice-toggle-btn {
        min-width: 120px;
        padding: 8px 12px;
        font-size: 13px;
      }
      
      /* FIX CRÍTICO: AJUSTAR history-toggle en tablet */
      .history-toggle {
        position: relative !important;
        z-index: 1 !important;
        margin: 10px 0;
      }
    }

    @media (max-width: 480px) {
      .voice-control {
        position: absolute;
        top: 20px;
        right: 20px;
        justify-content: center;
        z-index: 10;
      }
      
      .voice-toggle-btn {
        min-width: 100px;
        padding: 6px 10px;
        font-size: 12px;
        gap: 6px;
      }
      
      .voice-toggle-btn span {
        display: none;
      }
      
      .voice-toggle-btn i {
        font-size: 16px;
      }
      
      /* FIX CRÍTICO: AJUSTAR history-toggle en móvil */
      .history-toggle {
        position: relative !important;
        z-index: 1 !important;
        margin: 10px 0;
        font-size: 12px;
        padding: 10px 12px;
      }
    }





    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(0,0,0,0.15);
    }

    .card h2 {
      color: #4a5568;
      margin-bottom: 20px;
      font-size: 1.3rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-row {
      display: flex;
      gap: 15px;
      align-items: end;
      flex-wrap: wrap;
    }

    .form-row .form-group {
      flex: 1;
      min-width: 120px;
    }

    .form-row .form-group:last-child {
      flex: 0 0 auto;
      min-width: 140px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #4a5568;
    }

    input, select, button {
      width: 100%;
      padding: 12px 15px;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      font-size: 14px;
      transition: all 0.3s ease;
      background: white;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: all 0.3s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    button:disabled {
      background: #cbd5e0;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-danger {
      background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
    }

    .btn-success {
      background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
    }

    .btn-warning {
      background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
    }

    .list {
      list-style: none;
      margin-top: 15px;
    }

    .list-item {
      background: #f7fafc;
      padding: 12px 15px;
      margin-bottom: 8px;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.3s ease;
      overflow: hidden;
      word-wrap: break-word;
      position: relative;
    }

    .list-item:hover {
      background: #edf2f7;
      transform: translateX(5px);
    }

    .list-item.active {
      border-left-color: #38a169;
      background: #f0fff4;
    }

    .session-info {
      flex: 1;
      min-width: 0;
      margin-right: 10px;
    }

    .session-controls {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      min-width: 0;
      flex-shrink: 0;
    }

    .button-group {
      display: flex;
      gap: 3px;
      margin-top: 5px;
      flex-wrap: nowrap;
    }
    
    /* Estilos para avatares y identificadores únicos */
    .child-info {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
    }
    
    .child-avatar {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 50%;
      font-weight: bold;
      font-size: 14px;
      flex-shrink: 0;
    }
    
    .child-avatar-small {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 50%;
      font-weight: bold;
      font-size: 10px;
      margin-right: 5px;
    }
    
    .child-details {
      flex: 1;
      min-width: 0;
    }
    
    .original-name {
      display: block;
      color: #666;
      font-size: 11px;
      margin-top: 2px;
      font-style: italic;
    }
    
    /* Estilos para formulario mejorado de niños */
    .child-form {
      margin-bottom: 20px;
    }
    
    .child-form label {
      display: block;
      margin-bottom: 5px;
      font-weight: 600;
      color: #333;
      font-size: 14px;
    }
    
    .child-form input {
      width: 100%;
      padding: 10px;
      border: 2px solid #e1e5e9;
      border-radius: 8px;
      font-size: 14px;
      transition: all 0.3s ease;
      box-sizing: border-box;
    }
    
    .child-form input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    .child-form input[required] {
      border-color: #667eea;
    }
    
    .child-form .form-row {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    .child-form .form-row .form-group {
      flex: 1;
    }
    
    .child-form {
      margin-bottom: 20px;
    }

    .child-form .form-row {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
    }

    .child-form .form-group {
      flex: 1;
      min-width: 0;
    }

    .child-form label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      color: #333;
      font-size: 14px;
    }

    .child-form input {
      width: 100%;
      padding: 10px;
      border: 2px solid #e1e5e9;
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.3s ease;
      box-sizing: border-box;
    }

    .child-form input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .child-form small {
      display: block;
      color: #666;
      font-size: 12px;
      margin-top: 5px;
      font-style: italic;
    }

    /* Safari iPhone specific fixes */
    @supports (-webkit-touch-callout: none) {
      .btn-small, .btn-edit {
        -webkit-appearance: none !important;
        appearance: none !important;
        -webkit-tap-highlight-color: transparent !important;
        touch-action: manipulation !important;
      }
      
      .list-item {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }
    }

    /* Responsive design for mobile */
    @media (max-width: 768px) {
      .child-form .form-row {
        flex-direction: column;
        gap: 10px;
      }
      
      .child-form .form-group {
        flex: none;
      }

      .child-info {
        flex-direction: column;
        align-items: flex-start !important;
        gap: 8px;
      }

      .child-details {
        width: 100% !important;
      }

      .list-item {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }

      .btn-small {
        align-self: flex-end;
        margin-top: 8px;
        padding: 14px 18px !important;
        font-size: 16px !important;
        min-width: 48px !important;
        min-height: 48px !important;
        touch-action: manipulation !important;
        -webkit-tap-highlight-color: transparent !important;
      }

      .btn-edit {
        padding: 14px 18px !important;
        font-size: 16px !important;
        min-width: 48px !important;
        min-height: 48px !important;
        touch-action: manipulation !important;
        -webkit-tap-highlight-color: transparent !important;
      }

      .delete-button-container {
        min-width: 120px;
        height: 48px;
        gap: 8px;
      }

      .button-group-small {
        gap: 8px;
      }

      .list-item {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      .child-info {
        margin-right: 0 !important;
      }

      .container {
        padding: 10px;
      }

      .card {
        margin-bottom: 15px;
      }

      h2 {
        font-size: 18px;
      }
    }

    /* Tablet responsive */
    @media (max-width: 1024px) and (min-width: 769px) {
      .grid {
        grid-template-columns: 1fr;
        gap: 20px;
      }
      
      .child-form .form-row {
        gap: 12px;
      }
    }
    
    /* Estilos para elementos de niños mejorados */
    .child-item {
      border-left: 4px solid #667eea;
      background: #f8f9ff;
      transition: all 0.3s ease;
    }

    .child-item:hover {
      background: #e8f2ff;
    }

    .child-name {
      font-size: 16px;
      font-weight: 600;
      color: #333;
      margin-bottom: 4px;
    }

    .nickname-text {
      color: #666;
      font-weight: 400;
      font-style: italic;
    }

    .child-time {
      color: #666;
      font-size: 14px;
    }

    .child-parents {
      color: #555;
      font-size: 12px;
      font-style: italic;
      margin: 2px 0;
      background: rgba(102, 126, 234, 0.05);
      padding: 2px 6px;
      border-radius: 4px;
      border-left: 2px solid #667eea;
    }

    .btn-small {
      padding: 12px 16px !important;
      font-size: 14px !important;
      min-width: 44px !important;
      min-height: 44px !important;
      border-radius: 8px !important;
      opacity: 0.9;
      transition: all 0.2s ease !important;
      width: auto !important;
      height: auto !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      touch-action: manipulation !important;
      -webkit-tap-highlight-color: transparent !important;
    }

    .btn-small:hover {
      opacity: 1;
      transform: none;
      background: #e53e3e !important;
    }

    .btn-small i {
      font-size: 14px !important;
    }

    .btn-edit {
      padding: 12px 16px !important;
      font-size: 14px !important;
      min-width: 44px !important;
      min-height: 44px !important;
      border-radius: 8px !important;
      opacity: 0.9;
      transition: all 0.2s ease !important;
      width: auto !important;
      height: auto !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
      color: white !important;
      border: none !important;
      margin-right: 8px !important;
      touch-action: manipulation !important;
      -webkit-tap-highlight-color: transparent !important;
    }

    .btn-edit:hover {
      opacity: 1;
      transform: none;
      background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%) !important;
    }

    .btn-edit i {
      font-size: 14px !important;
    }

    .delete-button-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      min-width: 60px;
      height: 32px;
    }

    .button-group-small {
      display: flex;
      gap: 5px;
      align-items: center;
    }

    .parents-info {
      color: #555;
      font-size: 11px;
      font-style: italic;
      background: rgba(102, 126, 234, 0.05);
      padding: 2px 6px;
      border-radius: 4px;
      border-left: 2px solid #667eea;
      margin: 2px 0;
      display: inline-block;
    }

    .history-parents {
      color: #555;
      font-size: 11px;
      font-style: italic;
      background: rgba(102, 126, 234, 0.05);
      padding: 2px 6px;
      border-radius: 4px;
      border-left: 2px solid #667eea;
      margin: 2px 0;
      display: block;
    }

    /* Historial compacto y responsive */
    .history-item {
      background: white;
      margin-bottom: 8px;
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 12px;
      align-items: center;
      transition: all 0.2s ease;
      border-left: 4px solid transparent;
    }

    .history-item:hover {
      transform: translateX(2px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }

    .history-item.active {
      border-left-color: #4CAF50;
      background: linear-gradient(135deg, #f8fff8, #ffffff);
    }

    .history-item.completed {
      border-left-color: #2196F3;
      opacity: 0.8;
    }

    .history-item.expired {
      border-left-color: #f44336;
      background: linear-gradient(135deg, #fff5f5, #ffffff);
    }

    .history-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      color: white;
    }

    .history-icon.active {
      background: linear-gradient(135deg, #4CAF50, #45a049);
    }

    .history-icon.completed {
      background: linear-gradient(135deg, #2196F3, #1976D2);
    }

    .history-icon.expired {
      background: linear-gradient(135deg, #f44336, #d32f2f);
    }

    .history-content {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .history-title {
      font-weight: 600;
      color: #333;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .history-subtitle {
      font-size: 12px;
      color: #666;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .history-meta {
      text-align: right;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 80px;
    }

    .history-duration {
      font-size: 12px;
      font-weight: 600;
      padding: 2px 6px;
      border-radius: 4px;
      color: white;
    }

    .history-duration.active {
      background: #4CAF50;
    }

    .history-duration.completed {
      background: #2196F3;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .history-duration.expired {
      background: #f44336;
    }

    .history-time {
      font-size: 11px;
      color: #999;
    }

    /* Botón para expandir/colapsar historial - COLORIMETRÍA CORREGIDA */
    .history-toggle {
      width: 100%;
      padding: 12px 16px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: all 0.3s ease;
      margin: 15px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      position: relative !important;
      z-index: 1 !important;
    }

    /* AJUSTAR history-toggle en móvil y tablet */
    @media (max-width: 1024px) {
      .history-toggle {
        position: relative !important;
        z-index: 1 !important;
        margin: 10px 0;
      }
    }


    .history-toggle:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    .history-toggle.expanded {
      background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
    }


    .history-hidden {
      display: none;
    }

    .history-summary {
      background: #f8f9fa;
      border-radius: 6px;
      padding: 8px 12px;
      margin: 8px 0;
      font-size: 12px;
      color: #666;
      text-align: center;
      border: 1px solid #e9ecef;
    }

    /* Responsive design para historial */
    @media (max-width: 768px) {
      .history-item {
        grid-template-columns: auto 1fr;
        gap: 8px;
      }

      .history-meta {
        grid-column: 1 / -1;
        text-align: left;
        flex-direction: row;
        justify-content: space-between;
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #eee;
      }

      .history-content {
        grid-column: 2;
      }
    }

    @media (max-width: 480px) {
      .history-item {
        padding: 10px;
        margin-bottom: 6px;
      }

      .history-icon {
        width: 32px;
        height: 32px;
        font-size: 14px;
      }

      .history-title {
        font-size: 13px;
      }

      .history-subtitle {
        font-size: 11px;
      }

    }

    .timer {
      font-weight: bold;
      color: #38a169;
      font-family: 'Courier New', monospace;
      font-size: 1.1rem;
      line-height: 1.3;
      text-align: center;
      min-width: 120px;
    }

    .timer.warning {
      color: #f6ad55;
    }

    .timer.danger {
      color: #e53e3e;
      animation: pulse 1s infinite;
    }

    .timer strong {
      display: block;
      font-size: 1.2rem;
      margin-bottom: 2px;
    }

    .timer small {
      font-size: 0.9rem;
      opacity: 0.8;
      font-weight: normal;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .status-message {
      position: fixed;
      top: 120px;
      right: 20px;
      padding: 12px 16px;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      font-size: 14px;
      line-height: 1.4;
      z-index: 1010;
      max-width: 350px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transform: translateX(400px);
      transition: transform 0.3s ease;
      display: flex;
      align-items: flex-start;
      gap: 8px;
      max-width: 380px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      word-wrap: break-word;
      hyphens: auto;
    }

    .status-text {
      flex: 1;
      word-wrap: break-word;
    }

    .status-close {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      opacity: 0.8;
      transition: opacity 0.2s ease;
      flex-shrink: 0;
    }

    .status-close:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.1);
    }

    .status-message.show {
      transform: translateX(0);
    }

    .status-message.success {
      background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
    }

    .status-message.error {
      background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
    }

    .status-message.warning {
      background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(5px);
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      animation: modalSlideIn 0.3s ease;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: scale(0.8) translateY(-50px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .modal h2 {
      color: #4a5568;
      margin-bottom: 20px;
      font-size: 1.5rem;
    }

    .modal p {
      font-size: 1.1rem;
      margin-bottom: 30px;
      color: #666;
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .modal-buttons button {
      flex: 1;
      max-width: 120px;
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .extend-time {
      background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
      margin-left: 5px;
      padding: 5px 10px;
      font-size: 12px;
    }

    /* Responsive Design para navegación */
    @media (max-width: 768px) {
      .stats-grid {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }
      
      .stat-card {
        padding: 15px;
      }
      
      .stat-number {
        font-size: 2rem;
      }
      
      .chart-container {
        padding: 15px;
      }
    }

    @media (max-width: 480px) {
      .nav-btn {
        padding: 8px 12px;
        font-size: 12px;
      }
      
      .stats-grid {
        grid-template-columns: 1fr;
      }
      
      .ranking-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      
      .ranking-meta {
        display: flex;
        justify-content: space-between;
        width: 100%;
      }
    }

    /* Sistema de alertas mejorado */
    .alert-container {
      position: fixed;
      top: 80px;
      right: 20px;
      z-index: 10000;
      max-width: 380px;
      max-height: 60vh;
      overflow-y: auto;
      pointer-events: none;
    }
    
    .alert-container::-webkit-scrollbar {
      width: 4px;
    }
    
    .alert-container::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .alert-container::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
    }
    
    .persistent-alert {
      background: linear-gradient(135deg, #ff4757, #ff3742);
      color: white;
      border-radius: 8px;
      padding: 0;
      margin-bottom: 8px;
      box-shadow: 0 4px 20px rgba(255, 71, 87, 0.25);
      transform: translateX(0);
      opacity: 1;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: auto;
      border: none;
      backdrop-filter: blur(8px);
      overflow: hidden;
    }
    
    .persistent-alert:hover {
      transform: translateX(-4px);
      box-shadow: 0 6px 25px rgba(255, 71, 87, 0.35);
    }
    
    .alert-content {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      padding: 10px 14px;
      gap: 10px;
    }
    
    .alert-message {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
      line-height: 1.3;
      word-wrap: break-word;
      white-space: pre-line; /* Permitir saltos de línea */
      overflow-wrap: break-word;
      hyphens: auto;
    }
    
    .alert-close {
      background: rgba(255, 255, 255, 0.15);
      border: none;
      color: white;
      cursor: pointer;
      padding: 6px;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      flex-shrink: 0;
    }
    
    .alert-close:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: scale(1.1);
    }
    
    .alert-close i {
      font-size: 11px;
    }
    
    /* Animación de entrada mejorada */
    .persistent-alert {
      animation: slideInRight 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    /* Agrupación de alertas similares */
    .alert-group {
      background: linear-gradient(135deg, #ff6b6b, #ff5252);
      border-radius: 8px;
      margin-bottom: 8px;
      overflow: hidden;
    }
    
    .alert-group-header {
      background: rgba(255, 255, 255, 0.1);
      padding: 8px 16px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .alert-group-content {
      padding: 8px 16px;
    }
    
    .alert-group-item {
      font-size: 12px;
      margin-bottom: 4px;
      opacity: 0.9;
    }
    
    .alert-group-item:last-child {
      margin-bottom: 0;
    }
    
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* Optimizaciones específicas para desktop */
    @media (min-width: 769px) {
      .status-message {
        max-width: 400px;
        font-size: 14px;
        padding: 12px 18px;
      }
      
      .alert-container {
        max-width: 400px;
      }
      
      .alert-content {
        padding: 12px 16px;
      }
      
      .alert-message {
        font-size: 14px;
        line-height: 1.4;
        white-space: pre-line; /* Permitir saltos de línea */
      }
      
      /* Ocultar botón X en desktop también */
      .alert-close {
        display: none !important;
      }
      
      .status-close {
        display: none !important;
      }
    }

    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      
      .mobile-menu-toggle {
        display: block !important;
        position: fixed !important;
        top: 20px !important;
        left: 20px !important;
        z-index: 1001 !important;
        transform: none !important;
        transition: none !important;
      }
      
      /* Asegurar que el botón hamburguesa se mantenga fijo */
      .mobile-menu-toggle:hover {
        background: rgba(255, 255, 255, 0.2) !important;
        border-color: rgba(255, 255, 255, 0.5) !important;
      }
      
      .main-nav {
        display: none !important;
      }
      
      .header {
        padding-left: 20px !important;
        text-align: center !important;
      }
      
      .container {
        padding-left: 10px;
      }
      
      .header {
        padding-left: 20px !important;
        padding-right: 20px !important;
        text-align: center !important;
      }


      .header h1 {
        font-size: 1.5rem;
        margin-left: 0;
      }
      
      .header p {
        font-size: 0.9rem;
        margin-left: 0;
      }

      .grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .card {
        padding: 20px;
      }

      .form-row {
        flex-direction: column !important;
        gap: 10px;
        align-items: stretch !important;
      }

      .form-row .form-group {
        min-width: auto !important;
        max-width: none !important;
        flex: none !important;
        width: 100% !important;
      }

      .form-row .form-group:last-child {
        min-width: auto !important;
        max-width: none !important;
        flex: none !important;
        width: 100% !important;
      }

      input, select, button {
        width: 100% !important;
        max-width: none !important;
        font-size: 16px; /* Evita zoom en iOS */
      }
      
      /* Mejorar alertas en móviles */
      .alert-container {
        top: 70px;
        right: 10px;
        left: 10px;
        max-width: none;
        max-height: 50vh;
      }
      
      /* Ocultar botón X en alertas móviles */
      .alert-close {
        display: none !important;
      }
      
      /* Ocultar botón X en status message móvil */
      .status-close {
        display: none !important;
      }
      
      
      .persistent-alert {
        margin-bottom: 6px;
        border-radius: 6px;
      }
      
      .alert-content {
        padding: 10px 14px;
        gap: 10px;
      }
      
      .alert-message {
        font-size: 12px;
        line-height: 1.3;
        white-space: pre-line; /* Permitir saltos de línea */
      }
      
      .alert-close {
        width: 20px;
        height: 20px;
        padding: 4px;
      }
      
      .alert-close i {
        font-size: 10px;
      }
      
      /* Mejorar botones en móviles */
      .list-item .btn {
        padding: 8px 12px;
        font-size: 12px;
        margin: 2px;
      }

      .status-message {
        top: 100px;
        right: 10px;
        left: 10px;
        transform: translateY(-100px);
        max-width: none;
      }

      .status-message.show {
        transform: translateY(0);
      }
    }

    @media (max-width: 480px) {
      .header h1 {
        font-size: 1.8rem;
      }
      
      /* Sync button responsive rules removed */

      .card {
        padding: 15px;
      }

      .modal-content {
        padding: 30px 20px;
      }

      .form-row {
        flex-direction: column !important;
        gap: 8px;
      }

      .form-row .form-group {
        width: 100% !important;
        flex: none !important;
      }

      input, select, button {
        width: 100% !important;
        padding: 10px 12px;
        font-size: 14px;
      }
    }

    /* Reglas responsive para sesiones activas */
    @media (max-width: 768px) {
      .list-item.active {
        flex-direction: column;
        align-items: stretch;
      }
      
      .session-controls {
        align-items: center;
        margin-top: 10px;
      }
      
      .button-group {
        justify-content: center;
        width: 100%;
      }
    }

    @media (max-width: 480px) {
      .button-group button {
        padding: 6px 10px !important;
        font-size: 12px !important;
      }
    }

    /* Regla específica para pantallas muy pequeñas */
    @media (max-width: 360px) {
      .form-row {
        flex-direction: column !important;
        gap: 5px;
      }

      .form-row .form-group {
        width: 100% !important;
        margin-bottom: 10px;
      }

      input, select, button {
        width: 100% !important;
        padding: 8px 10px;
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
    <!-- Menú móvil - Posicionado fuera del flujo normal -->
    <div style="position: fixed; top: 20px; left: 20px; z-index: 1001;">
      <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">
        <div class="hamburger-lines">
          <span></span>
          <span></span>
          <span></span>
        </div>
      </button>
    </div>
    
    <div class="sidebar-overlay" onclick="closeMobileMenu()"></div>
    
    <div class="sidebar" id="sidebar">
      <div class="nav-buttons">
      <button onclick="showSection('dashboard')" class="nav-btn" id="nav-dashboard">
        <i class="fas fa-chart-bar"></i> Dashboard <span class="shortcut-key">1</span>
      </button>
      <button onclick="showSection('sessions')" class="nav-btn" id="nav-sessions">
        <i class="fas fa-play-circle"></i> Sesiones <span class="shortcut-key">2</span>
      </button>
      <button onclick="showSection('children')" class="nav-btn" id="nav-children">
        <i class="fas fa-child"></i> Niños <span class="shortcut-key">3</span>
      </button>
      <button onclick="showSection('games')" class="nav-btn" id="nav-games">
        <i class="fas fa-gamepad"></i> Juegos <span class="shortcut-key">4</span>
      </button>
      </div>
      <div class="sidebar-footer">
        <button onclick="logout()" class="nav-btn logout-btn-sidebar" title="Cerrar sesión">
          <i class="fas fa-sign-out-alt"></i> Cerrar Sesión
        </button>
      </div>
    </div>

  <!-- Desktop Sidebar -->
  <div class="desktop-sidebar">
    <div class="sidebar-header">
      <h2><i class="fas fa-gamepad"></i> Temporizador</h2>
    </div>
    <div class="desktop-nav-container">
    <nav class="desktop-nav">
      <button onclick="showSection('dashboard')" class="desktop-nav-btn" id="nav-dashboard">
        <i class="fas fa-chart-bar"></i> Dashboard
      </button>
      <button onclick="showSection('sessions')" class="desktop-nav-btn" id="nav-sessions">
        <i class="fas fa-play-circle"></i> Sesiones
      </button>
      <button onclick="showSection('children')" class="desktop-nav-btn" id="nav-children">
        <i class="fas fa-child"></i> Niños
      </button>
      <button onclick="showSection('games')" class="desktop-nav-btn" id="nav-games">
        <i class="fas fa-gamepad"></i> Juegos
      </button>
    </nav>
      <div class="desktop-sidebar-footer">
        <button onclick="logout()" class="desktop-nav-btn logout-btn-desktop" title="Cerrar sesión">
          <i class="fas fa-sign-out-alt"></i> Cerrar Sesión
        </button>
      </div>
    </div>
  </div>

  <div class="main-content">
    <div class="header">
      <h1><i class="fas fa-gamepad"></i> Temporizador de Juegos</h1>
      <p>Controla el tiempo de juego de los niños de forma divertida</p>
      
      <!-- Control de notificaciones de voz -->
      <div class="voice-control">
        <button id="voiceToggle" onclick="toggleVoiceNotifications()" class="voice-toggle-btn" title="Activar/Desactivar notificaciones de voz">
          <i class="fas fa-volume-up"></i>
          <span id="voiceStatus">Voz Activada</span>
        </button>
      </div>
    </div>

    <!-- Dashboard Section -->
    <div id="dashboard-section" class="section">
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-number" id="totalChildren">0</div>
          <div class="stat-label">Niños Registrados</div>
          <div class="stat-description">Total de niños en el sistema</div>
          </div>
        <div class="stat-card">
          <div class="stat-number" id="totalGames">0</div>
          <div class="stat-label">Juegos Disponibles</div>
          <div class="stat-description">Juegos registrados</div>
          </div>
        <div class="stat-card">
          <div class="stat-number" id="activeSessionsCount">0</div>
          <div class="stat-label">Sesiones Activas</div>
          <div class="stat-description">Jugando ahora</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="totalTimePlayed">0</div>
          <div class="stat-label">Tiempo Total (min)</div>
          <div class="stat-description">Tiempo jugado acumulado</div>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">🏆 Ranking de Tiempo Jugado</div>
        <ul class="ranking-list" id="childrenRanking">
          <li class="ranking-item">No hay datos disponibles</li>
        </ul>
          </div>

      <div class="chart-container">
        <div class="chart-title">🎮 Juegos Más Populares</div>
        <ul class="ranking-list" id="gamesRanking">
          <li class="ranking-item">No hay datos disponibles</li>
        </ul>
          </div>
      </div>

    <!-- Sessions Section -->
    <div id="sessions-section" class="section">
      <div class="grid">
      <!-- Iniciar Sesión -->
      <div class="card">
        <h2><i class="fas fa-play-circle"></i> Iniciar Sesión de Juego</h2>
        <div class="form-group">
          <label><i class="fas fa-user"></i> Niño:</label>
                     <div class="child-search-container">
                       <input type="text" id="childSearchInput" placeholder="Buscar niño por nombre..." autocomplete="off">
                       <div class="child-search-results" id="childSearchResults"></div>
                       <input type="hidden" id="selectedChildId" value="">
                     </div>
        </div>
        <div class="form-group">
          <label><i class="fas fa-gamepad"></i> Juego:</label>
          <select id="gameSelect">
            <option value="">Seleccione un juego</option>
          </select>
        </div>
        <div class="form-group">
          <label><i class="fas fa-clock"></i> Tiempo (minutos):</label>
          <input type="number" id="durationInput" min="1" max="180" value="15">
        </div>
        <button id="startBtn" type="button">
          <i class="fas fa-play"></i> Iniciar Sesión
        </button>
      </div>

      <!-- Sesiones Activas -->
      <div class="card">
        <h2><i class="fas fa-stopwatch"></i> Sesiones Activas</h2>
        <ul class="list" id="activeSessions">
          <li class="list-item">Cargando sesiones activas...</li>
        </ul>
      </div>

      <!-- Historial -->
      <div class="card">
        <h2><i class="fas fa-history"></i> Historial de Sesiones</h2>
        <ul class="list" id="sessionHistory"></ul>
      </div>
    </div>
  </div>

    <!-- Children Section -->
    <div id="children-section" class="section">
      <div class="grid">
        <!-- Registrar Niño -->
        <div class="card">
          <h2><i class="fas fa-child"></i> Registrar Niño</h2>
            <div class="child-form">
              <div class="form-row">
                <div class="form-group">
                  <label for="childName">Nombre del niño</label>
                  <input type="text" id="childName" placeholder="Ej: Juan" maxlength="30" required>
                </div>
                <div class="form-group">
                  <label for="childNickname">Apodo (opcional)</label>
                  <input type="text" id="childNickname" placeholder="Ej: Juanito" maxlength="20">
                </div>
              </div>
              <div class="form-row">
                <div class="form-group">
                  <label for="fatherName">Nombre del padre (opcional)</label>
                  <input type="text" id="fatherName" placeholder="Ej: Carlos" maxlength="30">
                </div>
                <div class="form-group">
                  <label for="motherName">Nombre de la madre (opcional)</label>
                  <input type="text" id="motherName" placeholder="Ej: María" maxlength="30">
                </div>
              </div>
              <button onclick="addChild()" id="addChildBtn" class="btn-primary">
                <i class="fas fa-plus"></i> AGREGAR NIÑO
              </button>
            </div>
          <ul class="list" id="childrenList"></ul>
        </div>
      </div>
    </div>

    <!-- Games Section -->
    <div id="games-section" class="section">
      <div class="grid">
        <!-- Registrar Juego -->
        <div class="card">
          <h2><i class="fas fa-dice"></i> Registrar Juego</h2>
          <div class="form-row">
            <div class="form-group">
              <input type="text" id="gameName" placeholder="Nombre del juego" maxlength="50">
            </div>
            <div class="form-group">
              <button onclick="addGame()" id="addGameBtn">
                <i class="fas fa-plus"></i> Agregar Juego
              </button>
            </div>
          </div>
          <ul class="list" id="gamesList"></ul>
        </div>
      </div>
    </div>
  </div>
  </div> <!-- Cerrar main-content -->

  <!-- Status Message -->
  <div id="statusMessage" class="status-message">
    <span class="status-text"></span>
    <button class="status-close" onclick="hideStatusMessage()" title="Cerrar">
      <i class="fas fa-times"></i>
    </button>
  </div>

  <!-- Modal -->
  <div id="customModal" class="modal">
    <div class="modal-content">
      <h2 id="modalTitle"><i class="fas fa-bell"></i> ¡Tiempo terminado!</h2>
      <p id="modalMsg"></p>
      <button onclick="closeModal()" class="btn-success">
        <i class="fas fa-check"></i> Entendido
      </button>
    </div>
  </div>

  <!-- Modal de Extensión de Tiempo -->
  <div id="extendModal" class="modal">
    <div class="modal-content">
      <h2><i class="fas fa-clock"></i> Extender Tiempo</h2>
      <p id="extendMsg"></p>
      <div class="form-group">
        <label>Tiempo adicional (minutos):</label>
        <input type="number" id="extendTimeInput" min="1" max="60" value="5">
      </div>
      <div class="modal-buttons">
        <button onclick="confirmExtendTime()" class="btn-success">
          <i class="fas fa-plus"></i> Extender
        </button>
        <button onclick="closeExtendModal()" class="btn-danger">
          <i class="fas fa-times"></i> Cancelar
        </button>
      </div>
    </div>
  </div>

  <!-- Modal de Edición de Niño -->
  <div id="editChildModal" class="modal">
    <div class="modal-content">
      <h2><i class="fas fa-edit"></i> Editar Información del Niño</h2>
      <div class="form-group">
        <label for="editChildName">Nombre del niño:</label>
        <input type="text" id="editChildName" placeholder="Ej: Juan" maxlength="30" required>
      </div>
      <div class="form-group">
        <label for="editChildNickname">Apodo (opcional):</label>
        <input type="text" id="editChildNickname" placeholder="Ej: Juanito" maxlength="20">
      </div>
      <div class="form-group">
        <label for="editFatherName">Nombre del padre (opcional):</label>
        <input type="text" id="editFatherName" placeholder="Ej: Carlos" maxlength="30">
      </div>
      <div class="form-group">
        <label for="editMotherName">Nombre de la madre (opcional):</label>
        <input type="text" id="editMotherName" placeholder="Ej: María" maxlength="30">
      </div>
      <div class="modal-buttons">
        <button onclick="confirmEditChild()" class="btn-success">
          <i class="fas fa-save"></i> Guardar Cambios
        </button>
        <button onclick="closeEditChildModal()" class="btn-danger">
          <i class="fas fa-times"></i> Cancelar
        </button>
      </div>
    </div>
  </div>

  <script>
    // Configuración de API - detectar entorno
    const api = window.location.origin;
    console.log('API URL:', api);
    console.log('Environment:', window.location.hostname);

    // Variables para el dashboard
    let dashboardStats = null;
    
    // Variables para notificaciones
    let notificationPermission = null;
    
    // Variables para atajos de teclado
    let keyboardShortcuts = {
      '1': () => showSection('dashboard'),
      '2': () => showSection('sessions'),
      '3': () => showSection('children'),
      '4': () => showSection('games'),
      'Escape': () => closeModal() || closeExtendModal() || closeEditChildModal(),
      'Delete': () => dismissAllAlerts() // Ctrl+Delete para cerrar todas las alertas
    };

    // Funciones de notificaciones push
    async function requestNotificationPermission() {
      if (!('Notification' in window)) {
        console.log('Este navegador no soporta notificaciones');
        return false;
      }
      
      if (Notification.permission === 'granted') {
        return true;
      }
      
      if (Notification.permission === 'denied') {
        console.log('Notificaciones denegadas por el usuario');
        return false;
      }
      
      const permission = await Notification.requestPermission();
      notificationPermission = permission === 'granted';
      return notificationPermission;
    }

    function showBrowserNotification(title, message, icon = null) {
      if (notificationPermission && 'Notification' in window) {
        const notification = new Notification(title, {
          body: message,
          icon: icon || '/favicon.ico',
          tag: 'temporizador-juegos',
          requireInteraction: true
        });
        
        // Auto-cerrar después de 10 segundos
        setTimeout(() => {
          notification.close();
        }, 10000);
        
        // Cerrar al hacer click
        notification.onclick = () => {
          window.focus();
          notification.close();
        };
      }
    }

    // Funciones de navegación
    function showSection(sectionName) {
      // Ocultar todas las secciones
      document.querySelectorAll('.section').forEach(section => {
        section.classList.remove('active');
      });
      
      // Desactivar todos los botones de navegación
      document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Mostrar la sección seleccionada
      const section = document.getElementById(sectionName + '-section');
      if (section) {
        section.classList.add('active');
      }
      
      // Activar el botón correspondiente (tanto desktop como móvil)
      const desktopNavBtn = document.getElementById('nav-' + sectionName);
      const mobileNavBtn = document.querySelector('.sidebar .nav-btn[id="nav-' + sectionName + '"]');
      
      // Desactivar todos los botones primero
      document.querySelectorAll('.desktop-nav-btn, .nav-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Activar el botón correspondiente
      if (desktopNavBtn) {
        desktopNavBtn.classList.add('active');
      }
      if (mobileNavBtn) {
        mobileNavBtn.classList.add('active');
      }
      
      // Actualizar dashboard si es necesario
      if (sectionName === 'dashboard') {
        updateDashboard();
      }
      
      // Cerrar menú móvil al navegar
      closeMobileMenu();
      
      // Limpiar alertas persistentes al cambiar de sección
      clearAllPersistentAlerts();
      
      // Guardar sección activa en localStorage
      localStorage.setItem('activeSection', sectionName);
    }

    // Funciones del menú móvil
    function toggleMobileMenu() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.querySelector('.sidebar-overlay');
      
      sidebar.classList.toggle('open');
      overlay.classList.toggle('active');
    }

    function closeMobileMenu() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.querySelector('.sidebar-overlay');
      
      sidebar.classList.remove('open');
      overlay.classList.remove('active');
    }

    // Sistema de búsqueda de niños
    function initializeChildSearch() {
      const searchInput = document.getElementById('childSearchInput');
      const searchResults = document.getElementById('childSearchResults');
      const selectedChildId = document.getElementById('selectedChildId');

      if (!searchInput) return;

      let searchTimeout;

      searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim().toLowerCase();

        if (query.length < 2) {
          hideSearchResults();
          return;
        }

        searchTimeout = setTimeout(() => {
          searchChildren(query);
        }, 300);
      });

      searchInput.addEventListener('focus', () => {
        if (searchInput.value.trim().length >= 2) {
          searchChildren(searchInput.value.trim().toLowerCase());
        }
      });

      // Cerrar resultados al hacer clic fuera
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.child-search-container')) {
          hideSearchResults();
        }
      });
    }

    function searchChildren(query) {
      const results = childrenCache.filter(child => {
        const name = (child.displayName || child.name).toLowerCase();
        const fatherName = ((child.father_name || child.fatherName) || '').toLowerCase();
        const motherName = ((child.mother_name || child.motherName) || '').toLowerCase();
        
        return name.includes(query) || 
               fatherName.includes(query) || 
               motherName.includes(query);
      });

      displaySearchResults(results);
    }

    function displaySearchResults(results) {
      const searchResults = document.getElementById('childSearchResults');
      const searchInput = document.getElementById('childSearchInput');

      if (!searchResults || !searchInput) return;

      if (results.length === 0) {
        searchResults.innerHTML = '<div class="no-results">No se encontraron niños</div>';
      } else {
        searchResults.innerHTML = results.map(child => {
          const displayName = child.displayName || child.name;
          const avatar = child.avatar || child.name.charAt(0).toUpperCase();
          
          let parentsInfo = '';
          const fatherName = child.father_name || child.fatherName;
          const motherName = child.mother_name || child.motherName;
          
          if (fatherName && motherName) {
            parentsInfo = `${fatherName} & ${motherName}`;
          } else if (fatherName) {
            parentsInfo = `Papá: ${fatherName}`;
          } else if (motherName) {
            parentsInfo = `Mamá: ${motherName}`;
          }

          return `
            <div class="child-search-item" onclick="selectChild(${child.id}, '${displayName.replace(/'/g, "\\'")}')">
              <div class="child-avatar">${avatar}</div>
              <div class="child-info">
                <div class="child-name">${displayName}</div>
                ${parentsInfo ? `<div class="child-parents">${parentsInfo}</div>` : ''}
              </div>
              <div class="child-stats">${child.totalTimePlayed} min</div>
            </div>
          `;
        }).join('');
      }

      searchResults.classList.add('show');
    }

    function selectChild(childId, childName) {
      const searchInput = document.getElementById('childSearchInput');
      const selectedChildId = document.getElementById('selectedChildId');
      const searchResults = document.getElementById('childSearchResults');

      if (searchInput) {
        searchInput.value = childName;
      }
      if (selectedChildId) {
        selectedChildId.value = childId;
      }

      hideSearchResults();
    }

    function hideSearchResults() {
      const searchResults = document.getElementById('childSearchResults');
      if (searchResults) {
        searchResults.classList.remove('show');
      }
    }

    // Funciones del dashboard
    async function fetchDashboardStats() {
      try {
        const res = await fetchWithRetry(api + '/admin/status');
        if (res.ok) {
          dashboardStats = await res.json();
          return dashboardStats;
        }
      } catch (error) {
        console.error('Error fetching dashboard stats:', error);
      }
      return null;
    }

    function updateDashboard() {
      // Actualizar dashboard con datos del caché local
      renderDashboard();
    }

    function renderDashboard() {
      // Usar datos del caché local para mostrar información real
      const totalChildren = childrenCache.length;
      const totalGames = gamesCache.length;
      const activeSessions = activeSessionsData.length;
      
      // Calcular tiempo total jugado desde el caché - CON DEBUGGING
      let totalTimePlayed = 0;
      console.group('📊 Dashboard Stats Calculation');
      console.log('📊 Children Cache:', childrenCache);
      
      childrenCache.forEach((child, index) => {
        const childTime = child.totalTimePlayed || 0;
        totalTimePlayed += childTime;
        console.log(`👶 Child ${index + 1}:`, {
          name: child.name,
          totalTimePlayed: childTime,
          hasTimeData: !!child.totalTimePlayed
        });
      });
      
      console.log('📊 Total Time Played:', totalTimePlayed);
      console.groupEnd();

      // Actualizar estadísticas principales
      document.getElementById('totalChildren').textContent = totalChildren;
      document.getElementById('totalGames').textContent = totalGames;
      document.getElementById('activeSessionsCount').textContent = activeSessions;
      document.getElementById('totalTimePlayed').textContent = totalTimePlayed;

      // Actualizar ranking de niños basado en tiempo jugado - VERSIÓN MEJORADA
      const childrenRanking = document.getElementById('childrenRanking');
      const sortedChildren = [...childrenCache].sort((a, b) => (b.totalTimePlayed || 0) - (a.totalTimePlayed || 0));
      
      if (sortedChildren.length > 0) {
        childrenRanking.innerHTML = sortedChildren.slice(0, 5).map((child, index) => {
        // Información de padres para diferenciación en el ranking
        let parentsInfo = getParentsInfo(child, 'html');
          
          return `
          <li class="ranking-item">
            <div class="ranking-position">${index + 1}°</div>
              <div class="ranking-name">
                ${child.displayName || child.name}${parentsInfo}
              </div>
            <div class="ranking-time">${child.totalTimePlayed || 0} min</div>
          </li>
          `;
        }).join('');
      } else {
        childrenRanking.innerHTML = '<li class="ranking-item">No hay datos disponibles</li>';
      }

      // Actualizar ranking de juegos (por ahora mostrar todos los juegos)
      const gamesRanking = document.getElementById('gamesRanking');
      if (gamesCache.length > 0) {
        gamesRanking.innerHTML = gamesCache.slice(0, 5).map((game, index) => `
          <li class="ranking-item">
            <div class="ranking-position">${index + 1}°</div>
            <div class="ranking-name">${game.name}</div>
            <div class="ranking-time">-</div>
          </li>
        `).join('');
      } else {
        gamesRanking.innerHTML = '<li class="ranking-item">No hay datos disponibles</li>';
      }
    }

    // Estado de la aplicación - ROBUSTO
    let isLoading = false;
    let activeSessionsData = [];
    let childrenCache = [];
    let gamesCache = [];
    let timerIntervals = new Map();
    let currentExtendSession = null;
    let currentEditChild = null; // Para almacenar el ID del niño que se está editando
    // FUNCIONES DE COMPATIBILIDAD CRÍTICAS - DEBEN ESTAR PRIMERO
    function showStatusMessage(text, type = 'success', sessionId = null, options = {}) {
      console.log(`🔔 showStatusMessage (compatibilidad): ${text} [${type}]`);
      
      // Usar showSmartAlert como función principal
      if (typeof showSmartAlert === 'function') {
        showSmartAlert(text, type, sessionId, options);
      } else {
        // Fallback básico si showSmartAlert no está disponible
        console.warn('⚠️ showSmartAlert no disponible, usando fallback básico');
        
        // Crear elemento de alerta básico
        let msg = document.getElementById('statusMessage');
        if (!msg) {
          msg = document.createElement('div');
          msg.id = 'statusMessage';
          msg.className = 'status-message';
          msg.innerHTML = `
            <span class="status-text"></span>
            <button class="status-close" onclick="hideStatusMessage()" title="Cerrar">
              <i class="fas fa-times"></i>
            </button>
          `;
          document.body.appendChild(msg);
        }
        
        // Mostrar mensaje
        const textSpan = msg.querySelector('.status-text');
        if (textSpan) {
          textSpan.textContent = text;
        }
        
        // Aplicar estilos según tipo
        msg.className = `status-message ${type}`;
        msg.style.display = 'block';
        
        // Auto-ocultar después de 5 segundos
        setTimeout(() => {
          if (msg) {
            msg.style.display = 'none';
          }
        }, 5000);
      }
    }
    

    // Variables globales críticas para el sistema de voz
    let voiceNotificationsEnabled = true; // Control de notificaciones de voz
    let browserNotificationsEnabled = false; // Control de notificaciones del navegador
    let voicePermissionsGranted = false; // Estado de permisos de voz
    let voiceSystemActivated = false; // Estado de activación del sistema de voz
    
    // Sistema de cola de voz para evitar interrupciones
    let voiceQueue = []; // Cola de mensajes de voz pendientes
    let isVoicePlaying = false; // Estado de reproducción actual
    let voiceQueueProcessing = false; // Estado de procesamiento de cola
    
    // Sistema de alertas inteligente para evitar redundancias
    let alertPreferences = {
      showVisualAlerts: true,        // Mostrar alertas visuales
      showVoiceAlerts: true,         // Mostrar alertas de voz
      showBrowserNotifications: true, // Mostrar notificaciones del navegador
      showConfigAlerts: true,        // Mostrar alertas de configuración
      showStatusAlerts: true,        // Mostrar alertas de estado (inicio/fin sesión)
      showErrorAlerts: true,         // Mostrar alertas de error
      showSuccessAlerts: true,       // Mostrar alertas de éxito
      show30SecondAlerts: true      // Mostrar alertas de 30 segundos
    };
    
    // Sistema de alertas adaptativo para evitar contaminación de audio
    let adaptiveAlertSystem = {
      maxConcurrentAlerts: 3,        // Máximo de alertas simultáneas
      alertReductionThreshold: 5,    // Reducir alertas si hay 5+ niños
      singleAlertMode: false,        // Modo de una sola alerta para muchos niños
      audioContaminationPrevention: true // Prevenir contaminación de audio
    };
    
    // Asegurar que las variables estén disponibles globalmente
    window.voiceNotificationsEnabled = voiceNotificationsEnabled;
    window.browserNotificationsEnabled = browserNotificationsEnabled;
    window.voicePermissionsGranted = voicePermissionsGranted;
    window.voiceSystemActivated = voiceSystemActivated;

    // FUNCIÓN HELPER PARA EVITAR DUPLICACIÓN DE CÓDIGO
    function getParentsInfo(child, format = 'simple') {
      if (!child) return '';
      
      const fatherName = child.fatherName || child.father_name;
      const motherName = child.motherName || child.mother_name;
      
      if (!fatherName && !motherName) return '';
      
      let parentsInfo = '';
      
      if (format === 'html') {
        // Formato HTML para listas y rankings
        if (fatherName && motherName) {
          parentsInfo = `<br><small class="parents-info"><i class="fas fa-users"></i> ${fatherName} & ${motherName}</small>`;
        } else if (fatherName) {
          parentsInfo = `<br><small class="parents-info"><i class="fas fa-users"></i> Papá: ${fatherName}</small>`;
        } else if (motherName) {
          parentsInfo = `<br><small class="parents-info"><i class="fas fa-users"></i> Mamá: ${motherName}</small>`;
        }
      } else if (format === 'history') {
        // Formato para historial
        if (fatherName && motherName) {
          parentsInfo = `<div class="history-parents"><i class="fas fa-users"></i> ${fatherName} & ${motherName}</div>`;
        } else if (fatherName) {
          parentsInfo = `<div class="history-parents"><i class="fas fa-users"></i> Papá: ${fatherName}</div>`;
        } else if (motherName) {
          parentsInfo = `<div class="history-parents"><i class="fas fa-users"></i> Mamá: ${motherName}</div>`;
        }
      } else {
        // Formato simple (default)
        if (fatherName && motherName) {
          parentsInfo = ` (${fatherName} & ${motherName})`;
        } else if (fatherName) {
          parentsInfo = ` (Papá: ${fatherName})`;
        } else if (motherName) {
          parentsInfo = ` (Mamá: ${motherName})`;
        }
      }
      
      return parentsInfo;
    }

    // Función para detectar género por nombre - FUNCIÓN SIMPLE Y ESTABLE
    function detectGenderByName(name) {
      if (!name || typeof name !== 'string') {
        return 'unknown';
      }
      
      const normalizedName = name.toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '');
      
      const femaleNames = [
        'sofia', 'maria', 'ana', 'lucia', 'carla', 'laura', 'isabella', 'valentina',
        'camila', 'natalia', 'andrea', 'paula', 'fernanda', 'alejandra', 'diana'
      ];
      
      const maleNames = [
        'david', 'mathias', 'cristian', 'ramon', 'santiago', 'carlos', 'juan', 'pedro',
        'miguel', 'antonio', 'jose', 'manuel', 'francisco', 'alejandro', 'daniel'
      ];
      
      if (femaleNames.includes(normalizedName)) {
        return 'female';
      }
      if (maleNames.includes(normalizedName)) {
        return 'male';
      }
      
      return 'unknown';
    }

    // Función para detectar el navegador
    function detectBrowser() {
      const userAgent = navigator.userAgent.toLowerCase();
      if (userAgent.includes('safari') && !userAgent.includes('chrome')) {
        return 'safari';
      } else if (userAgent.includes('firefox')) {
        return 'firefox';
      } else if (userAgent.includes('chrome')) {
        return 'chrome';
      } else if (userAgent.includes('edge')) {
        return 'edge';
      }
      return 'unknown';
    }

    // Función helper para seleccionar voz femenina en español (optimizada por navegador)
    function getFemaleSpanishVoice() {
      const browser = detectBrowser();
      console.log('🌐 Navegador detectado:', browser);
      
      // Intentar cargar voces si no están disponibles
      let voices = window.speechSynthesis.getVoices();
      
      // Si no hay voces cargadas, intentar forzar la carga
      if (voices.length === 0) {
        console.log('🔄 Forzando carga de voces...');
        // En algunos navegadores necesitamos hacer esto
        window.speechSynthesis.getVoices();
        voices = window.speechSynthesis.getVoices();
      }
      
      const spanishVoices = voices.filter(voice => voice.lang.startsWith('es'));
      
      console.log('🎙️ Todas las voces en español:', spanishVoices.map(v => ({ name: v.name, lang: v.lang, localService: v.localService })));
      
      // Lista de nombres masculinos a excluir
      const maleNames = ['eddy', 'carlos', 'juan', 'diego', 'male', 'men', 'man', 'masculino', 'antonio', 'miguel', 'pedro', 'jose', 'manuel', 'rafael', 'daniel', 'andres', 'roberto', 'fernando', 'eduardo', 'alejandro', 'sergio', 'pablo', 'mario', 'ricardo', 'alberto', 'enrique', 'ramon', 'javier', 'gabriel', 'luis', 'felipe', 'sebastian', 'adrian', 'david'];
      
      // Función para verificar si una voz es masculina
      const isMaleVoice = (voiceName) => {
        return maleNames.some(maleName => voiceName.toLowerCase().includes(maleName));
      };
      
      // Función ULTRA ESTRICTA para seleccionar solo voces humanas reales
      const isQualityVoice = (voice) => {
        const voiceName = voice.name.toLowerCase();
        const lang = voice.lang.toLowerCase();
        
        // CRITERIOS ULTRA ESTRICTOS PARA SONIDO HUMANO:
        const hasSpanishAccent = lang.includes('es-es') || lang.includes('es-mx') || lang.startsWith('es');
        const isLocal = voice.localService;
        
        // EVITAR TODAS las voces robóticas/artificiales
        const notRobotic = !['robot', 'artificial', 'neural', 'tts', 'synthetic', 'digital', 'machine', 'auto', 'generated', 'system', 'speak', 'voice', 'speech', 'sapi', 'espeak', 'festival', 'mary', 'enhanced', 'premium', 'cloud'].some(flag => voiceName.includes(flag));
        
        // SOLO nombres que suenen 100% humanos
        const isHuman = ['maria', 'monica', 'lucia', 'sofia', 'carmen', 'ana', 'laura', 'isabel', 'teresa', 'paula', 'claudia', 'natalia', 'veronica', 'patricia', 'cristina', 'rosa', 'elena'].some(name => voiceName.includes(name));
        
        // ADICIONAL: preferir voces con nombres reales de personas
        const hasRealPersonName = voiceName.match(/\b(maria|monica|lucia|sofia|carmen|ana|laura|isabel|teresa|paula|claudia|natalia|veronica|patricia|cristina|rosa|elena)\b/);
        
        return hasSpanishAccent && isLocal && notRobotic && isHuman && hasRealPersonName;
      };
      
      // SELECCIÓN ULTRA ESTRICTA: solo voces que suenen 100% humanas
      let selectedVoice = spanishVoices.find(voice => {
        const voiceName = voice.name.toLowerCase();
        const isNotMale = !isMaleVoice(voiceName);
        const isQuality = isQualityVoice(voice);
        return isNotMale && isQuality;
      });
      
      // FALLBACK 1: voces con nombres reales pero menos estricto
      if (!selectedVoice) {
        selectedVoice = spanishVoices.find(voice => {
          const voiceName = voice.name.toLowerCase();
          const isNotMale = !isMaleVoice(voiceName);
          const isRealName = ['maria', 'monica', 'lucia', 'sofia', 'carmen', 'ana', 'laura', 'isabel', 'teresa', 'paula', 'claudia'].some(name => voiceName.includes(name));
          return isNotMale && isRealName;
        });
      }
      
      // FALLBACK 2: cualquier voz femenina que no sea claramente robótica
      if (!selectedVoice) {
        selectedVoice = spanishVoices.find(voice => {
          const voiceName = voice.name.toLowerCase();
          const isNotMale = !isMaleVoice(voiceName);
          const notObviouslyRobotic = !['robot', 'artificial', 'neural', 'tts', 'synthetic', 'digital', 'machine', 'auto', 'generated'].some(flag => voiceName.includes(flag));
          return isNotMale && notObviouslyRobotic;
        });
      }
      
      // Último recurso: usar primera voz disponible que NO sea claramente masculina
      if (!selectedVoice && spanishVoices.length > 0) {
        selectedVoice = spanishVoices.find(voice => {
          return !isMaleVoice(voice.name);
        }) || spanishVoices[0];
      }
      
      // Verificar una vez más que la voz seleccionada no sea masculina
      if (selectedVoice && isMaleVoice(selectedVoice.name)) {
        console.warn('⚠️ Voz seleccionada es masculina, buscando alternativa...');
        selectedVoice = spanishVoices.find(voice => {
          return !isMaleVoice(voice.name) && voice !== selectedVoice;
        });
      }
      
      console.log('👩 Voz femenina seleccionada:', selectedVoice ? `${selectedVoice.name} (${selectedVoice.lang})` : 'ninguna');
      return selectedVoice;
    }

    // Sistema de voz híbrido para sonido humano en TODOS los navegadores
    function getVoiceParameters() {
      const browser = detectBrowser();
      
      // Configuración UNIVERSAL para sonido humano en todos los navegadores
      const universalConfig = {
        rate: 0.75,      // Velocidad óptima para sonido humano
        pitch: 1.15,     // Pitch óptimo para sonido humano
        volume: 0.9,     // Volumen óptimo
        lang: 'es-ES'    // Idioma español
      };
      
      // Ajustes específicos por navegador para maximizar sonido humano
      const browserAdjustments = {
        safari: { rate: 0.9, pitch: 1.1, volume: 0.8 },      // Safari ya excelente
        firefox: { rate: 0.6, pitch: 1.2, volume: 0.95 },    // Firefox - parámetros más agresivos
        chrome: { rate: 0.7, pitch: 1.15, volume: 0.9 },    // Chrome - parámetros balanceados
        edge: { rate: 0.7, pitch: 1.15, volume: 0.9 },        // Edge - igual que Chrome
        default: { rate: 0.75, pitch: 1.15, volume: 0.9 }   // Fallback universal
      };
      
      const params = { ...universalConfig, ...browserAdjustments[browser] || browserAdjustments.default };
      
      // POST-PROCESAMIENTO UNIVERSAL para sonido humano máximo
      if (browser === 'firefox') {
        // Firefox - parámetros más agresivos para compensar limitaciones
        params.rate = Math.max(params.rate * 0.85, 0.5); // Más lento para sonar humano
        params.pitch = Math.min(params.pitch * 1.1, 1.4); // Pitch más alto
        params.volume = Math.min(params.volume * 1.1, 1.0); // Volumen más alto
      } else if (browser === 'chrome' || browser === 'edge') {
        // Chrome/Edge - parámetros balanceados
        params.rate = Math.max(params.rate * 0.9, 0.6); // Ligeramente más lento
        params.pitch = Math.min(params.pitch * 1.05, 1.3); // Pitch ligeramente más alto
        params.volume = Math.min(params.volume * 1.05, 1.0); // Volumen ligeramente más alto
      }
      
      return params;
    }

    // Función de prueba COMPLETA para evaluar calidad de voz en todos los navegadores
    function testAllBrowsersVoiceQuality() {
      const browser = detectBrowser();
      console.log(`🧪 INICIANDO PRUEBA DE CALIDAD DE VOZ PARA ${browser.toUpperCase()}`);
      
      const testPhrases = [
        "Hola, soy una prueba de voz natural",
        "El tiempo de juego ha terminado",
        "María, tu sesión ha finalizado",
        "David Carlos, es hora de terminar"
      ];
      
      let currentPhrase = 0;
      
      function testNextPhrase() {
        if (currentPhrase >= testPhrases.length) {
          console.log(`✅ PRUEBA COMPLETADA PARA ${browser.toUpperCase()}`);
          console.log(`📊 EVALUACIÓN REQUERIDA:`);
          console.log(`   - ¿La voz suena natural y humana?`);
          console.log(`   - ¿El acento español es correcto?`);
          console.log(`   - ¿La velocidad es apropiada?`);
          console.log(`   - ¿Comparado con Safari, ¿qué tal?`);
          return;
        }
        
        const phrase = testPhrases[currentPhrase];
        console.log(`🎤 Prueba ${currentPhrase + 1}/${testPhrases.length}: "${phrase}"`);
        
        // Obtener parámetros actuales
        const voiceParams = getVoiceParameters();
        console.log(`⚙️ Parámetros actuales:`, voiceParams);
        
        // Obtener voz seleccionada
        const selectedVoice = getFemaleSpanishVoice();
        console.log(`🎭 Voz seleccionada:`, selectedVoice ? `${selectedVoice.name} (${selectedVoice.lang})` : 'ninguna');
        
        const utterance = new SpeechSynthesisUtterance(phrase);
        utterance.lang = voiceParams.lang;
        utterance.rate = voiceParams.rate;
        utterance.pitch = voiceParams.pitch;
        utterance.volume = voiceParams.volume;
        
        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }
        
        utterance.onend = () => {
          setTimeout(() => {
            currentPhrase++;
            testNextPhrase();
          }, 2000);
        };
        
        utterance.onerror = (event) => {
          console.error(`❌ Error en síntesis de voz:`, event);
          currentPhrase++;
          setTimeout(() => testNextPhrase(), 1000);
        };
        
        speechSynthesis.speak(utterance);
      }
      
      testNextPhrase();
    }
    
    // Función para probar diferentes configuraciones y encontrar la óptima
    function testVoiceConfigurations() {
      const browser = detectBrowser();
      console.log(`🔬 PRUEBA DE CONFIGURACIONES PARA ${browser.toUpperCase()}`);
      
      const configurations = [
        { rate: 0.3, pitch: 1.5, name: 'EXTREMO lento + pitch muy alto' },
        { rate: 0.4, pitch: 1.4, name: 'MUY lento + pitch alto (actual Firefox)' },
        { rate: 0.5, pitch: 1.3, name: 'Muy lento + pitch alto (actual Chrome)' },
        { rate: 0.6, pitch: 1.2, name: 'Lento + pitch medio-alto' },
        { rate: 0.7, pitch: 1.1, name: 'Medio-lento + pitch medio' }
      ];
      
      let currentConfig = 0;
      
      function testNextConfig() {
        if (currentConfig >= configurations.length) {
          console.log(`🎯 PRUEBA DE CONFIGURACIONES COMPLETADA`);
          console.log(`📝 SELECCIONA LA CONFIGURACIÓN QUE SUENA MÁS HUMANA:`);
          configurations.forEach((config, index) => {
            console.log(`   ${index + 1}. ${config.name} (rate: ${config.rate}, pitch: ${config.pitch})`);
          });
          return;
        }
        
        const config = configurations[currentConfig];
        console.log(`🎛️ Probando configuración ${currentConfig + 1}: ${config.name}`);
        console.log(`   Rate: ${config.rate}, Pitch: ${config.pitch}`);
        
        const utterance = new SpeechSynthesisUtterance(`Prueba ${currentConfig + 1}: ${config.name}`);
        utterance.lang = 'es-ES';
        utterance.rate = config.rate;
        utterance.pitch = config.pitch;
        utterance.volume = 0.8;
        
        const selectedVoice = getFemaleSpanishVoice();
        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }
        
        utterance.onend = () => {
          setTimeout(() => {
            currentConfig++;
            testNextConfig();
          }, 3000);
        };
        
        speechSynthesis.speak(utterance);
      }
      
      testNextConfig();
    }
    
    // Función de prueba EXTREMA para encontrar la configuración más humana
    function testExtremeVoiceConfigurations() {
      const browser = detectBrowser();
      console.log(`🔥 PRUEBA EXTREMA DE CONFIGURACIONES PARA ${browser.toUpperCase()}`);
      
      const extremeConfigurations = [
        { rate: 0.2, pitch: 1.6, name: 'ULTRA lento + pitch máximo' },
        { rate: 0.3, pitch: 1.5, name: 'EXTREMO lento + pitch muy alto' },
        { rate: 0.4, pitch: 1.4, name: 'MUY lento + pitch alto' },
        { rate: 0.5, pitch: 1.3, name: 'Lento + pitch alto' },
        { rate: 0.6, pitch: 1.2, name: 'Medio-lento + pitch medio-alto' }
      ];
      
      let currentConfig = 0;
      
      function testNextConfig() {
        if (currentConfig >= extremeConfigurations.length) {
          console.log(`🎯 PRUEBA EXTREMA COMPLETADA`);
          console.log(`📝 SELECCIONA LA CONFIGURACIÓN MÁS HUMANA:`);
          extremeConfigurations.forEach((config, index) => {
            console.log(`   ${index + 1}. ${config.name} (rate: ${config.rate}, pitch: ${config.pitch})`);
          });
          return;
        }
        
        const config = extremeConfigurations[currentConfig];
        console.log(`🔥 Probando configuración EXTREMA ${currentConfig + 1}: ${config.name}`);
        console.log(`   Rate: ${config.rate}, Pitch: ${config.pitch}`);
        
        const utterance = new SpeechSynthesisUtterance(`Prueba extrema ${currentConfig + 1}: ${config.name}`);
        utterance.lang = 'es-ES';
        utterance.rate = config.rate;
        utterance.pitch = config.pitch;
        utterance.volume = 0.9;
        
        const selectedVoice = getFemaleSpanishVoice();
        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }
        
        utterance.onend = () => {
          setTimeout(() => {
            currentConfig++;
            testNextConfig();
          }, 4000);
        };
        
        speechSynthesis.speak(utterance);
      }
      
      testNextConfig();
    }
    
    // Función de prueba ULTRA EXTREMA específica para Firefox
    function testFirefoxUltraExtreme() {
      if (detectBrowser() !== 'firefox') {
        console.log('⚠️ Esta función es específica para Firefox');
        return;
      }
      
      console.log(`🔥 PRUEBA ULTRA EXTREMA PARA FIREFOX`);
      
      const firefoxUltraConfigurations = [
        { rate: 0.1, pitch: 1.8, name: 'ULTRA lento + pitch máximo' },
        { rate: 0.2, pitch: 1.7, name: 'EXTREMO lento + pitch muy alto' },
        { rate: 0.3, pitch: 1.6, name: 'MUY lento + pitch alto (actual)' },
        { rate: 0.4, pitch: 1.5, name: 'Lento + pitch alto' },
        { rate: 0.5, pitch: 1.4, name: 'Medio-lento + pitch alto' }
      ];
      
      let currentConfig = 0;
      
      function testNextConfig() {
        if (currentConfig >= firefoxUltraConfigurations.length) {
          console.log(`🎯 PRUEBA ULTRA EXTREMA DE FIREFOX COMPLETADA`);
          console.log(`📝 SELECCIONA LA CONFIGURACIÓN MÁS HUMANA PARA FIREFOX:`);
          firefoxUltraConfigurations.forEach((config, index) => {
            console.log(`   ${index + 1}. ${config.name} (rate: ${config.rate}, pitch: ${config.pitch})`);
          });
          return;
        }
        
        const config = firefoxUltraConfigurations[currentConfig];
        console.log(`🔥 Firefox Ultra Extremo ${currentConfig + 1}: ${config.name}`);
        console.log(`   Rate: ${config.rate}, Pitch: ${config.pitch}`);
        
        const utterance = new SpeechSynthesisUtterance(`Firefox ultra ${currentConfig + 1}: ${config.name}`);
        utterance.lang = 'es-ES';
        utterance.rate = config.rate;
        utterance.pitch = config.pitch;
        utterance.volume = 0.95;
        
        const selectedVoice = getFemaleSpanishVoice();
        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }
        
        utterance.onend = () => {
          setTimeout(() => {
            currentConfig++;
            testNextConfig();
          }, 5000);
        };
        
        speechSynthesis.speak(utterance);
      }
      
      testNextConfig();
    }
    
    // Sistema de voz híbrido para sonido humano universal
    function getHybridVoiceSystem() {
      const browser = detectBrowser();
      
      // Estrategia 1: Parámetros optimizados por navegador
      const optimizedParams = getVoiceParameters();
      
      // Estrategia 2: Selección de voz inteligente
      const selectedVoice = getFemaleSpanishVoice();
      
      // Estrategia 3: Configuración híbrida universal
      const hybridConfig = {
        // Parámetros base universales
        rate: optimizedParams.rate,
        pitch: optimizedParams.pitch,
        volume: optimizedParams.volume,
        lang: 'es-ES',
        voice: selectedVoice,
        
        // Configuración adicional para sonido humano
        emphasis: 'strong',        // Énfasis fuerte para sonido humano
        pause: 0.1,              // Pausa entre palabras
        breath: true,            // Simular respiración
        natural: true            // Modo natural
      };
      
      return hybridConfig;
    }
    
    // Sistema de cola de voz para evitar interrupciones
    function addToVoiceQueue(message, options = {}) {
      console.log(`📝 Agregando a cola de voz: "${message}"`);
      
      // Agregar mensaje a la cola
      voiceQueue.push({
        message: message,
        options: options,
        timestamp: Date.now()
      });
      
      // Procesar cola si no está en proceso
      if (!voiceQueueProcessing) {
        processVoiceQueue();
      }
    }
    
    function processVoiceQueue() {
      if (voiceQueueProcessing || voiceQueue.length === 0) {
        return;
      }
      
      voiceQueueProcessing = true;
      console.log(`🔄 Procesando cola de voz (${voiceQueue.length} mensajes pendientes)`);
      
      function playNextInQueue() {
        if (voiceQueue.length === 0) {
          voiceQueueProcessing = false;
          isVoicePlaying = false;
          console.log(`✅ Cola de voz completada`);
          return;
        }
        
        const voiceItem = voiceQueue.shift();
        console.log(`🎤 Reproduciendo: "${voiceItem.message}"`);
        
        isVoicePlaying = true;
        const utterance = createHybridUtterance(voiceItem.message, voiceItem.options.alertCount || 1);
        
        utterance.onend = () => {
          console.log(`✅ Mensaje completado: "${voiceItem.message}"`);
          isVoicePlaying = false;
          // Pequeña pausa antes del siguiente mensaje
          setTimeout(playNextInQueue, 500);
        };
        
        utterance.onerror = (e) => {
          console.error(`❌ Error en mensaje: "${voiceItem.message}"`, e);
          isVoicePlaying = false;
          // Continuar con el siguiente mensaje
          setTimeout(playNextInQueue, 100);
        };
        
        speechSynthesis.speak(utterance);
      }
      
      playNextInQueue();
    }
    
    // Función de voz híbrida mejorada con sistema de cola
    function speakWithHybridVoice(message, options = {}) {
      console.log(`🎤 SISTEMA DE VOZ HÍBRIDA CON COLA ACTIVADO`);
      console.log(`📊 Mensaje: "${message}"`);
      console.log(`📊 Estado actual: isVoicePlaying=${isVoicePlaying}, queueLength=${voiceQueue.length}`);
      
      // Agregar a cola en lugar de reproducir inmediatamente
      addToVoiceQueue(message, options);
      
      return {
        message: message,
        queued: true,
        queuePosition: voiceQueue.length
      };
    }
    
    // Función de evaluación del sistema híbrido
    function evaluateHybridVoiceSystem() {
      const browser = detectBrowser();
      console.log(`🔍 EVALUACIÓN DEL SISTEMA DE VOZ HÍBRIDA PARA ${browser.toUpperCase()}`);
      
      const hybridConfig = getHybridVoiceSystem();
      
      console.log(`📊 CONFIGURACIÓN HÍBRIDA:`);
      console.log(`   Rate: ${hybridConfig.rate}`);
      console.log(`   Pitch: ${hybridConfig.pitch}`);
      console.log(`   Volume: ${hybridConfig.volume}`);
      console.log(`   Voice: ${hybridConfig.voice ? hybridConfig.voice.name : 'Sistema'}`);
      console.log(`   Lang: ${hybridConfig.lang}`);
      
      console.log(`🎯 ESTRATEGIAS ACTIVAS:`);
      console.log(`   1. Parámetros optimizados por navegador`);
      console.log(`   2. Selección inteligente de voz`);
      console.log(`   3. Configuración híbrida universal`);
      console.log(`   4. Modulación específica por navegador`);
      
      console.log(`💡 PRUEBA EL SISTEMA HÍBRIDO:`);
      console.log(`   speakWithHybridVoice("Prueba del sistema híbrido")`);
    }
    
    // Función de prueba exhaustiva del sistema híbrido en producción
    function testHybridSystemExhaustive() {
      console.log(`🔥 PRUEBA EXHAUSTIVA DEL SISTEMA HÍBRIDO EN PRODUCCIÓN`);
      console.log(`📅 Fecha: ${new Date().toLocaleString()}`);
      
      const browser = detectBrowser();
      console.log(`🌐 Navegador detectado: ${browser}`);
      
      // Test 1: Verificar funciones híbridas
      console.log(`\n🧪 TEST 1: VERIFICACIÓN DE FUNCIONES HÍBRIDAS`);
      try {
        const hybridConfig = getHybridVoiceSystem();
        console.log(`✅ getHybridVoiceSystem(): OK`);
        console.log(`   Configuración:`, hybridConfig);
        
        if (typeof speakWithHybridVoice === 'function') {
          console.log(`✅ speakWithHybridVoice(): OK`);
        } else {
          console.error(`❌ speakWithHybridVoice(): NO DISPONIBLE`);
        }
        
        if (typeof evaluateHybridVoiceSystem === 'function') {
          console.log(`✅ evaluateHybridVoiceSystem(): OK`);
        } else {
          console.error(`❌ evaluateHybridVoiceSystem(): NO DISPONIBLE`);
        }
      } catch (error) {
        console.error(`❌ ERROR en funciones híbridas:`, error);
      }
      
      // Test 2: Verificar integración con funciones existentes
      console.log(`\n🧪 TEST 2: INTEGRACIÓN CON FUNCIONES EXISTENTES`);
      try {
        if (typeof speakChildName === 'function') {
          console.log(`✅ speakChildName(): DISPONIBLE`);
        } else {
          console.error(`❌ speakChildName(): NO DISPONIBLE`);
        }
        
        if (typeof speakWithRepetition === 'function') {
          console.log(`✅ speakWithRepetition(): DISPONIBLE`);
        } else {
          console.error(`❌ speakWithRepetition(): NO DISPONIBLE`);
        }
        
        if (typeof speakAlertWithRepetition === 'function') {
          console.log(`✅ speakAlertWithRepetition(): DISPONIBLE`);
        } else {
          console.error(`❌ speakAlertWithRepetition(): NO DISPONIBLE`);
        }
      } catch (error) {
        console.error(`❌ ERROR en integración:`, error);
      }
      
      // Test 3: Verificar sistema de voz
      console.log(`\n🧪 TEST 3: SISTEMA DE VOZ`);
      try {
        if ('speechSynthesis' in window) {
          console.log(`✅ Speech Synthesis: DISPONIBLE`);
          console.log(`   Voces disponibles: ${speechSynthesis.getVoices().length}`);
          
          const spanishVoices = speechSynthesis.getVoices().filter(v => v.lang.startsWith('es'));
          console.log(`   Voces en español: ${spanishVoices.length}`);
          
          if (spanishVoices.length > 0) {
            console.log(`   Primera voz ES: ${spanishVoices[0].name} (${spanishVoices[0].lang})`);
          }
        } else {
          console.error(`❌ Speech Synthesis: NO DISPONIBLE`);
        }
      } catch (error) {
        console.error(`❌ ERROR en sistema de voz:`, error);
      }
      
      // Test 4: Verificar variables globales
      console.log(`\n🧪 TEST 4: VARIABLES GLOBALES`);
      try {
        console.log(`   voiceNotificationsEnabled: ${voiceNotificationsEnabled}`);
        console.log(`   voiceSystemActivated: ${voiceSystemActivated}`);
        console.log(`   browserNotificationsEnabled: ${browserNotificationsEnabled}`);
        console.log(`   voicePermissionsGranted: ${voicePermissionsGranted}`);
      } catch (error) {
        console.error(`❌ ERROR en variables globales:`, error);
      }
      
      // Test 5: Prueba de voz híbrida
      console.log(`\n🧪 TEST 5: PRUEBA DE VOZ HÍBRIDA`);
      try {
        console.log(`🎤 Iniciando prueba de voz híbrida...`);
        speakWithHybridVoice("Prueba del sistema híbrido en producción");
        console.log(`✅ Prueba de voz híbrida iniciada`);
      } catch (error) {
        console.error(`❌ ERROR en prueba de voz:`, error);
      }
      
      console.log(`\n🎯 RESUMEN DE PRUEBA EXHAUSTIVA:`);
      console.log(`   Sistema híbrido: ${typeof getHybridVoiceSystem === 'function' ? 'OK' : 'ERROR'}`);
      console.log(`   Voz híbrida: ${typeof speakWithHybridVoice === 'function' ? 'OK' : 'ERROR'}`);
      console.log(`   Integración: ${typeof speakChildName === 'function' ? 'OK' : 'ERROR'}`);
      console.log(`   Speech Synthesis: ${'speechSynthesis' in window ? 'OK' : 'ERROR'}`);
      
      return {
        hybridSystem: typeof getHybridVoiceSystem === 'function',
        hybridVoice: typeof speakWithHybridVoice === 'function',
        integration: typeof speakChildName === 'function',
        speechSynthesis: 'speechSynthesis' in window,
        browser: browser
      };
    }
    
    // Función de prueba crítica para producción
    function testProductionCritical() {
      console.log(`🚨 PRUEBA CRÍTICA DE PRODUCCIÓN - SISTEMA HÍBRIDO`);
      console.log(`⏰ ${new Date().toLocaleString()}`);
      
      const results = {
        critical: true,
        timestamp: new Date().toISOString(),
        tests: {}
      };
      
      // Test crítico 1: Verificar que todas las funciones existen
      console.log(`\n🔍 TEST CRÍTICO 1: EXISTENCIA DE FUNCIONES`);
      const criticalFunctions = [
        'getHybridVoiceSystem',
        'speakWithHybridVoice', 
        'createHybridUtterance',
        'speakChildName',
        'speakWithRepetition',
        'speakAlertWithRepetition'
      ];
      
      criticalFunctions.forEach(funcName => {
        const exists = typeof window[funcName] === 'function';
        results.tests[funcName] = exists;
        console.log(`${exists ? '✅' : '❌'} ${funcName}: ${exists ? 'OK' : 'ERROR'}`);
      });
      
      // Test crítico 2: Verificar configuración híbrida
      console.log(`\n🔍 TEST CRÍTICO 2: CONFIGURACIÓN HÍBRIDA`);
      try {
        const config = getHybridVoiceSystem();
        const hasRequiredProps = config.rate && config.pitch && config.volume && config.lang;
        results.tests.hybridConfig = hasRequiredProps;
        console.log(`${hasRequiredProps ? '✅' : '❌'} Configuración híbrida: ${hasRequiredProps ? 'OK' : 'ERROR'}`);
        console.log(`   Rate: ${config.rate}, Pitch: ${config.pitch}, Volume: ${config.volume}, Lang: ${config.lang}`);
      } catch (error) {
        results.tests.hybridConfig = false;
        console.error(`❌ ERROR en configuración híbrida:`, error);
      }
      
      // Test crítico 3: Verificar Speech Synthesis
      console.log(`\n🔍 TEST CRÍTICO 3: SPEECH SYNTHESIS`);
      const hasSpeechSynthesis = 'speechSynthesis' in window;
      results.tests.speechSynthesis = hasSpeechSynthesis;
      console.log(`${hasSpeechSynthesis ? '✅' : '❌'} Speech Synthesis: ${hasSpeechSynthesis ? 'OK' : 'ERROR'}`);
      
      if (hasSpeechSynthesis) {
        const voices = speechSynthesis.getVoices();
        const spanishVoices = voices.filter(v => v.lang.startsWith('es'));
        console.log(`   Voces totales: ${voices.length}`);
        console.log(`   Voces en español: ${spanishVoices.length}`);
      }
      
      // Test crítico 4: Verificar variables globales críticas
      console.log(`\n🔍 TEST CRÍTICO 4: VARIABLES GLOBALES`);
      const globalVars = [
        'voiceNotificationsEnabled',
        'voiceSystemActivated', 
        'browserNotificationsEnabled'
      ];
      
      globalVars.forEach(varName => {
        const exists = typeof window[varName] !== 'undefined';
        results.tests[varName] = exists;
        console.log(`${exists ? '✅' : '❌'} ${varName}: ${exists ? 'OK' : 'ERROR'}`);
      });
      
      // Test crítico 5: Prueba de voz real
      console.log(`\n🔍 TEST CRÍTICO 5: PRUEBA DE VOZ REAL`);
      try {
        console.log(`🎤 Ejecutando prueba de voz híbrida...`);
        speakWithHybridVoice("Prueba crítica del sistema híbrido en producción");
        results.tests.voiceTest = true;
        console.log(`✅ Prueba de voz ejecutada`);
      } catch (error) {
        results.tests.voiceTest = false;
        console.error(`❌ ERROR en prueba de voz:`, error);
      }
      
      // Resumen crítico
      const allTestsPassed = Object.values(results.tests).every(test => test === true);
      results.allTestsPassed = allTestsPassed;
      
      console.log(`\n🚨 RESUMEN CRÍTICO:`);
      console.log(`   Estado general: ${allTestsPassed ? '✅ SISTEMA OK' : '❌ ERRORES DETECTADOS'}`);
      console.log(`   Tests pasados: ${Object.values(results.tests).filter(t => t).length}/${Object.keys(results.tests).length}`);
      
      if (!allTestsPassed) {
        console.error(`🚨 ERRORES CRÍTICOS DETECTADOS EN PRODUCCIÓN:`);
        Object.entries(results.tests).forEach(([test, passed]) => {
          if (!passed) {
            console.error(`   ❌ ${test}: FALLO`);
          }
        });
      }
      
      return results;
    }
    
    // Funciones auxiliares para sistema de alertas inteligente
    function showVoiceAlert(text, type, options) {
      console.log('🔊 showVoiceAlert llamado con:', { text, type, options });
      
      if (options.consolidated && options.pendingAlerts) {
        // Para alertas consolidadas, usar el sistema de repetición
        console.log('🔊 Usando speakAlertWithRepetition para alertas consolidadas');
        speakAlertWithRepetition(options.pendingAlerts, options.alertCount);
      } else {
        // Para alertas simples, usar voz híbrida
        console.log('🔊 Usando speakWithHybridVoice para alerta simple:', text);
        speakWithHybridVoice(text);
      }
    }
    
    function getNotificationTitle(type) {
      switch (type) {
        case 'warning': return '⏰ Tiempo de Juego Terminado';
        case 'error': return '❌ Error';
        case 'success': return '✅ Éxito';
        case 'info': return 'ℹ️ Información';
        default: return '🔔 Notificación';
      }
    }
    
    // Función para configurar preferencias de alertas
    function configureAlertPreferences(preferences) {
      alertPreferences = { ...alertPreferences, ...preferences };
      console.log('🔧 Preferencias de alertas actualizadas:', alertPreferences);
    }
    
    // Función de prueba del sistema de cola de voz
    function testVoiceQueue() {
      console.log(`🧪 PRUEBA DEL SISTEMA DE COLA DE VOZ`);
      console.log(`📊 Estado inicial: isVoicePlaying=${isVoicePlaying}, queueLength=${voiceQueue.length}`);
      
      // Limpiar cola existente
      voiceQueue = [];
      isVoicePlaying = false;
      voiceQueueProcessing = false;
      
      // Simular escenario de múltiples niños terminando tiempo
      console.log(`🎯 Simulando escenario: Niño A termina tiempo`);
      speakWithHybridVoice("Niño A terminó su tiempo de juego");
      
      setTimeout(() => {
        console.log(`🎯 Simulando escenario: Niño B termina tiempo (debería ir a cola)`);
        speakWithHybridVoice("Niño B terminó su tiempo de juego");
      }, 2000);
      
      setTimeout(() => {
        console.log(`🎯 Simulando escenario: Niño C termina tiempo (debería ir a cola)`);
        speakWithHybridVoice("Niño C terminó su tiempo de juego");
      }, 4000);
      
      console.log(`📝 Prueba iniciada - observa que NO hay interrupciones`);
      console.log(`📊 Estado final: isVoicePlaying=${isVoicePlaying}, queueLength=${voiceQueue.length}`);
    }
    
    // Función de prueba del sistema de alertas inteligente
    function testSmartAlerts() {
      console.log(`🧪 PRUEBA DEL SISTEMA DE ALERTAS INTELIGENTE`);
      console.log(`📊 Preferencias actuales:`, alertPreferences);
      
      // Probar diferentes tipos de alertas
      console.log(`\n🎯 Probando alertas con preferencias actuales:`);
      
      showSmartAlert("Esta es una alerta de éxito", 'success');
      showSmartAlert("Esta es una alerta de información", 'info');
      showSmartAlert("Esta es una alerta de advertencia", 'warning');
      showSmartAlert("Esta es una alerta de error", 'error');
      
      console.log(`\n🔧 Cambiando preferencias para mostrar todas las alertas:`);
      configureAlertPreferences({
        showSuccessAlerts: true,
        showStatusAlerts: true,
        showConfigAlerts: true
      });
      
      console.log(`\n🎯 Probando alertas con todas habilitadas:`);
      showSmartAlert("Ahora deberías ver esta alerta de éxito", 'success');
      showSmartAlert("Y esta alerta de información", 'info');
    }
    
    // Función de prueba del sistema adaptativo de alertas
    function testAdaptiveAlertSystem() {
      console.log(`🧪 PRUEBA DEL SISTEMA ADAPTATIVO DE ALERTAS`);
      console.log(`📊 Sistema adaptativo actual:`, adaptiveAlertSystem);
      
      // Probar diferentes escenarios de cantidad de niños
      console.log(`\n🎯 Probando escenarios de contaminación de audio:`);
      
      // Escenario 1: 1 niño
      console.log(`\n📝 ESCENARIO 1: 1 niño terminando tiempo`);
      speakWithRepetition("Niño A terminó su tiempo de juego", 1);
      
      setTimeout(() => {
        // Escenario 2: 3 niños
        console.log(`\n📝 ESCENARIO 2: 3 niños terminando tiempo`);
        speakWithRepetition("Niños A, B, C terminaron su tiempo de juego", 3);
      }, 5000);
      
      setTimeout(() => {
        // Escenario 3: 5 niños
        console.log(`\n📝 ESCENARIO 3: 5 niños terminando tiempo`);
        speakWithRepetition("5 niños terminaron su tiempo de juego", 5);
      }, 10000);
      
      setTimeout(() => {
        // Escenario 4: 8 niños (contaminación de audio)
        console.log(`\n📝 ESCENARIO 4: 8 niños terminando tiempo (modo consolidado)`);
        speakWithRepetition("8 niños terminaron su tiempo de juego", 8);
      }, 15000);
      
      console.log(`📝 Prueba adaptativa iniciada - observa la reducción de repeticiones`);
    }
    
    // Función para configurar el sistema adaptativo
    function configureAdaptiveSystem(settings) {
      adaptiveAlertSystem = { ...adaptiveAlertSystem, ...settings };
      console.log('🔧 Sistema adaptativo actualizado:', adaptiveAlertSystem);
    }
    

    // Función de diagnóstico para problemas de inicio de sesión
    function diagnoseSessionStart() {
      console.log('🔍 DIAGNÓSTICO DE INICIO DE SESIÓN');
      console.log('=====================================');
      
      // Verificar estado de la aplicación
      console.log('📊 Estado de la aplicación:');
      console.log('- AppState:', AppState);
      console.log('- isStartingSession:', AppState?.isStartingSession);
      
      // Verificar datos de niños
      console.log('👶 Datos de niños:');
      console.log('- childrenCache.length:', childrenCache.length);
      console.log('- childrenCache:', childrenCache);
      
      // Verificar datos de juegos
      console.log('🎮 Datos de juegos:');
      console.log('- gamesCache.length:', gamesCache.length);
      console.log('- gamesCache:', gamesCache);
      
      // Verificar elementos del formulario
      console.log('📝 Elementos del formulario:');
      const selectedChildId = document.getElementById('selectedChildId');
      const gameSelect = document.getElementById('gameSelect');
      const durationInput = document.getElementById('durationInput');
      
      console.log('- selectedChildId:', selectedChildId?.value || 'NO ENCONTRADO');
      console.log('- gameSelect:', gameSelect?.value || 'NO ENCONTRADO');
      console.log('- durationInput:', durationInput?.value || 'NO ENCONTRADO');
      
      // Verificar opciones disponibles
      if (selectedChildId) {
        console.log('- Opciones de niños disponibles:', selectedChildId.options.length);
        for (let i = 0; i < selectedChildId.options.length; i++) {
          console.log(`  ${i}: ${selectedChildId.options[i].value} - ${selectedChildId.options[i].text}`);
        }
      }
      
      if (gameSelect) {
        console.log('- Opciones de juegos disponibles:', gameSelect.options.length);
        for (let i = 0; i < gameSelect.options.length; i++) {
          console.log(`  ${i}: ${gameSelect.options[i].value} - ${gameSelect.options[i].text}`);
        }
      }
      
      // Verificar conectividad
      console.log('🌐 Conectividad:');
      console.log('- API URL:', api);
      console.log('- fetchWithRetry disponible:', typeof fetchWithRetry);
      
      // Verificar errores en consola
      console.log('❌ Errores recientes:');
      console.log('- Revisar consola para errores de red o JavaScript');
      
      console.log('=====================================');
      console.log('🔍 DIAGNÓSTICO COMPLETADO');
      
      return {
        appState: AppState,
        childrenCount: childrenCache.length,
        gamesCount: gamesCache.length,
        selectedChild: selectedChildId?.value,
        selectedGame: gameSelect?.value,
        duration: durationInput?.value
      };
    }
    
    // Hacer funciones disponibles globalmente para pruebas
    window.testAllBrowsersVoiceQuality = testAllBrowsersVoiceQuality;
    window.testVoiceConfigurations = testVoiceConfigurations;
    window.testExtremeVoiceConfigurations = testExtremeVoiceConfigurations;
    window.testFirefoxUltraExtreme = testFirefoxUltraExtreme;
    window.evaluateHybridVoiceSystem = evaluateHybridVoiceSystem;
    window.speakWithHybridVoice = speakWithHybridVoice;
    window.testHybridSystemExhaustive = testHybridSystemExhaustive;
    window.testProductionCritical = testProductionCritical;
    window.testVoiceQueue = testVoiceQueue;
    window.testSmartAlerts = testSmartAlerts;
    window.configureAlertPreferences = configureAlertPreferences;
    window.testAdaptiveAlertSystem = testAdaptiveAlertSystem;
    window.configureAdaptiveSystem = configureAdaptiveSystem;
    window.diagnoseSessionStart = diagnoseSessionStart;


    // ============================================================================
    // FUNCIONES DE SEGURIDAD CRÍTICAS PARA PRODUCCIÓN
    // ============================================================================
    
    // Sanitización HTML para prevenir XSS
    function sanitizeHTML(str) {
      if (typeof str !== 'string') return '';
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
    
    // Validación robusta de entrada
    function validateInput(input, type, min = null, max = null) {
      if (typeof input !== 'string') return null;
      
      const trimmed = input.trim();
      if (trimmed.length === 0) return null;
      
      switch (type) {
        case 'name':
          // Solo letras, espacios, números y caracteres básicos
          if (!/^[a-zA-ZáéíóúÁÉÍÓÚñÑ\s\d\-\.]+$/.test(trimmed)) return null;
          if (trimmed.length < 1 || trimmed.length > 50) return null;
          break;
        case 'number':
          const num = parseInt(trimmed);
          if (isNaN(num)) return null;
          if (min !== null && num < min) return null;
          if (max !== null && num > max) return null;
          return num;
        case 'id':
          const id = parseInt(trimmed);
          if (isNaN(id) || id <= 0) return null;
          return id;
        default:
          return trimmed;
      }
      
      return trimmed;
    }
    
    // Validación específica para duración
    function validateDuration(input) {
      const duration = validateInput(input, 'number', 1, 1440); // 1 min a 24 horas
      if (duration === null) {
        throw new Error('Duración inválida. Debe ser un número entre 1 y 1440 minutos.');
      }
      return duration;
    }
    
    // Validación específica para IDs
    function validateId(input, fieldName) {
      const id = validateInput(input, 'id');
      if (id === null) {
        throw new Error(`${fieldName} inválido. Debe ser un número positivo.`);
      }
      return id;
    }
    
    // Validación específica para nombres
    function validateName(input, fieldName) {
      const name = validateInput(input, 'name');
      if (name === null) {
        throw new Error(`${fieldName} inválido. Solo se permiten letras, números y espacios.`);
      }
      return name;
    }
    
    // Circuit Breaker para APIs
    class CircuitBreaker {
      constructor(threshold = 5, timeout = 60000) {
        this.failures = 0;
        this.threshold = threshold;
        this.timeout = timeout;
        this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
        this.nextAttempt = Date.now();
      }
      
      async execute(fn) {
        if (this.state === 'OPEN') {
          if (Date.now() < this.nextAttempt) {
            throw new Error('Circuit breaker is OPEN. Servicio temporalmente no disponible.');
          }
          this.state = 'HALF_OPEN';
        }
        
        try {
          const result = await fn();
          this.onSuccess();
          return result;
        } catch (error) {
          this.onFailure();
          throw error;
        }
      }
      
      onSuccess() {
        this.failures = 0;
        this.state = 'CLOSED';
      }
      
      onFailure() {
        this.failures++;
        if (this.failures >= this.threshold) {
          this.state = 'OPEN';
          this.nextAttempt = Date.now() + this.timeout;
        }
      }
    }
    
    // Circuit breakers por endpoint
    const circuitBreakers = {
      children: new CircuitBreaker(3, 30000),
      games: new CircuitBreaker(3, 30000),
      sessions: new CircuitBreaker(3, 30000)
    };
    
    // Rate Limiting para operaciones del usuario
    class RateLimiter {
      constructor(maxRequests = 10, windowMs = 60000) {
        this.maxRequests = maxRequests;
        this.windowMs = windowMs;
        this.requests = [];
      }
      
      canMakeRequest() {
        const now = Date.now();
        // Limpiar requests antiguos
        this.requests = this.requests.filter(time => now - time < this.windowMs);
        
        if (this.requests.length >= this.maxRequests) {
          return false;
        }
        
        this.requests.push(now);
        return true;
      }
      
      getTimeUntilReset() {
        if (this.requests.length === 0) return 0;
        const oldestRequest = Math.min(...this.requests);
        return Math.max(0, this.windowMs - (Date.now() - oldestRequest));
      }
    }
    
    const rateLimiter = new RateLimiter(15, 60000); // 15 requests por minuto
    
    // Función para verificar rate limit antes de operaciones
    function checkRateLimit(operation) {
      if (!rateLimiter.canMakeRequest()) {
        const timeLeft = Math.ceil(rateLimiter.getTimeUntilReset() / 1000);
        throw new Error(`Demasiadas solicitudes. Espere ${timeLeft} segundos antes de intentar nuevamente.`);
      }
    }
    let isInitialized = false;
    let isFirstLoad = true;
    let alertedSessions = new Set(); // Para evitar alertas duplicadas
    let pendingTimeAlerts = new Map(); // Para consolidar alertas de tiempo terminado
    let timeAlertTimeout = null; // Para agrupar alertas cercanas en tiempo
    
    // SISTEMA DE COLA DE VOZ PARA EVITAR INTERRUPCIONES
    // (Variables ya declaradas anteriormente)
    
    // SISTEMA ADAPTATIVO DE ALERTAS
    // (Variable ya declarada anteriormente con más funcionalidades)

    // Sistema de alertas inteligente para evitar redundancias
    function showSmartAlert(text, type = 'success', sessionId = null, options = {}) {
      console.log(`🔔 showSmartAlert LLAMADA: "${text}" [${type}] sessionId: ${sessionId}`, options);
      
      // Verificar preferencias de alertas
      if (!shouldShowAlert(type, options)) {
        console.log(`🔇 Alerta suprimida por preferencias: ${text}`);
        return;
      }
      console.log(`✅ Alerta aprobada por preferencias: ${text}`);
      
      // SISTEMA INTELIGENTE DE CONSOLIDACIÓN DE ALERTAS
      if (type === 'warning' && text.includes('quedan solo') && text.includes('segundos')) {
        handleTimeAlert(text, sessionId, options);
        return;
      }
      
      // Determinar qué tipo de alerta mostrar
      const alertTypes = determineAlertTypes(type, options);
      
      // Mostrar alerta visual si está habilitada
      if (alertTypes.visual) {
        showVisualAlert(text, type, sessionId);
      }
      
      // Mostrar alerta de voz si está habilitada
      if (alertTypes.voice && voiceNotificationsEnabled) {
        showVoiceAlert(text, type, options);
      }
      
      // Mostrar notificación del navegador si está habilitada
      if (alertTypes.browser && browserNotificationsEnabled) {
        showBrowserNotification(getNotificationTitle(type), text);
      }
    }
    
    // SISTEMA INTELIGENTE DE CONSOLIDACIÓN DE ALERTAS DE TIEMPO
    function handleTimeAlert(text, sessionId, options) {
      console.log(`🧠 SISTEMA INTELIGENTE: Procesando alerta de tiempo: "${text}"`);
      
      // Extraer información del niño de la alerta
      const childName = extractChildNameFromAlert(text);
      const timeLeft = extractTimeFromAlert(text);
      
      if (!childName) {
        console.log(`⚠️ No se pudo extraer nombre del niño de: "${text}"`);
        showVisualAlert(text, 'warning', sessionId);
        return;
      }
      
      // Agregar a alertas pendientes
      pendingTimeAlerts.set(childName, {
        text: text,
        sessionId: sessionId,
        timeLeft: timeLeft,
        timestamp: Date.now()
      });
      
      console.log(`📊 Alertas pendientes: ${pendingTimeAlerts.size}`);
      
      // Cancelar timeout anterior si existe
      if (timeAlertTimeout) {
        clearTimeout(timeAlertTimeout);
      }
      
      // NO LLAMAR showConsolidatedTimeAlert aquí - solo se debe llamar cuando realmente termina el tiempo
      // timeAlertTimeout = setTimeout(() => {
      //   showConsolidatedTimeAlert();
      // }, 2000); // Esperar 2 segundos para consolidar
    }
    
    // Extraer nombre del niño de la alerta - FUNCIÓN MEJORADA CON ACENTOS
    function extractChildNameFromAlert(text) {
      if (!text || typeof text !== 'string') {
        console.log(`⚠️ extractChildNameFromAlert: texto inválido`);
        return null;
      }
      
      // Regex mejorada que maneja acentos y caracteres especiales
      const match = text.match(/A\s+([a-zA-ZáéíóúÁÉÍÓÚñÑüÜ\s]+?)\s+le\s+quedan/);
      if (match) {
        const name = match[1].trim();
        console.log(`✅ extractChildNameFromAlert: nombre extraído: "${name}"`);
        return name;
      }
      
      console.log(`❌ extractChildNameFromAlert: no se pudo extraer nombre de: "${text}"`);
      return null;
    }
    
    // Extraer tiempo restante de la alerta
    function extractTimeFromAlert(text) {
      const match = text.match(/(\d+)\s+segundos/);
      return match ? parseInt(match[1]) : 0;
    }
    
    // Mostrar alerta consolidada de tiempo - FUNCIÓN UNIFICADA
    function showConsolidatedTimeAlert(childName, parentsInfo) {
      console.log(`🧠 CONSOLIDANDO ALERTA DE TIEMPO: ${childName}`);
      
      // Crear clave única usando nombre + padres para evitar duplicados
      const uniqueKey = `${childName}|${parentsInfo || 'sin_padres'}`;
      
      // Agregar a la lista de alertas pendientes
      pendingTimeAlerts.set(uniqueKey, { name: childName, parents: parentsInfo });
      
      // Esperar un momento para consolidar múltiples alertas
      setTimeout(() => {
        if (pendingTimeAlerts.size === 0) return;
        
        const alerts = Array.from(pendingTimeAlerts.values());
        const alertCount = alerts.length;
        
        console.log(`📊 ALERTAS A CONSOLIDAR:`, alerts);
        
        // Generar mensaje consolidado
        let consolidatedMessage;
        if (alertCount === 1) {
          const alert = alerts[0];
          consolidatedMessage = `¡Atención! ${alert.name} ha terminado su tiempo de juego`;
        } else if (alertCount === 2) {
          const names = alerts.map(a => a.name).join(' y ');
          consolidatedMessage = `¡Atención! ${names} han terminado su tiempo de juego`;
        } else if (alertCount <= 5) {
          const names = alerts.map(a => a.name);
          const lastChild = names.pop();
          const otherChildren = names.join(', ');
          consolidatedMessage = `¡Atención! ${otherChildren} y ${lastChild} han terminado su tiempo de juego`;
        } else {
          consolidatedMessage = `¡Atención! ${alertCount} niños han terminado su tiempo de juego`;
        }
        
        console.log(`🔊 MENSAJE CONSOLIDADO: "${consolidatedMessage}"`);
        
        // Mostrar alerta visual
        showStatusMessage(consolidatedMessage, 'warning');
        
        // Activar notificaciones de voz si están habilitadas
        if (voiceNotificationsEnabled) {
          console.log(`🔊 ACTIVANDO NOTIFICACIONES DE VOZ`);
          speakAlertWithRepetition(alerts, alertCount);
        }
        
        // Limpiar alertas pendientes
        pendingTimeAlerts.clear();
      }, 1000); // Esperar 1 segundo para consolidar
    }
    
    // FUNCIÓN PARA REPRODUCIR MENSAJE DE VOZ DIRECTAMENTE - URGENTE
    async function playVoiceMessage(message, options = {}) {
      console.log(`🔊 playVoiceMessage: "${message}"`);
      
      return new Promise((resolve) => {
        // FORZAR ACTIVACIÓN DE AUDIO - URGENTE
        console.log(`🚨 FORZANDO ACTIVACIÓN DE AUDIO URGENTE`);
        
        // Cancelar cualquier voz anterior
        speechSynthesis.cancel();
        
        // Esperar un momento para asegurar cancelación
        setTimeout(() => {
          // Crear utterance con configuración URGENTE
          const utterance = new SpeechSynthesisUtterance(message);
          
          // CONFIGURACIÓN NATURAL Y INTELIGENTE
          utterance.volume = 0.9; // Volumen alto pero no máximo
          utterance.rate = 0.8;   // Velocidad natural y clara
          utterance.pitch = 1.1;  // Pitch ligeramente más alto para claridad
          utterance.lang = 'es-ES';
          
          // AGREGAR PAUSAS NATURALES AL MENSAJE
          const messageWithPauses = message
            .replace(/\./g, '. ')  // Pausa después de puntos
            .replace(/,/g, ', ')    // Pausa después de comas
            .replace(/:/g, ': ');   // Pausa después de dos puntos
          
          utterance.text = messageWithPauses;
          
          // Configurar voz con fallback URGENTE
          const voice = getFemaleSpanishVoice();
          if (voice) {
            utterance.voice = voice;
            console.log(`🔊 Voz seleccionada: ${voice.name} (${voice.lang})`);
          } else {
            // FALLBACK URGENTE - usar cualquier voz disponible
            const voices = speechSynthesis.getVoices();
            if (voices.length > 0) {
              utterance.voice = voices[0];
              console.log(`🚨 FALLBACK URGENTE: Usando voz ${voices[0].name}`);
            }
          }
          
          // Eventos con diagnóstico URGENTE
          utterance.onstart = () => {
            console.log(`🔊 AUDIO INICIADO: "${message}"`);
            console.log(`🚨 VERIFICAR VOLUMEN DEL NAVEGADOR Y SISTEMA`);
          };
          
          utterance.onend = () => {
            console.log(`🔊 AUDIO TERMINADO: "${message}"`);
            console.log(`🚨 SI NO SE ESCUCHA: Verificar volumen del navegador`);
            resolve();
          };
          
          utterance.onerror = (event) => {
            console.error(`❌ ERROR DE AUDIO URGENTE:`, event.error);
            console.log(`🚨 DIAGNÓSTICO URGENTE:`, {
              error: event.error,
              message: message,
              voicesAvailable: speechSynthesis.getVoices().length,
              voiceSystemActivated: voiceSystemActivated,
              browserMuted: document.muted || false
            });
            resolve();
          };
          
          // FORZAR REPRODUCCIÓN URGENTE
          console.log(`🚨 INICIANDO REPRODUCCIÓN URGENTE: "${message}"`);
          console.log(`🚨 INSTRUCCIONES URGENTES:`);
          console.log(`   1. Verificar que el volumen del navegador esté activado`);
          console.log(`   2. Verificar que el volumen del sistema esté activado`);
          console.log(`   3. Verificar que la pestaña no esté silenciada`);
          
          speechSynthesis.speak(utterance);
          
          // TIMEOUT URGENTE - forzar resolución si no hay respuesta
          setTimeout(() => {
            console.log(`🚨 TIMEOUT URGENTE: Forzando resolución`);
            resolve();
          }, 10000); // 10 segundos timeout
          
        }, 100); // Pequeño delay para asegurar cancelación
      });
    }
    
    // FUNCIÓN DE PRUEBA URGENTE DE AUDIO
    function testAudioUrgent() {
      console.log(`🚨 PRUEBA URGENTE DE AUDIO`);
      console.log(`🚨 INSTRUCCIONES URGENTES:`);
      console.log(`   1. Hacer clic en la pestaña del navegador`);
      console.log(`   2. Verificar que no esté silenciada (icono de altavoz)`);
      console.log(`   3. Verificar volumen del sistema`);
      console.log(`   4. Hacer clic en "VOZ ACTIVADA" para probar`);
      
      // Probar audio inmediatamente
      const testMessage = "PRUEBA URGENTE DE AUDIO - Si escuchas esto, el sistema funciona";
      playVoiceMessage(testMessage);
    }
    
    // Hacer función global para pruebas urgentes
    window.testAudioUrgent = testAudioUrgent;
    
    // PRUEBA DE ESTRÉS COMPLETA - TODOS LOS ESCENARIOS
    function runStressTest() {
      console.log(`🚨 INICIANDO PRUEBA DE ESTRÉS COMPLETA`);
      console.log(`🚨 PROBANDO TODOS LOS ESCENARIOS DE VOZ`);
      
      // ESCENARIO 1: Un niño
      console.log(`\n📝 ESCENARIO 1: Un niño`);
      const scenario1 = [{
        text: "¡Atención! A sofia le quedan solo 5 segundos",
        sessionId: 1,
        timeLeft: 5,
        timestamp: Date.now()
      }];
      speakAlertWithRepetition(scenario1, 1);
      
      setTimeout(() => {
        // ESCENARIO 2: Dos niños
        console.log(`\n📝 ESCENARIO 2: Dos niños`);
        const scenario2 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 3, timestamp: Date.now() }
        ];
        speakAlertWithRepetition(scenario2, 2);
      }, 3000);
      
      setTimeout(() => {
        // ESCENARIO 3: Tres niños
        console.log(`\n📝 ESCENARIO 3: Tres niños`);
        const scenario3 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 3, timestamp: Date.now() },
          { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 2, timestamp: Date.now() }
        ];
        speakAlertWithRepetition(scenario3, 3);
      }, 6000);
      
      setTimeout(() => {
        // ESCENARIO 4: Cinco niños
        console.log(`\n📝 ESCENARIO 4: Cinco niños`);
        const scenario4 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 3, timestamp: Date.now() },
          { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 2, timestamp: Date.now() },
          { text: "¡Atención! A cristian le quedan solo 1 segundo", sessionId: 4, timeLeft: 1, timestamp: Date.now() },
          { text: "¡Atención! A ramon le quedan solo 1 segundo", sessionId: 5, timeLeft: 1, timestamp: Date.now() }
        ];
        speakAlertWithRepetition(scenario4, 5);
      }, 9000);
      
      setTimeout(() => {
        // ESCENARIO 5: Seis niños (consolidado)
        console.log(`\n📝 ESCENARIO 5: Seis niños (consolidado)`);
        const scenario5 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 3, timestamp: Date.now() },
          { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 2, timestamp: Date.now() },
          { text: "¡Atención! A cristian le quedan solo 1 segundo", sessionId: 4, timeLeft: 1, timestamp: Date.now() },
          { text: "¡Atención! A ramon le quedan solo 1 segundo", sessionId: 5, timeLeft: 1, timestamp: Date.now() },
          { text: "¡Atención! A santiago le quedan solo 1 segundo", sessionId: 6, timeLeft: 1, timestamp: Date.now() }
        ];
        speakAlertWithRepetition(scenario5, 6);
      }, 12000);
      
      console.log(`🚨 PRUEBA DE ESTRÉS INICIADA - VERIFICAR CONSOLA Y AUDIO`);
    }
    
    // Hacer función global para prueba de estrés
    window.runStressTest = runStressTest;
    
    // DIAGNÓSTICO COMPLETO DEL SISTEMA DE VOZ
    function diagnoseVoiceSystem() {
      console.log(`🔍 DIAGNÓSTICO COMPLETO DEL SISTEMA DE VOZ`);
      console.log(`==========================================`);
      
      // 1. VERIFICAR ESTADO DEL SISTEMA
      console.log(`\n📊 ESTADO DEL SISTEMA:`);
      console.log(`  - voiceNotificationsEnabled: ${voiceNotificationsEnabled}`);
      console.log(`  - voiceSystemActivated: ${voiceSystemActivated}`);
      console.log(`  - speechSynthesis disponible: ${typeof speechSynthesis !== 'undefined'}`);
      console.log(`  - voces disponibles: ${speechSynthesis.getVoices().length}`);
      console.log(`  - adaptiveAlertSystem.enabled: ${adaptiveAlertSystem.enabled}`);
      
      // 2. PROBAR EXTRACCIÓN DE NOMBRES
      console.log(`\n🧪 PROBANDO EXTRACCIÓN DE NOMBRES:`);
      const testTexts = [
        "¡Atención! A sofia le quedan solo 5 segundos",
        "¡Atención! A david le quedan solo 3 segundos",
        "¡Atención! A mathias le quedan solo 2 segundos"
      ];
      
      testTexts.forEach((text, index) => {
        const name = extractChildNameFromAlert(text);
        const gender = detectGenderByName(name);
        console.log(`  ${index + 1}. "${text}" → Nombre: "${name}", Género: "${gender}"`);
      });
      
      // 3. PROBAR GENERACIÓN DE MENSAJES
      console.log(`\n🎯 PROBANDO GENERACIÓN DE MENSAJES:`);
      
      // Escenario 1: Un niño
      const scenario1 = [{ text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() }];
      const message1 = generateNaturalVoiceMessage(scenario1, 1);
      console.log(`  ESCENARIO 1: "${message1}"`);
      
      // Escenario 2: Dos niños
      const scenario2 = [
        { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() },
        { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 3, timestamp: Date.now() }
      ];
      const message2 = generateNaturalVoiceMessage(scenario2, 2);
      console.log(`  ESCENARIO 2: "${message2}"`);
      
      // Escenario 3: Tres niños
      const scenario3 = [
        { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() },
        { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 3, timestamp: Date.now() },
        { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 2, timestamp: Date.now() }
      ];
      const message3 = generateNaturalVoiceMessage(scenario3, 3);
      console.log(`  ESCENARIO 3: "${message3}"`);
      
      // 4. PROBAR REPETICIONES ADAPTATIVAS
      console.log(`\n🔄 PROBANDO REPETICIONES ADAPTATIVAS:`);
      for (let i = 1; i <= 6; i++) {
        const { repetitions, delay } = calculateAdaptiveRepetitions('', i);
        console.log(`  ${i} niño(s): ${repetitions} repeticiones, delay: ${delay}ms`);
      }
      
      // 5. PROBAR AUDIO DIRECTO
      console.log(`\n🔊 PROBANDO AUDIO DIRECTO:`);
      console.log(`  - Ejecutando testAudioUrgent()...`);
      testAudioUrgent();
      
      console.log(`\n✅ DIAGNÓSTICO COMPLETO FINALIZADO`);
      console.log(`📋 REVISAR LOGS ANTERIORES PARA IDENTIFICAR PROBLEMAS`);
    }
    
    // Hacer función global para diagnóstico
    window.diagnoseVoiceSystem = diagnoseVoiceSystem;
    
    // 🚨 CORRECCIÓN URGENTE DE TODOS LOS PROBLEMAS IDENTIFICADOS
    function fixAllVoiceProblems() {
      console.log(`🚨 APLICANDO CORRECCIONES URGENTES A TODOS LOS PROBLEMAS`);
      console.log(`=======================================================`);
      
      // PROBLEMA 1: extractChildNameFromAlert() más robusto
      function extractChildNameFromAlertFixed(text) {
        if (!text || typeof text !== 'string') {
          console.log(`⚠️ extractChildNameFromAlert: texto inválido`);
          return null;
        }
        
        // Múltiples patrones para mayor robustez
        const patterns = [
          /A (\w+) le quedan/,
          /(\w+) le quedan/,
          /A (\w+) le queda/,
          /(\w+) le queda/
        ];
        
        for (const pattern of patterns) {
          const match = text.match(pattern);
          if (match && match[1]) {
            console.log(`✅ extractChildNameFromAlert: "${match[1]}" extraído de "${text}"`);
            return match[1];
          }
        }
        
        console.log(`❌ extractChildNameFromAlert: no se pudo extraer nombre de "${text}"`);
        return null;
      }
      
      // PROBLEMA 2: detectGenderByName() con acentos
      function detectGenderByNameFixed(name) {
        if (!name || typeof name !== 'string') {
          console.log(`⚠️ detectGenderByName: nombre inválido`);
          return 'unknown';
        }
        
        const normalizedName = name.toLowerCase()
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, ''); // Remover acentos
        
        const femaleNames = [
          'sofia', 'maria', 'ana', 'lucia', 'carla', 'laura', 'isabella', 'valentina',
          'camila', 'natalia', 'andrea', 'paula', 'fernanda', 'alejandra', 'diana'
        ];
        
        const maleNames = [
          'david', 'mathias', 'cristian', 'ramon', 'santiago', 'carlos', 'juan', 'pedro',
          'miguel', 'antonio', 'jose', 'manuel', 'francisco', 'alejandro', 'daniel'
        ];
        
        if (femaleNames.includes(normalizedName)) {
          console.log(`✅ detectGenderByName: "${name}" → female`);
          return 'female';
        }
        if (maleNames.includes(normalizedName)) {
          console.log(`✅ detectGenderByName: "${name}" → male`);
          return 'male';
        }
        
        console.log(`⚠️ detectGenderByName: "${name}" → unknown`);
        return 'unknown';
      }
      
      // PROBLEMA 3: generateNaturalVoiceMessage() con validación
      function generateNaturalVoiceMessageFixed(pendingAlerts, alertCount) {
        console.log(`🎯 GENERANDO MENSAJE NATURAL PARA ${alertCount} NIÑOS`);
        
        // VALIDACIÓN CRÍTICA DE ENTRADA
        if (!pendingAlerts || !Array.isArray(pendingAlerts) || pendingAlerts.length === 0) {
          console.log(`❌ generateNaturalVoiceMessage: pendingAlerts inválido`);
          return "Hola, algunos niños han terminado su tiempo de juego. Por favor, recógelos.";
        }
        
        if (!alertCount || alertCount < 1) {
          console.log(`❌ generateNaturalVoiceMessage: alertCount inválido`);
          return "Hola, algunos niños han terminado su tiempo de juego. Por favor, recógelos.";
        }
        
        // Extraer información de los niños con validación
        const childrenInfo = pendingAlerts.map((alert, index) => {
          if (!alert || !alert.text) {
            console.log(`⚠️ generateNaturalVoiceMessage: alert ${index} inválido`);
            return null;
          }
          
          const childName = extractChildNameFromAlertFixed(alert.text);
          if (!childName) {
            console.log(`⚠️ generateNaturalVoiceMessage: no se pudo extraer nombre del alert ${index}`);
            return null;
          }
          
          const gender = detectGenderByNameFixed(childName);
          return {
            name: childName,
            gender: gender,
            relationship: gender === 'female' ? 'hija' : (gender === 'male' ? 'hijo' : 'niño')
          };
        }).filter(child => child !== null);
        
        console.log(`👶 INFORMACIÓN DE NIÑOS:`, childrenInfo);
        
        if (childrenInfo.length === 0) {
          console.log(`❌ generateNaturalVoiceMessage: no se pudieron extraer nombres válidos`);
          return "Hola, algunos niños han terminado su tiempo de juego. Por favor, recógelos.";
        }
        
        // GENERAR MENSAJE SEGÚN ESCENARIOS NATURALES
        if (alertCount === 1) {
          const child = childrenInfo[0];
          return `Hola, ${child.name} ha terminado su tiempo de juego. Por favor, recógelo.`;
          
        } else if (alertCount === 2) {
          const child1 = childrenInfo[0];
          const child2 = childrenInfo[1];
          return `Hola, ${child1.name} y ${child2.name} han terminado su tiempo de juego. Por favor, recógelos.`;
          
        } else if (alertCount <= 5) {
          const names = childrenInfo.map(child => child.name);
          const lastChild = names.pop();
          const otherChildren = names.join(', ');
          return `Hola, ${otherChildren} y ${lastChild} han terminado su tiempo de juego. Por favor, recógelos.`;
          
        } else {
          return `Hola, ${alertCount} niños han terminado su tiempo de juego. Por favor, recógelos.`;
        }
      }
      
      // PROBLEMA 4: calculateAdaptiveRepetitions() con edge cases
      function calculateAdaptiveRepetitionsFixed(message, alertCount) {
        if (!adaptiveAlertSystem || !adaptiveAlertSystem.enabled) {
          console.log(`⚠️ calculateAdaptiveRepetitions: adaptiveAlertSystem deshabilitado`);
          return { repetitions: 1, delay: 0 };
        }
        
        // VALIDACIÓN DE ENTRADA
        if (!alertCount || alertCount < 1 || alertCount > 20) {
          console.log(`⚠️ calculateAdaptiveRepetitions: alertCount inválido (${alertCount})`);
          return { repetitions: 1, delay: 0 };
        }
        
        let repetitions;
        let delay;
        
        if (alertCount === 1) {
          repetitions = 2;
          delay = 15000;
        } else if (alertCount <= 3) {
          repetitions = 2;
          delay = 20000;
        } else if (alertCount <= 5) {
          repetitions = 1;
          delay = 0;
        } else {
          repetitions = 1;
          delay = 0;
        }
        
        console.log(`🧠 ADAPTATIVO: ${alertCount} niños → ${repetitions} repeticiones, delay: ${delay}ms`);
        return { repetitions, delay };
      }
      
      // PROBLEMA 5-10: Sistema de cola de voz robusto
      let voiceQueueFixed = [];
      let isVoicePlayingFixed = false;
      let voiceQueueProcessingFixed = false;
      let voiceQueueMaxSize = 10; // Límite de cola
      let audioTimeout = 10000; // 10 segundos timeout
      
      function addToVoiceQueueFixed(message, options = {}) {
        console.log(`📝 AGREGANDO A COLA DE VOZ: "${message}"`);
        
        // VALIDACIÓN DE ENTRADA
        if (!message || typeof message !== 'string' || message.trim().length === 0) {
          console.log(`❌ addToVoiceQueue: mensaje inválido`);
          return false;
        }
        
        // LIMITAR TAMAÑO DE COLA
        if (voiceQueueFixed.length >= voiceQueueMaxSize) {
          console.log(`⚠️ addToVoiceQueue: cola llena (${voiceQueueMaxSize}), removiendo mensaje más antiguo`);
          voiceQueueFixed.shift(); // Remover el más antiguo
        }
        
        voiceQueueFixed.push({ 
          message: message.trim(), 
          options, 
          timestamp: Date.now(),
          id: Math.random().toString(36).substr(2, 9)
        });
        
        console.log(`📊 Cola actual: ${voiceQueueFixed.length} mensajes`);
        
        // PROCESAR COLA SI NO ESTÁ EN PROCESO
        if (!voiceQueueProcessingFixed) {
          setTimeout(() => processVoiceQueueFixed(), 100);
        }
        
        return true;
      }
      
      function processVoiceQueueFixed() {
        if (isVoicePlayingFixed || voiceQueueProcessingFixed || voiceQueueFixed.length === 0) {
          console.log(`⏸️ COLA DE VOZ: No procesando (playing: ${isVoicePlayingFixed}, processing: ${voiceQueueProcessingFixed}, queue: ${voiceQueueFixed.length})`);
          return;
        }
        
        console.log(`🎵 PROCESANDO COLA DE VOZ: ${voiceQueueFixed.length} mensajes pendientes`);
        voiceQueueProcessingFixed = true;
        
        const item = voiceQueueFixed.shift();
        console.log(`🔊 REPRODUCIENDO: "${item.message}" (ID: ${item.id})`);
        
        // VALIDAR SPEECH SYNTHESIS
        if (typeof speechSynthesis === 'undefined') {
          console.log(`❌ processVoiceQueue: speechSynthesis no disponible`);
          voiceQueueProcessingFixed = false;
          return;
        }
        
        // CREAR UTTERANCE CON TIMEOUT
        const utterance = new SpeechSynthesisUtterance(item.message);
        utterance.volume = 0.9;
        utterance.rate = 0.8;
        utterance.pitch = 1.1;
        utterance.lang = 'es-ES';
        
        // TIMEOUT PARA AUDIO
        const timeoutId = setTimeout(() => {
          console.log(`⏰ TIMEOUT DE AUDIO: "${item.message}" (ID: ${item.id})`);
          speechSynthesis.cancel();
          isVoicePlayingFixed = false;
          voiceQueueProcessingFixed = false;
          
          // CONTINUAR CON SIGUIENTE MENSAJE
          if (voiceQueueFixed.length > 0) {
            setTimeout(() => processVoiceQueueFixed(), 500);
          }
        }, audioTimeout);
        
        // MANEJAR EVENTOS DE AUDIO
        utterance.onstart = () => {
          console.log(`🔊 AUDIO INICIADO: "${item.message}" (ID: ${item.id})`);
          isVoicePlayingFixed = true;
        };
        
        utterance.onend = () => {
          console.log(`✅ AUDIO COMPLETADO: "${item.message}" (ID: ${item.id})`);
          clearTimeout(timeoutId);
          isVoicePlayingFixed = false;
          voiceQueueProcessingFixed = false;
          
          // CONTINUAR CON SIGUIENTE MENSAJE
          if (voiceQueueFixed.length > 0) {
            setTimeout(() => processVoiceQueueFixed(), 500);
          } else {
            console.log(`🏁 COLA DE VOZ VACÍA`);
          }
        };
        
        utterance.onerror = (error) => {
          console.log(`❌ ERROR DE AUDIO: "${item.message}" (ID: ${item.id}) - ${error.error}`);
          clearTimeout(timeoutId);
          isVoicePlayingFixed = false;
          voiceQueueProcessingFixed = false;
          
          // CONTINUAR CON SIGUIENTE MENSAJE
          if (voiceQueueFixed.length > 0) {
            setTimeout(() => processVoiceQueueFixed(), 500);
          }
        };
        
        // REPRODUCIR AUDIO
        try {
          speechSynthesis.speak(utterance);
        } catch (error) {
          console.log(`❌ ERROR AL REPRODUCIR: ${error.message}`);
          clearTimeout(timeoutId);
          isVoicePlayingFixed = false;
          voiceQueueProcessingFixed = false;
          
          // CONTINUAR CON SIGUIENTE MENSAJE
          if (voiceQueueFixed.length > 0) {
            setTimeout(() => processVoiceQueueFixed(), 500);
          }
        }
      }
      
      // FUNCIÓN DE LIMPIEZA DE COLA
      function clearVoiceQueueFixed() {
        console.log(`🧹 LIMPIANDO COLA DE VOZ: ${voiceQueueFixed.length} mensajes`);
        speechSynthesis.cancel();
        voiceQueueFixed = [];
        isVoicePlayingFixed = false;
        voiceQueueProcessingFixed = false;
      }
      
      // HACER FUNCIONES GLOBALES
      window.extractChildNameFromAlertFixed = extractChildNameFromAlertFixed;
      window.detectGenderByNameFixed = detectGenderByNameFixed;
      window.generateNaturalVoiceMessageFixed = generateNaturalVoiceMessageFixed;
      window.calculateAdaptiveRepetitionsFixed = calculateAdaptiveRepetitionsFixed;
      window.addToVoiceQueueFixed = addToVoiceQueueFixed;
      window.processVoiceQueueFixed = processVoiceQueueFixed;
      window.clearVoiceQueueFixed = clearVoiceQueueFixed;
      
      console.log(`✅ TODAS LAS CORRECCIONES APLICADAS`);
      console.log(`📋 FUNCIONES CORREGIDAS DISPONIBLES GLOBALMENTE`);
    }
    
    // Hacer función global para correcciones
    window.fixAllVoiceProblems = fixAllVoiceProblems;
    
    // 🧪 PRUEBA ESPECÍFICA: 3 SESIONES ACTIVAS TERMINANDO
    function test3ActiveSessions() {
      console.log(`🧪 INICIANDO PRUEBA: 3 SESIONES ACTIVAS TERMINANDO`);
      console.log(`=================================================`);
      
      // Primero aplicar todas las correcciones
      console.log(`🔧 APLICANDO CORRECCIONES...`);
      fixAllVoiceProblems();
      
      // Simular 3 sesiones activas terminando
      const activeSessions = [
        {
          childName: "sofia",
          parents: "Luis & Ana",
          game: "trampolin",
          timeLeft: 5,
          sessionId: 1
        },
        {
          childName: "david", 
          parents: "Carlos & Maria",
          game: "trampolin",
          timeLeft: 3,
          sessionId: 2
        },
        {
          childName: "mathias",
          parents: "Pedro & Laura", 
          game: "trampolin",
          timeLeft: 2,
          sessionId: 3
        }
      ];
      
      console.log(`\n📊 SESIONES ACTIVAS SIMULADAS:`);
      activeSessions.forEach((session, index) => {
        console.log(`  ${index + 1}. ${session.childName} (${session.parents}) - ${session.timeLeft}s restantes`);
      });
      
      // Simular alertas de tiempo terminado
      const timeOutAlerts = [
        {
          text: "¡Atención! A sofia le quedan solo 5 segundos",
          sessionId: 1,
          timeLeft: 0,
          timestamp: Date.now()
        },
        {
          text: "¡Atención! A david le quedan solo 3 segundos", 
          sessionId: 2,
          timeLeft: 0,
          timestamp: Date.now()
        },
        {
          text: "¡Atención! A mathias le quedan solo 2 segundos",
          sessionId: 3, 
          timeLeft: 0,
          timestamp: Date.now()
        }
      ];
      
      console.log(`\n🎯 SIMULANDO TERMINACIÓN DE SESIONES...`);
      console.log(`📝 Alertas generadas: ${timeOutAlerts.length}`);
      
      // Probar extracción de nombres
      console.log(`\n🧪 PROBANDO EXTRACCIÓN DE NOMBRES:`);
      timeOutAlerts.forEach((alert, index) => {
        const name = extractChildNameFromAlertFixed(alert.text);
        const gender = detectGenderByNameFixed(name);
        console.log(`  ${index + 1}. "${alert.text}" → Nombre: "${name}", Género: "${gender}"`);
      });
      
      // Probar generación de mensaje natural
      console.log(`\n🎯 PROBANDO GENERACIÓN DE MENSAJE NATURAL:`);
      const naturalMessage = generateNaturalVoiceMessageFixed(timeOutAlerts, 3);
      console.log(`📢 MENSAJE GENERADO: "${naturalMessage}"`);
      
      // Probar repeticiones adaptativas
      console.log(`\n🔄 PROBANDO REPETICIONES ADAPTATIVAS:`);
      const { repetitions, delay } = calculateAdaptiveRepetitionsFixed('', 3);
      console.log(`📊 3 niños → ${repetitions} repeticiones, delay: ${delay}ms`);
      
      // Probar cola de voz
      console.log(`\n🎵 PROBANDO COLA DE VOZ:`);
      console.log(`📝 Agregando mensaje a cola...`);
      
      // Agregar mensaje a la cola
      const success = addToVoiceQueueFixed(naturalMessage, { 
        priority: 'high',
        sessionId: 'test-3-sessions'
      });
      
      if (success) {
        console.log(`✅ MENSAJE AGREGADO A COLA EXITOSAMENTE`);
        console.log(`🔊 EL AUDIO DEBERÍA REPRODUCIRSE EN BREVE...`);
        console.log(`📋 ESCUCHA ATENTAMENTE EL MENSAJE DE VOZ`);
        console.log(`🎯 DEBERÍAS ESCUCHAR: "${naturalMessage}"`);
      } else {
        console.log(`❌ ERROR AL AGREGAR MENSAJE A COLA`);
      }
      
      // Probar escenarios individuales
      console.log(`\n🧪 PROBANDO ESCENARIOS INDIVIDUALES:`);
      
      // Escenario 1: Solo sofia
      setTimeout(() => {
        console.log(`\n📝 ESCENARIO 1: Solo sofia`);
        const sofiaAlert = [timeOutAlerts[0]];
        const sofiaMessage = generateNaturalVoiceMessageFixed(sofiaAlert, 1);
        console.log(`📢 MENSAJE SOFIA: "${sofiaMessage}"`);
        addToVoiceQueueFixed(sofiaMessage, { priority: 'high' });
      }, 2000);
      
      // Escenario 2: sofia y david
      setTimeout(() => {
        console.log(`\n📝 ESCENARIO 2: sofia y david`);
        const twoAlerts = [timeOutAlerts[0], timeOutAlerts[1]];
        const twoMessage = generateNaturalVoiceMessageFixed(twoAlerts, 2);
        console.log(`📢 MENSAJE DOS: "${twoMessage}"`);
        addToVoiceQueueFixed(twoMessage, { priority: 'high' });
      }, 4000);
      
      // Escenario 3: Los tres
      setTimeout(() => {
        console.log(`\n📝 ESCENARIO 3: Los tres (sofia, david, mathias)`);
        const threeMessage = generateNaturalVoiceMessageFixed(timeOutAlerts, 3);
        console.log(`📢 MENSAJE TRES: "${threeMessage}"`);
        addToVoiceQueueFixed(threeMessage, { priority: 'high' });
      }, 6000);
      
      console.log(`\n✅ PRUEBA INICIADA - VERIFICAR AUDIO Y LOGS`);
      console.log(`📋 INSTRUCCIONES:`);
      console.log(`  1. ESCUCHA el mensaje de voz`);
      console.log(`  2. VERIFICA que dice los 3 nombres correctamente`);
      console.log(`  3. CONFIRMA que el mensaje es natural y claro`);
      console.log(`  4. REVISA los logs en consola`);
      
      return {
        success: true,
        message: naturalMessage,
        sessions: activeSessions,
        alerts: timeOutAlerts
      };
    }
    
    // Hacer función global para prueba de 3 sesiones
    window.test3ActiveSessions = test3ActiveSessions;
    
    // 🚨 SISTEMA DE PRUEBAS ROBUSTO - ESCUCHAR AUDIO REAL
    function testVoiceSystemRobust() {
      console.log(`🚨 INICIANDO PRUEBAS ROBUSTAS DEL SISTEMA DE VOZ`);
      console.log(`================================================`);
      
      // Verificar estado del sistema
      console.log(`\n📊 ESTADO DEL SISTEMA:`);
      console.log(`  - voiceNotificationsEnabled: ${voiceNotificationsEnabled}`);
      console.log(`  - voiceSystemActivated: ${voiceSystemActivated}`);
      console.log(`  - speechSynthesis disponible: ${typeof speechSynthesis !== 'undefined'}`);
      console.log(`  - voces disponibles: ${speechSynthesis.getVoices().length}`);
      
      // PRUEBA 1: Audio básico
      console.log(`\n🧪 PRUEBA 1: AUDIO BÁSICO`);
      console.log(`📢 Reproduciendo: "Prueba de audio básico"`);
      speakChildName("Prueba de audio básico");
      
      setTimeout(() => {
        // PRUEBA 2: Un niño
        console.log(`\n🧪 PRUEBA 2: UN NIÑO`);
        const scenario1 = [{
          text: "¡Atención! A sofia le quedan solo 5 segundos",
          sessionId: 1,
          timeLeft: 0,
          timestamp: Date.now()
        }];
        console.log(`📢 Escenario: 1 niño (sofia)`);
        speakAlertWithRepetition(scenario1, 1);
      }, 3000);
      
      setTimeout(() => {
        // PRUEBA 3: Dos niños
        console.log(`\n🧪 PRUEBA 3: DOS NIÑOS`);
        const scenario2 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: 2 niños (sofia, david)`);
        speakAlertWithRepetition(scenario2, 2);
      }, 6000);
      
      setTimeout(() => {
        // PRUEBA 4: Tres niños
        console.log(`\n🧪 PRUEBA 4: TRES NIÑOS`);
        const scenario3 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: 3 niños (sofia, david, mathias)`);
        speakAlertWithRepetition(scenario3, 3);
      }, 9000);
      
      setTimeout(() => {
        // PRUEBA 5: Cinco niños
        console.log(`\n🧪 PRUEBA 5: CINCO NIÑOS`);
        const scenario4 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A cristian le quedan solo 1 segundo", sessionId: 4, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A ramon le quedan solo 1 segundo", sessionId: 5, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: 5 niños (sofia, david, mathias, cristian, ramon)`);
        speakAlertWithRepetition(scenario4, 5);
      }, 12000);
      
      setTimeout(() => {
        // PRUEBA 6: Seis niños
        console.log(`\n🧪 PRUEBA 6: SEIS NIÑOS`);
        const scenario5 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A cristian le quedan solo 1 segundo", sessionId: 4, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A ramon le quedan solo 1 segundo", sessionId: 5, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A santiago le quedan solo 1 segundo", sessionId: 6, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: 6 niños (sofia, david, mathias, cristian, ramon, santiago)`);
        speakAlertWithRepetition(scenario5, 6);
      }, 15000);
      
      setTimeout(() => {
        // PRUEBA 7: Nombres con acentos
        console.log(`\n🧪 PRUEBA 7: NOMBRES CON ACENTOS`);
        const scenario6 = [
          { text: "¡Atención! A josé le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A maría le quedan solo 3 segundos", sessionId: 2, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: Nombres con acentos (josé, maría)`);
        speakAlertWithRepetition(scenario6, 2);
      }, 18000);
      
      setTimeout(() => {
        // PRUEBA 8: Nombres complejos
        console.log(`\n🧪 PRUEBA 8: NOMBRES COMPLEJOS`);
        const scenario7 = [
          { text: "¡Atención! A alejandro le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A valentina le quedan solo 3 segundos", sessionId: 2, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: Nombres complejos (alejandro, valentina)`);
        speakAlertWithRepetition(scenario7, 2);
      }, 21000);
      
      setTimeout(() => {
        // PRUEBA 9: Casos edge
        console.log(`\n🧪 PRUEBA 9: CASOS EDGE`);
        const scenario8 = [
          { text: "¡Atención! A niño le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: Casos edge (niño genérico)`);
        speakAlertWithRepetition(scenario8, 1);
      }, 24000);
      
      setTimeout(() => {
        // PRUEBA 10: Datos inválidos
        console.log(`\n🧪 PRUEBA 10: DATOS INVÁLIDOS`);
        const scenario9 = [
          { text: "¡Atención! A  le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: Datos inválidos (nombre vacío)`);
        speakAlertWithRepetition(scenario9, 1);
      }, 27000);
      
      console.log(`\n✅ PRUEBAS INICIADAS - ESCUCHAR AUDIO EN SECUENCIA`);
      console.log(`📋 INSTRUCCIONES:`);
      console.log(`  1. ESCUCHA cada mensaje de voz`);
      console.log(`  2. VERIFICA que los nombres se pronuncian correctamente`);
      console.log(`  3. CONFIRMA que los mensajes son naturales`);
      console.log(`  4. IDENTIFICA cualquier problema`);
      console.log(`  5. REVISA los logs en consola`);
      
      return {
        success: true,
        message: "Pruebas robustas iniciadas",
        tests: 10,
        duration: "30 segundos"
      };
    }
    
    // Hacer función global para pruebas robustas
    window.testVoiceSystemRobust = testVoiceSystemRobust;
    
    // SISTEMA ADAPTATIVO DE REPETICIONES
    function calculateAdaptiveRepetitions(message, alertCount) {
      if (!adaptiveAlertSystem.enabled) {
        return 1; // Repetición única si está deshabilitado
      }
      
      let repetitions;
      let delay;
      
      if (alertCount === 1) {
        // 1 niño: 2 repeticiones (inmediata + 15s)
        repetitions = 2;
        delay = 15000;
      } else if (alertCount <= 3) {
        // 2-3 niños: 2 repeticiones (inmediata + 20s)
        repetitions = 2;
        delay = 20000;
      } else if (alertCount <= 5) {
        // 4-5 niños: 1 repetición (inmediata)
        repetitions = 1;
        delay = 0;
      } else {
        // 6+ niños: 1 mensaje consolidado (inmediata)
        repetitions = 1;
        delay = 0;
      }
      
      console.log(`🧠 ADAPTATIVO: ${alertCount} niños → ${repetitions} repeticiones, delay: ${delay}ms`);
      return { repetitions, delay };
    }
    
    // SISTEMA DE VOZ CORREGIDO - SOLUCIÓN A TODOS LOS PROBLEMAS
    async function speakAlertWithRepetition(pendingAlerts, alertCount) {
      if (!voiceNotificationsEnabled) {
        console.log(`🔇 Voz deshabilitada, saltando speakAlertWithRepetition`);
        return;
      }
      
      console.log(`🧠 SISTEMA CORREGIDO: Procesando ${alertCount} alertas`);
      console.log(`📊 pendingAlerts:`, pendingAlerts);
      
      // VALIDAR DATOS DE ENTRADA
      if (!pendingAlerts || pendingAlerts.length === 0) {
        console.log(`⚠️ speakAlertWithRepetition: pendingAlerts vacío o inválido`);
        return;
      }
      
      // EXTRAER NOMBRES CON VALIDACIÓN ROBUSTA
      console.log(`🔍 DEBUG: Estructura de pendingAlerts:`, pendingAlerts.map(alert => ({
        text: alert.text,
        hasText: !!alert.text,
        textType: typeof alert.text,
        keys: Object.keys(alert)
      })));
      
      const childNames = pendingAlerts.map(alert => {
        console.log(`🔍 DEBUG: Procesando alert:`, alert);
        
        // MANEJAR DOS TIPOS DE ESTRUCTURA:
        let name = null;
        
        if (alert.name) {
          // Estructura: {name: 'sofia', parents: 'Papá: fernando'}
          name = alert.name;
          console.log(`🔍 DEBUG: Nombre directo: "${name}"`);
        } else if (alert.text) {
          // Estructura: {text: '¡Atención! A sofia le quedan solo 30 segundos'}
          name = extractChildNameFromAlert(alert.text);
          console.log(`🔍 DEBUG: Nombre extraído de texto: "${name}"`);
        }
        
        console.log(`🔍 DEBUG: Nombre final: "${name}"`);
        return name && name !== 'null' ? name : null;
      }).filter(name => name !== null);
      
      console.log(`👶 NOMBRES EXTRAÍDOS:`, childNames);
      
      // GENERAR MENSAJE SEGÚN ESCENARIOS CON INFORMACIÓN DE PADRES
      let message;
      
      // Obtener información de padres de pendingAlerts
      const childrenWithParents = pendingAlerts.map(alert => {
        let childName = null;
        let parentsInfo = '';
        
        if (alert.name) {
          // Estructura: {name: 'sofia', parents: 'Papá: fernando'}
          childName = alert.name;
          parentsInfo = alert.parents ? ` (${alert.parents})` : '';
        } else if (alert.text) {
          // Estructura: {text: '¡Atención! A sofia le quedan solo 30 segundos'}
          childName = extractChildNameFromAlert(alert.text);
          // Buscar información del niño en childrenCache
          const child = childrenCache.find(c => c.name === childName);
          
          if (child) {
            parentsInfo = getParentsInfo(child, 'simple');
          }
        }
        
        return { name: childName, parents: parentsInfo };
      });
      
      if (alertCount === 1 && childrenWithParents.length === 1) {
        const child = childrenWithParents[0];
        const gender = detectGenderByName(child.name);
        const relationship = gender === 'female' ? 'hija' : (gender === 'male' ? 'hijo' : 'niño');
        message = `Hola, ${child.name}${child.parents} ha terminado su tiempo de juego. Por favor, recoge a tu ${relationship}.`;
      } else if (alertCount === 2 && childrenWithParents.length === 2) {
        const child1 = childrenWithParents[0];
        const child2 = childrenWithParents[1];
        message = `Hola, ${child1.name}${child1.parents} y ${child2.name}${child2.parents} han terminado su tiempo de juego. Por favor, recógelos.`;
      } else if (alertCount <= 5 && childrenWithParents.length > 0) {
        // LISTAR NOMBRES ESPECÍFICOS HASTA 5 CON PADRES
        const names = childrenWithParents.slice(0, 5).map(child => `${child.name}${child.parents}`);
        const lastChild = names.pop();
        const otherChildren = names.join(', ');
        message = `Hola, ${otherChildren} y ${lastChild} han terminado su tiempo de juego. Por favor, recógelos.`;
      } else {
        // MENSAJE CONSOLIDADO PARA 6+ NIÑOS
        message = `Hola, ${alertCount} niños han terminado su tiempo de juego. Por favor, recógelos.`;
      }
      
      console.log(`🔊 MENSAJE GENERADO: "${message}"`);
      
      // REPRODUCIR CON REPETICIONES ADAPTATIVAS
      const { repetitions, delay } = calculateAdaptiveRepetitions('', alertCount);
      
      console.log(`🔊 ACTIVANDO SISTEMA DE REPETICIONES: ${repetitions} repeticiones con ${delay}ms de delay`);
      
      // AGREGAR TODAS LAS REPETICIONES A LA COLA DE VOZ
      for (let i = 0; i < repetitions; i++) {
        if (i === 0) {
          // Primera repetición inmediata
          addToVoiceQueue(message, { immediate: true });
        } else {
          // Repeticiones subsecuentes con delay
          setTimeout(() => {
            addToVoiceQueue(message, { immediate: false });
          }, i * delay);
        }
      }
    }
    
    // GENERADOR DE MENSAJES NATURALES Y PERSONALIZADOS - USAR FUNCIONES CORREGIDAS
    function generateNaturalVoiceMessage(pendingAlerts, alertCount) {
      console.log(`🎯 GENERANDO MENSAJE NATURAL PARA ${alertCount} NIÑOS (USANDO FUNCIONES CORREGIDAS)`);
      
      // USAR FUNCIONES CORREGIDAS
      return generateNaturalVoiceMessageFixed(pendingAlerts, alertCount);
    }
    
    function shouldShowAlert(type, options) {
      // Alertas críticas siempre se muestran
      if (type === 'error' || type === 'danger') {
        return true;
      }
      
      // Verificar preferencias por tipo
      switch (type) {
        case 'success':
          return alertPreferences.showSuccessAlerts;
        case 'warning':
          return alertPreferences.showVisualAlerts;
        case 'info':
          return alertPreferences.showStatusAlerts;
        default:
          return true;
      }
    }
    
    function determineAlertTypes(type, options) {
      const result = {
        visual: alertPreferences.showVisualAlerts && !options.voiceOnly,
        voice: alertPreferences.showVoiceAlerts && !options.voiceOnly && !options.visualOnly,
        browser: alertPreferences.showBrowserNotifications && !options.visualOnly
      };
      
      // Debug: Log para verificar por qué se activa la voz
      if (options.voiceOnly === false) {
        console.log('🔇 VOZ DESACTIVADA - options.voiceOnly:', options.voiceOnly, 'result.voice:', result.voice);
        // FORZAR voz a false cuando voiceOnly es false
        result.voice = false;
        console.log('🔇 VOZ FORZADA A FALSE - result.voice:', result.voice);
      }
      
      return result;
    }
    
    function showVisualAlert(text, type, sessionId) {
      console.log(`🔔 showVisualAlert LLAMADA: "${text}" [${type}] sessionId: ${sessionId}`);
      
      // CANCELAR ALERTA ANTERIOR SI EXISTE
      const existingMsg = document.getElementById('statusMessage');
      if (existingMsg && existingMsg.timeoutId) {
        console.log(`🔔 CANCELANDO ALERTA ANTERIOR: "${existingMsg.textContent}"`);
        clearTimeout(existingMsg.timeoutId);
        existingMsg.remove();
      }
      
      // CREAR NUEVA ALERTA
      let msg = document.createElement('div');
      msg.id = 'statusMessage';
      msg.className = 'status-message';
      msg.innerHTML = `
        <span class="status-text"></span>
        <button class="status-close" onclick="hideStatusMessage()" title="Cerrar">
          <i class="fas fa-times"></i>
        </button>
      `;
      document.body.appendChild(msg);
      
      // Reproducir sonido según el tipo
      if (type === 'warning' || type === 'danger') {
        playNotificationSound(type);
      }
      
      // Limpiar cualquier timeout anterior
      if (msg.timeoutId) {
        clearTimeout(msg.timeoutId);
      }
      
      // Usar el span para el texto
      const textSpan = msg.querySelector('.status-text');
      if (textSpan) {
        textSpan.textContent = text;
      } else {
        msg.textContent = text; // Fallback para compatibilidad
      }
      msg.className = `status-message ${type} show`;
      msg.style.display = 'flex'; // Asegurar que se muestre
      msg.style.transform = 'translateX(0)'; // Asegurar que esté en posición visible
      
      // NO marcar sesión como alertada - permitir todas las notificaciones
      
      // Auto-ocultar después de tiempo apropiado según el tipo
      let timeoutDuration;
      if (type === 'error') {
        // Para errores de validación, mostrar menos tiempo para mejor UX
        if (text.includes('Validation failed') || text.includes('Por favor seleccione')) {
          timeoutDuration = 4000; // 4 segundos para errores de validación
        } else {
          timeoutDuration = 6000; // Errores más tiempo para leer
        }
      } else if (type === 'warning') {
        // Alertas de warning con texto largo (nombres + padres) necesitan más tiempo
        if (text.includes('terminó su tiempo') || text.includes('Tiempo terminado')) {
          timeoutDuration = 12000; // 12 segundos para alertas de tiempo terminado
        } else {
          timeoutDuration = text.length > 50 ? 8000 : 6000; // Más tiempo para texto largo
        }
      } else {
        timeoutDuration = text.length < 10 ? 2000 : 4000; // Éxito menos tiempo
      }
      
      msg.timeoutId = setTimeout(() => {
        console.log(`🔔 ALERTA OCULTÁNDOSE AUTOMÁTICAMENTE: "${text}" después de ${timeoutDuration}ms`);
        // Usar la función de ocultar que remueve completamente del DOM
        hideStatusMessage();
        
        // NO limpiar alertas de sesión - permitir todas las notificaciones
      }, timeoutDuration);
      
      console.log(`✅ ALERTA VISUAL CONFIGURADA: "${text}" se ocultará en ${timeoutDuration}ms`);
    }

    // Función para ocultar manualmente el mensaje de estado
    function hideStatusMessage() {
      const msg = document.getElementById('statusMessage');
      if (msg) {
        console.log(`🔔 hideStatusMessage LLAMADA: ocultando "${msg.textContent}"`);
        msg.style.display = 'none';
        msg.style.opacity = '0';
        msg.style.transform = 'translateX(400px)';
        
        // REMOVER COMPLETAMENTE DEL DOM DESPUÉS DE LA ANIMACIÓN
        setTimeout(() => {
          if (msg && msg.parentNode) {
            console.log(`🔔 REMOVIENDO ALERTA DEL DOM: "${msg.textContent}"`);
            msg.remove();
          }
        }, 300); // Esperar 300ms para la animación
      }
    }

    function showLoading(buttonId, show = true) {
      const button = document.getElementById(buttonId);
      if (!button) return;
      
      if (show) {
        button.disabled = true;
        button.innerHTML = '<div class="loading"></div> Procesando...';
      } else {
        button.disabled = false;
        // Restaurar texto original basado en el botón
        if (buttonId === 'addChildBtn') {
          button.innerHTML = '<i class="fas fa-plus"></i> Agregar Niño';
        } else if (buttonId === 'addGameBtn') {
          button.innerHTML = '<i class="fas fa-plus"></i> Agregar Juego';
        } else if (buttonId === 'startBtn') {
          button.innerHTML = '<i class="fas fa-play"></i> Iniciar Sesión';
        }
      }
    }

    // Función para limpiar todas las alertas de sesiones
    function clearAllSessionAlerts() {
      alertedSessions.clear();
      pendingTimeAlerts.clear();
      if (timeAlertTimeout) {
        clearTimeout(timeAlertTimeout);
        timeAlertTimeout = null;
      }
      const msg = document.getElementById('statusMessage');
      if (msg) {
        if (msg.timeoutId) {
          clearTimeout(msg.timeoutId);
          msg.timeoutId = null;
        }
        msg.classList.remove('show');
        msg.textContent = '';
        msg.className = 'status-message';
      }
    }

    // Función para cerrar manualmente todas las alertas (para casos críticos)
    function dismissAllAlerts() {
      clearAllSessionAlerts();
      showStatusMessage('✅ Todas las alertas cerradas', 'success');
    }

    // Función inteligente para determinar si mostrar información de padres
    function shouldShowParentsInfo(context, children) {
      switch(context) {
        case 'search':
        case 'list':
        case 'history':
          return true; // Siempre mostrar en estos contextos
          
        case 'alert':
          // En alertas, solo si hay nombres duplicados
          const nameCount = {};
          children.forEach(child => {
            nameCount[child.name] = (nameCount[child.name] || 0) + 1;
          });
          return Object.values(nameCount).some(count => count > 1);
          
        case 'ranking':
          // En ranking, solo si hay duplicados
          const rankingNames = {};
          children.forEach(child => {
            rankingNames[child.name] = (rankingNames[child.name] || 0) + 1;
          });
          return Object.values(rankingNames).some(count => count > 1);
          
        default:
          return false;
      }
    }



    // Función para limpiar alerta específica de sesión
    function clearSessionAlert(sessionId) {
      alertedSessions.delete(sessionId);
      const msg = document.getElementById('statusMessage');
      if (msg && msg.textContent.includes('quedan solo') && msg.textContent.includes('segundos')) {
        if (msg.timeoutId) {
          clearTimeout(msg.timeoutId);
          msg.timeoutId = null;
        }
        msg.classList.remove('show');
        msg.textContent = '';
        msg.className = 'status-message';
      }
    }


    // Sistema de notificaciones con sonido
    function playNotificationSound(type = 'default') {
      try {
        // Crear audio context para sonidos
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        let frequency = 800;
        let duration = 0.2;
        
        switch(type) {
          case 'warning':
            frequency = 600;
            duration = 0.3;
            break;
          case 'danger':
            frequency = 400;
            duration = 0.5;
            break;
          case 'success':
            frequency = 1000;
            duration = 0.2;
            break;
        }
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
      } catch (error) {
        console.log('Could not play notification sound:', error);
      }
    }

    // Sistema de inicialización de permisos (mejores prácticas para producción)
    async function initializeNotificationPermissions() {
      try {
        console.log('🎤 Inicializando sistema de notificaciones de voz...');
        
        // Verificar soporte de APIs
        const hasSpeechSynthesis = 'speechSynthesis' in window;
        const hasNotifications = 'Notification' in window;
        
        console.log('🔍 Soporte APIs:', { speechSynthesis: hasSpeechSynthesis, notifications: hasNotifications });
        
        if (!hasSpeechSynthesis) {
          console.warn('⚠️ Speech Synthesis no soportado en este navegador');
          voiceNotificationsEnabled = false;
          // NO mostrar alerta durante inicialización para evitar errores
          return;
        }
        
        if (!hasNotifications) {
          console.warn('⚠️ Notifications API no soportado en este navegador');
        }
        
        // Verificar voces disponibles - CRÍTICO para producción
        let voices = window.speechSynthesis.getVoices();
        
        // En algunos navegadores, las voces necesitan tiempo para cargar
        if (voices.length === 0) {
          console.log('🔄 Cargando voces del navegador...');
          await new Promise(resolve => {
            const loadVoices = () => {
              voices = window.speechSynthesis.getVoices();
              if (voices.length > 0) {
                resolve();
              } else {
                setTimeout(loadVoices, 100);
              }
            };
            loadVoices();
          });
        }
        
        console.log('🎙️ Voces disponibles:', voices.length);
        
        const spanishVoices = voices.filter(voice => voice.lang.startsWith('es'));
        console.log('🇪🇸 Voces en español:', spanishVoices.length);
        
        // Verificar voz femenina disponible usando función helper
        const selectedVoice = getFemaleSpanishVoice();
        
        if (spanishVoices.length === 0) {
          console.warn('⚠️ No se encontraron voces en español disponibles');
          showStatusMessage('⚠️ No hay voces en español - usará inglés como fallback', 'warning');
        } else {
          console.log('✅ Voces en español encontradas:', spanishVoices.map(v => v.name).join(', '));
          if (selectedVoice) {
            console.log('👩 Voz femenina seleccionada:', selectedVoice.name);
          } else {
            console.log('👩 No se detectaron voces específicamente femeninas, usando la primera disponible');
          }
        }
        
        // Solicitar permisos de notificaciones del navegador
        if (hasNotifications && Notification.permission === 'default') {
          const permission = await Notification.requestPermission();
          browserNotificationsEnabled = permission === 'granted';
          window.browserNotificationsEnabled = browserNotificationsEnabled; // Actualizar variable global
          
          if (browserNotificationsEnabled) {
            showStatusMessage('🔔 Notificaciones del navegador activadas', 'success');
          } else {
            showStatusMessage('🔕 Notificaciones del navegador denegadas', 'warning');
          }
        } else if (hasNotifications) {
          browserNotificationsEnabled = Notification.permission === 'granted';
          window.browserNotificationsEnabled = browserNotificationsEnabled; // Actualizar variable global
        }
        
        // PRUEBA CRÍTICA: Hacer un test de voz para activar el sistema (SILENCIOSO)
        try {
          await testVoiceSystem();
        } catch (error) {
          console.warn('⚠️ Test de voz falló (continuando):', error);
          voiceNotificationsEnabled = false;
          voiceSystemActivated = false;
        }
        
        voicePermissionsGranted = true;
        console.log('✅ Sistema de notificaciones inicializado correctamente');
        
      } catch (error) {
        console.error('❌ Error inicializando permisos:', error);
        showStatusMessage('❌ Error configurando notificaciones: ' + error.message, 'error');
        voicePermissionsGranted = false;
      }
    }
    
    // Función para probar el sistema de voz (crítico para producción)
    async function testVoiceSystem() {
      try {
        console.log('🧪 Probando sistema de voz...');
        
        if (!('speechSynthesis' in window)) {
          throw new Error('Speech Synthesis no soportado');
        }
        
        // Cancelar cualquier síntesis previa
        window.speechSynthesis.cancel();
        
        // Crear un test básico SILENCIOSO
        const testUtterance = new SpeechSynthesisUtterance('');
        testUtterance.volume = 0; // COMPLETAMENTE SILENCIOSO
        testUtterance.rate = 1;
        
        // Configurar idioma básico
        testUtterance.lang = 'es-ES';
        
        // Configurar eventos para detectar problemas
        testUtterance.onstart = () => {
          console.log('✅ Sistema de voz funcionando correctamente');
        };
        
        testUtterance.onerror = (event) => {
          console.warn('⚠️ Error en sistema de voz (continuando sin voz):', event.error);
          voiceNotificationsEnabled = false;
          voiceSystemActivated = false;
          // NO bloquear la aplicación por errores de voz
          console.log('🔧 Sistema de voz deshabilitado, aplicación continúa normalmente');
          // Resolver inmediatamente para no bloquear
          return true;
        };
        
        // Ejecutar test (sin esperar)
        window.speechSynthesis.speak(testUtterance);
        
        // Esperar un momento para ver si hay errores (con timeout)
        await new Promise(resolve => {
          const timeout = setTimeout(() => {
            console.log('⏰ Timeout en test de voz - continuando');
            resolve(true);
          }, 500); // 500ms máximo
          
          // Si hay error, se resuelve en onerror
          testUtterance.onend = () => {
            clearTimeout(timeout);
            resolve(true);
          };
        });
        
        return true;
        
      } catch (error) {
        console.error('❌ Fallo en test de voz:', error);
        voiceNotificationsEnabled = false;
        return false;
      }
    }

    // Control de notificaciones de voz (mejorado para producción)
    function toggleVoiceNotifications() {
      if (!voicePermissionsGranted) {
        showStatusMessage('⚠️ Primero inicialice los permisos de notificaciones', 'warning');
        return;
      }
      
      // Activar sistema de voz en esta interacción del usuario
      activateVoiceSystemOnUserInteraction();
      
      voiceNotificationsEnabled = !voiceNotificationsEnabled;
      window.voiceNotificationsEnabled = voiceNotificationsEnabled; // Actualizar variable global
      
      const voiceToggle = document.getElementById('voiceToggle');
      const voiceStatus = document.getElementById('voiceStatus');
      const icon = voiceToggle.querySelector('i');
      
      if (voiceNotificationsEnabled) {
        voiceToggle.classList.remove('muted');
        icon.className = 'fas fa-volume-up';
        voiceStatus.textContent = 'Voz Activada';
        
        // Hacer un test rápido para verificar que funciona - USANDO LA MISMA VOZ Y PARÁMETROS OPTIMIZADOS
        setTimeout(() => {
          try {
            const testUtterance = new SpeechSynthesisUtterance('Voz activada');
            
            // Obtener parámetros optimizados por navegador
            const voiceParams = getVoiceParameters();
            testUtterance.lang = voiceParams.lang;
            testUtterance.rate = voiceParams.rate * 1.2; // Un poco más rápido para el test
            testUtterance.pitch = voiceParams.pitch;
            testUtterance.volume = 0.3; // Volumen bajo para el test
            
            // Configurar la MISMA voz que se usa para los nombres de los niños
            const selectedVoice = getFemaleSpanishVoice();
            if (selectedVoice) {
              testUtterance.voice = selectedVoice;
              console.log('🎤 Test de voz usando la misma voz que los nombres:', selectedVoice.name, selectedVoice.lang);
            } else {
              console.warn('⚠️ No se encontró voz en español para el test');
            }
            
            window.speechSynthesis.speak(testUtterance);
          } catch (error) {
            console.error('Error en test de voz:', error);
          }
        }, 500);
        
      } else {
        voiceToggle.classList.add('muted');
        icon.className = 'fas fa-volume-mute';
        voiceStatus.textContent = 'Voz Desactivada';
        showStatusMessage('🔇 Notificaciones de voz desactivadas', 'info');
        
        // Cancelar cualquier síntesis en curso
        window.speechSynthesis.cancel();
      }
    }



    // Función helper global para crear utterance híbrido
    function createHybridUtterance(msg, alertCount = 1) {
      const hybridConfig = getHybridVoiceSystem();
      const utterance = new SpeechSynthesisUtterance(msg);
      
      // Aplicar configuración híbrida
      Object.assign(utterance, hybridConfig);
      
      // Ajustar según cantidad de niños
      if (alertCount > 3) {
        utterance.rate = Math.max(utterance.rate * 0.9, 0.5);
        utterance.volume = Math.min(utterance.volume * 1.1, 1.0);
      }
      
      return utterance;
    }

    // Función para repetir mensajes 3 veces (mejorada para producción)
    function speakWithRepetition(message, alertCount) {
      console.log(`🔊 speakWithRepetition llamado con mensaje:`, message);
      console.log(`🔊 Estado del sistema:`, { 
        voiceNotificationsEnabled, 
        voiceSystemActivated, 
        speechSynthesisAvailable: 'speechSynthesis' in window 
      });
      
      // Verificar que el sistema de voz esté disponible y habilitado
      if (!voiceNotificationsEnabled || !('speechSynthesis' in window)) {
        console.warn('⚠️ Sistema de voz no disponible:', { voiceNotificationsEnabled, speechSynthesis: 'speechSynthesis' in window });
        return;
      }
      
      console.log(`🔊 Iniciando alerta de voz: ${alertCount} niño(s)`);
      
      // Usar sistema de cola para evitar interrupciones
      console.log('🎤 Usando sistema de COLA para repetición sin interrupciones');
      
      // LÓGICA ADAPTATIVA PARA EVITAR CONTAMINACIÓN DE AUDIO
      const repetitions = calculateAdaptiveRepetitions(message, alertCount);
      
      console.log(`🎤 Usando sistema ADAPTATIVO: ${repetitions.length} repeticiones para ${alertCount} niño(s)`);
      
      repetitions.forEach((rep, index) => {
        if (rep.options.immediate) {
          // Primera repetición inmediata
          addToVoiceQueue(rep.message, rep.options);
        } else {
          // Repeticiones con delay
          setTimeout(() => {
            addToVoiceQueue(rep.message, rep.options);
          }, rep.options.delay);
        }
      });
      
      console.log(`📝 Agregadas ${repetitions.length} repeticiones ADAPTATIVAS a la cola de voz`);
      console.log(`🔊 Alerta adaptativa programada: ${alertCount} niño(s) - ${repetitions.length} repeticiones`);
    }


    // Función para alertas de múltiples niños (más de 5) - DEPRECATED
    function speakMultipleChildrenAlert(pendingAlerts) {
      const children = Array.from(pendingAlerts.values());
      
      // Crear lista de nombres únicos (diferenciando por padres si es necesario)
      const uniqueNames = new Map();
      children.forEach(child => {
        let key = child.name;
        if (child.parents) {
          const parentName = child.parents.split(' & ')[0];
          key = `${child.name} (${parentName})`;
        }
        uniqueNames.set(key, child);
      });
      
      const names = Array.from(uniqueNames.keys());
      
      // Mensaje principal
      const mainMessage = `ATENCIÓN: ${children.length} niños han terminado su tiempo de juego`;
      
      // Lista de nombres (uno por uno)
      const nameList = names.join(', ');
      const detailedMessage = `Los niños son: ${nameList}`;
      
      // Mensaje de llamada a padres
      const callMessage = `Por favor, padres, recojan a sus hijos inmediatamente`;
      
      // Repetir 3 veces con pausas
      const fullMessage = `${mainMessage}. ${detailedMessage}. ${callMessage}`;
      
      // Función helper para crear utterance con voz mejorada y parámetros optimizados por navegador
      const createUtteranceWithVoice = (message) => {
        const utterance = new SpeechSynthesisUtterance(message);
        
        // Obtener parámetros optimizados por navegador
        const voiceParams = getVoiceParameters();
        utterance.lang = voiceParams.lang;
        utterance.rate = voiceParams.rate;
        utterance.pitch = voiceParams.pitch;
        utterance.volume = voiceParams.volume;
        
        // Configurar voz femenina en español (usando función helper mejorada)
        const selectedVoice = getFemaleSpanishVoice();
        
        if (selectedVoice) {
          utterance.voice = selectedVoice;
          console.log('🎤 Voz seleccionada:', selectedVoice.name, selectedVoice.lang, 'localService:', selectedVoice.localService);
        } else {
          console.warn('⚠️ No se encontró voz en español, usando configuración por defecto');
        }
        
        return utterance;
      };
      
      // Primera repetición
      setTimeout(() => {
        const utterance1 = createUtteranceWithVoice(fullMessage);
        window.speechSynthesis.speak(utterance1);
      }, 100);
      
      // Segunda repetición (después de 15 segundos - mejorado)
      setTimeout(() => {
        const utterance2 = createUtteranceWithVoice(fullMessage);
        window.speechSynthesis.speak(utterance2);
      }, 15000);
      
      // Tercera repetición (después de 30 segundos - mejorado)
      setTimeout(() => {
        const utterance3 = createUtteranceWithVoice(fullMessage);
        window.speechSynthesis.speak(utterance3);
      }, 30000);
      
      console.log(`🔊 Alerta múltiple: ${children.length} niños - ${names.length} nombres únicos`);
    }

    // Sistema de notificaciones de voz
    function speakChildName(childName, parentsInfo = '') {
      try {
        // Verificar si las notificaciones de voz están habilitadas
        if (!voiceNotificationsEnabled) {
          console.log('Notificaciones de voz desactivadas');
          return;
        }

        // Verificar si el navegador soporta Speech Synthesis
        if (!('speechSynthesis' in window)) {
          console.warn('Speech synthesis no soportado en este navegador');
          return;
        }

        // Cancelar cualquier síntesis anterior
        window.speechSynthesis.cancel();

        // Las voces se cargarán en getFemaleSpanishVoice si es necesario

        // Crear el mensaje personalizado
        let message = `${childName}, tu tiempo de juego ha terminado`;
        if (parentsInfo) {
          message += `. ${parentsInfo}, por favor recojan a ${childName}`;
        }

        // Usar sistema híbrido para sonido humano universal
        console.log('🎤 Usando sistema híbrido para sonido humano universal');
        return speakWithHybridVoice(message);
        
        console.log(`🔊 Mensaje de voz: "${message}"`);
        
      } catch (error) {
        console.error('Error en síntesis de voz:', error);
        // Fallback al sonido normal si falla la voz
        playNotificationSound('warning');
      }
    }

    // Sistema de alertas mejorado
    function showCustomModal(msg) {
      // Reproducir sonido de notificación
      playNotificationSound('danger');
      
      // Mostrar notificación del navegador
      showBrowserNotification('⏰ Tiempo Terminado', msg);
      
      // Crear alerta persistente en la esquina
      const alertContainer = document.getElementById('alertContainer') || createAlertContainer();
      
      const alertId = 'alert-' + Date.now();
      const alert = document.createElement('div');
      alert.id = alertId;
      alert.className = 'persistent-alert';
      alert.innerHTML = `
        <div class="alert-content">
          <span class="alert-message">${msg}</span>
          <button class="alert-close" onclick="closeAlert('${alertId}')">
            <i class="fas fa-times"></i>
          </button>
        </div>
      `;
      
      alertContainer.appendChild(alert);
      
      // Auto-remover después de 10 segundos si no se cierra manualmente
      setTimeout(() => {
        if (document.getElementById(alertId)) {
          closeAlert(alertId);
        }
      }, 10000);
    }
    
    function createAlertContainer() {
      const container = document.createElement('div');
      container.id = 'alertContainer';
      container.className = 'alert-container';
      document.body.appendChild(container);
      return container;
    }
    
    function closeAlert(alertId) {
      const alert = document.getElementById(alertId);
      if (alert) {
        alert.style.display = 'none';
        alert.style.opacity = '0';
        alert.style.transform = 'translateX(100%)';
        alert.style.transition = 'all 0.3s ease';
        setTimeout(() => {
          if (alert && alert.parentNode) {
          alert.remove();
          }
        }, 100);
      }
    }

    // Función para limpiar alertas transparentes
    function clearTransparentAlerts() {
      // Limpiar statusMessage específicamente
      const statusMsg = document.getElementById('statusMessage');
      if (statusMsg) {
        statusMsg.style.display = 'none';
        statusMsg.style.opacity = '0';
        statusMsg.style.transform = 'translateX(400px)';
      }
      
      // Limpiar otras alertas transparentes
      const alerts = document.querySelectorAll('.status-message, .alert-container > div');
      alerts.forEach(alert => {
        if (alert.style.opacity === '0' || alert.style.display === 'none') {
          alert.remove();
        }
      });
    }
    
    
    // Función para mostrar alertas elegantes
    function showElegantAlert(msg, type = 'info', sessionId = null) {
      const container = document.getElementById('alertContainer') || createAlertContainer();
      const alertId = `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      const alertElement = document.createElement('div');
      alertElement.className = 'persistent-alert';
      alertElement.id = alertId;
      
      // Truncar mensaje si es muy largo
      const truncatedMsg = msg.length > 60 ? msg.substring(0, 57) + '...' : msg;
      
      alertElement.innerHTML = `
        <div class="alert-content">
          <div class="alert-message">${truncatedMsg}</div>
          <button class="alert-close" onclick="closeAlert('${alertId}')">
            <i class="fas fa-times"></i>
          </button>
        </div>
      `;
      
      container.appendChild(alertElement);
      
      // Auto-cerrar después de 8 segundos
      setTimeout(() => {
        closeAlert(alertId);
      }, 8000);
      
    }

    // Función para limpiar todas las alertas persistentes
    function clearAllPersistentAlerts() {
      const alertContainer = document.getElementById('alertContainer');
      if (alertContainer) {
        alertContainer.innerHTML = '';
      }
      // También limpiar cualquier alerta que pueda estar fuera del contenedor
      document.querySelectorAll('.persistent-alert').forEach(alert => {
        alert.remove();
      });
    }

    function closeModal() {
      document.getElementById('customModal').classList.remove('show');
    }

    function showExtendModal(sessionId, childName) {
      currentExtendSession = sessionId;
      
      // Buscar información del niño para mostrar padres si existen
      const session = activeSessionsData.find(s => s.id === sessionId);
      const child = session ? childrenCache.find(c => c.id === session.childId) : null;
      
      let displayMessage = `¿Cuánto tiempo adicional quiere darle a ${childName}?`;
      if (child) {
        const parentsText = getParentsInfo(child, 'simple');
        if (parentsText) {
          displayMessage = `¿Cuánto tiempo adicional quiere darle a ${childName}${parentsText}?`;
        }
      }
      
      document.getElementById('extendMsg').textContent = displayMessage;
      document.getElementById('extendTimeInput').value = 5;
      document.getElementById('extendModal').classList.add('show');
    }

    function closeExtendModal() {
      document.getElementById('extendModal').classList.remove('show');
      currentExtendSession = null;
    }


    function validateSession(childId, gameId, duration) {
      // Solo validar duración aquí, los otros valores ya se validaron arriba
      if (isNaN(duration)) {
        showStatusMessage('El tiempo debe ser un número válido', 'error');
        return false;
      }
      if (duration < 1) {
        showStatusMessage('El tiempo mínimo es 1 minuto', 'error');
        return false;
      }
      if (duration > 180) {
        showStatusMessage('El tiempo máximo es 180 minutos', 'error');
        return false;
      }
      return true;
    }

    // Funciones de fetch ROBUSTAS con reintentos
    async function fetchWithRetry(url, options = {}, retries = 3) {
      // 🚀 OPTIMIZACIÓN: Reduce timeout para carga inicial más rápida
      const timeoutMs = options.initialLoad ? 5000 : 8000; // 5s para carga inicial, 8s para el resto
      
      // Extraer opciones especiales
      const { initialLoad, silent404, ...fetchOptions } = options;
      
      for (let i = 0; i < retries; i++) {
        try {
          // Crear AbortController para timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
          
          const finalFetchOptions = {
            ...fetchOptions,
            signal: controller.signal
          };
          
          const res = await fetch(url, finalFetchOptions);
          clearTimeout(timeoutId);
          
          if (res.ok) {
            return res;
          }
          
          // Manejo especial para 404 silencioso (para finalizar sesiones)
          if (res.status === 404 && silent404) {
            return res; // Retornar la respuesta 404 sin lanzar error
          }
          
          // Manejo especial para rate limiting (429)
          if (res.status === 429) {
            const retryAfter = res.headers.get('retry-after') || '60';
            const waitTime = parseInt(retryAfter) * 1000;
            console.warn(`Rate limited, esperando ${retryAfter} segundos...`);
            await new Promise(resolve => setTimeout(resolve, waitTime));
            continue; // Reintentar sin contar como fallo
          }
          
          if (i === retries - 1) {
            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          }
        } catch (error) {
          if (error.name === 'AbortError') {
            throw new Error(`Timeout: La solicitud tardó más de ${timeoutMs/1000} segundos`);
          }
          
          if (i === retries - 1) {
            throw error;
          }
          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
      }
    }

    async function fetchChildren(forceRefresh = false) {
      try {
        // Limpiar caché si es refresh forzado
        if (forceRefresh) {
          childrenCache = [];
        }
        
        const timestamp = Date.now();
        const res = await fetchWithRetry(api + '/children?t=' + timestamp);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        // Validar que la respuesta sea JSON válido
        let children;
        try {
          const text = await res.text();
          if (!text || text.trim() === '') {
            throw new Error('Respuesta vacía del servidor');
          }
          children = JSON.parse(text);
        } catch (parseError) {
          console.error('Error parsing JSON:', parseError);
          throw new Error('Respuesta inválida del servidor');
        }
        
        // Verificar que los datos son válidos
        if (!Array.isArray(children)) {
          console.error('Invalid children data format:', children);
          throw new Error('Invalid children data format');
        }
        
        childrenCache = children || [];
        
        // Renderizar inmediatamente
        renderChildrenList(childrenCache);
        updateChildSelect(childrenCache);
        
        return childrenCache;
      } catch (error) {
        console.error('Error fetching children:', error);
        showStatusMessage('Error al cargar la lista de niños', 'error');
        childrenCache = [];
        renderChildrenList([]);
        updateChildSelect([]);
        throw error; // Re-throw para que initializeApp pueda manejarlo
      }
    }


    async function fetchGames() {
      try {
        console.log('Fetching games from:', api + '/games');
        
        // LIMPIAR CACHÉ ANTES DE FETCH
        gamesCache = [];
        renderGamesList([]);
        updateGameSelect([]);
        
        const res = await fetchWithRetry(api + '/games');
        console.log('Games response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        // Validar que la respuesta sea JSON válido
        let games;
        try {
          const text = await res.text();
          if (!text || text.trim() === '') {
            throw new Error('Respuesta vacía del servidor');
          }
          games = JSON.parse(text);
        } catch (parseError) {
          console.error('Error parsing games JSON:', parseError);
          throw new Error('Respuesta inválida del servidor');
        }
        
        console.log('Games data received:', games, 'Length:', games ? games.length : 0);
        
        // VALIDAR Y ASIGNAR DATOS
        gamesCache = Array.isArray(games) ? games : [];
        
        // RENDERIZAR INMEDIATAMENTE
        renderGamesList(gamesCache);
        updateGameSelect(gamesCache);
        
        console.log('Games loaded successfully - Cache length:', gamesCache.length, 'Cache content:', gamesCache.map(g => `${g.id}:${g.name}`));
      } catch (error) {
        console.error('Error fetching games:', error);
        showStatusMessage('Error al cargar la lista de juegos', 'error');
        gamesCache = [];
        renderGamesList([]);
        updateGameSelect([]);
        throw error; // Re-throw para que initializeApp pueda manejarlo
      }
    }

    function renderChildrenList(children) {
      const list = document.getElementById('childrenList');
      console.log('renderChildrenList called with:', children ? children.length : 0, 'children');
      console.log('Children data:', children);
      
      if (!list) {
        console.error('childrenList element not found');
        return;
      }
      
      if (!children || children.length === 0) {
        console.log('No children to render, showing empty message');
        list.innerHTML = '<li class="list-item">No hay niños registrados</li>';
        return;
      }
      
      console.log('Rendering children list with', children.length, 'items');
        list.innerHTML = children.map(child => {
          const displayName = sanitizeHTML(child.displayName || child.name);
          const avatar = sanitizeHTML(child.avatar || child.name.charAt(0).toUpperCase());
          const fatherName = sanitizeHTML((child.father_name || child.fatherName) || '');
          const motherName = sanitizeHTML((child.mother_name || child.motherName) || '');
          const totalTime = child.totalTimePlayed || 0;
          
          // Información de padres mejorada para mejor diferenciación
          let parentsInfo = '';
          // Usar los nombres correctos del backend (con guión bajo)
          const backendFatherName = child.father_name || child.fatherName;
          const backendMotherName = child.mother_name || child.motherName;
          
          console.log(`Child ${child.name} parent data:`, { 
            fatherName: backendFatherName, 
            motherName: backendMotherName 
          });
          
          if (backendFatherName && backendMotherName) {
            parentsInfo = `<div class="child-parents" style="color: #555; font-size: 12px; font-style: italic; margin-top: 2px;">
              <i class="fas fa-users" style="margin-right: 4px;"></i>${backendFatherName} & ${backendMotherName}
            </div>`;
          } else if (backendFatherName) {
            parentsInfo = `<div class="child-parents" style="color: #555; font-size: 12px; font-style: italic; margin-top: 2px;">
              <i class="fas fa-male" style="margin-right: 4px;"></i>Papá: ${backendFatherName}
            </div>`;
          } else if (backendMotherName) {
            parentsInfo = `<div class="child-parents" style="color: #555; font-size: 12px; font-style: italic; margin-top: 2px;">
              <i class="fas fa-female" style="margin-right: 4px;"></i>Mamá: ${backendMotherName}
            </div>`;
          }

          return `<li class="list-item child-item">
            <div class="child-info" style="flex: 1; margin-right: 10px;">
              <span class="child-avatar">${avatar}</span>
              <div class="child-details">
                <div class="child-name">${displayName}</div>
                ${parentsInfo}
                <div class="child-time">${totalTime} min</div>
              </div>
            </div>
            <div class="delete-button-container" style="flex-shrink: 0;">
              <div class="button-group-small">
                <button onclick="editChild(${child.id})" class="btn-edit" title="Editar información">
                  <i class="fas fa-edit"></i>
                </button>
                <button onclick="deleteChild(${child.id})" class="btn-danger btn-small" title="Eliminar niño">
            <i class="fas fa-trash"></i>
          </button>
              </div>
            </div>
          </li>`;
        }).join('');
        
        console.log('Children list rendered with', children.length, 'items');
        console.log('List HTML length:', list.innerHTML.length);
    }

    function renderGamesList(games) {
      const list = document.getElementById('gamesList');
      if (!list) return;
      
      if (!games || games.length === 0) {
        list.innerHTML = '<li class="list-item">No hay juegos registrados</li>';
        return;
      }
      list.innerHTML = games.map(game => 
        `<li class="list-item">
          <div style="flex: 1; margin-right: 10px;">
          <span><i class="fas fa-dice"></i> ${sanitizeHTML(game.name)}</span>
          </div>
          <div class="delete-button-container" style="flex-shrink: 0;">
            <button onclick="deleteGame(${game.id})" class="btn-danger btn-small">
            <i class="fas fa-trash"></i>
          </button>
          </div>
        </li>`
      ).join('');
    }

    function updateChildSelect(children) {
      const select = document.getElementById('selectedChildId');
      if (!select) return;
      
      select.innerHTML = '<option value="">Seleccione un niño</option>' +
        (children || []).map(child => {
          const displayName = sanitizeHTML(child.displayName || child.name);
          
          // Agregar información de padres si existe para diferenciar
          let parentInfo = '';
          const fatherName = child.father_name || child.fatherName;
          const motherName = child.mother_name || child.motherName;
          if (fatherName || motherName) {
            const father = sanitizeHTML(fatherName || '');
            const mother = sanitizeHTML(motherName || '');
            const separator = father && mother ? ', ' : '';
            parentInfo = ` (${father}${separator}${mother})`;
          }
          
          return `<option value="${child.id}">${displayName}${parentInfo}</option>`;
        }).join('');
    }

    function updateGameSelect(games) {
      const select = document.getElementById('gameSelect');
      if (!select) {
        console.warn('Game select element not found');
        return;
      }
      
      console.log('Updating game select with games:', games ? games.length : 0, 'games');
      
      if (!games || !Array.isArray(games) || games.length === 0) {
        console.warn('No games provided to updateGameSelect');
        select.innerHTML = '<option value="">Seleccione un juego</option>';
        return;
      }
      
      select.innerHTML = '<option value="">Seleccione un juego</option>' +
        games.map(game => `<option value="${game.id}">${sanitizeHTML(game.name)}</option>`).join('');
        
      console.log('Game select updated with', games.length, 'options');
    }

    // Función para forzar la recarga de juegos
    async function forceRefreshGames() {
      console.log('🔄 Forzando recarga de juegos...');
      showStatusMessage('Recargando lista de juegos...', 'info');
      
      try {
        // Limpiar caché completamente
        gamesCache = [];
        updateGameSelect([]);
        
        // Hacer fetch directo
        const response = await fetch(api + '/games');
        console.log('Force refresh - Response status:', response.status);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const games = await response.json();
        console.log('Force refresh - Games received:', games);
        
        if (Array.isArray(games)) {
          gamesCache = games;
          updateGameSelect(gamesCache);
          renderGamesList(gamesCache);
          
          console.log('✅ Juegos recargados exitosamente:', gamesCache.length);
          showStatusMessage(`✅ ${gamesCache.length} juegos cargados`, 'success');
        } else {
          throw new Error('Formato de datos inválido');
        }
        
      } catch (error) {
        console.error('❌ Error forzando recarga de juegos:', error);
        showStatusMessage('❌ Error al recargar juegos', 'error');
        gamesCache = [];
        updateGameSelect([]);
      }
    }

    // Funciones de sesiones activas ROBUSTAS
    async function fetchActiveSessions() {
      try {
        console.log('Fetching active sessions from:', api + '/sessions/active');
        const res = await fetchWithRetry(api + '/sessions/active');
        console.log('Active sessions response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const newActiveSessionsData = await res.json() || [];
        console.log('Active sessions data received:', newActiveSessionsData);
        
        // Actualizar siempre para mostrar cambios
        activeSessionsData = newActiveSessionsData;
        console.log('Active sessions data updated:', activeSessionsData);
        console.log('Children cache length:', childrenCache.length);
        console.log('Games cache length:', gamesCache.length);
        renderActiveSessions();
        console.log('Active sessions rendered:', activeSessionsData.length, 'sessions');
        
      } catch (error) {
        console.error('Error fetching active sessions:', error);
        
        // NO resetear las sesiones activas en caso de error
        console.warn('Failed to fetch active sessions, keeping current data');
        
        // Solo actualizar timers con datos existentes
        if (activeSessionsData.length > 0) {
          updateExistingTimers();
        } else {
          // Si no hay datos, mostrar mensaje de no sesiones activas
          const list = document.getElementById('activeSessions');
          if (list) {
            list.innerHTML = '<li class="list-item">No hay sesiones activas</li>';
          }
        }
      }
    }


    function renderActiveSessions() {
      const list = document.getElementById('activeSessions');
      if (!list) return;
      
      // Limitar a 50 sesiones visibles para mejor rendimiento
      const visibleSessions = activeSessionsData.slice(0, 50);
      const hiddenCount = activeSessionsData.length - 50;
      
      if (activeSessionsData.length === 0) {
        if (list.innerHTML !== '<li class="list-item">No hay sesiones activas</li>') {
          list.innerHTML = '<li class="list-item">No hay sesiones activas</li>';
        }
        return;
      }
      
      // Solo re-renderizar si la estructura cambió
      const sessionHash = visibleSessions.map(s => `${s.id}-${s.childId}-${s.gameId}-${s.duration}`).join('|');
      
      if (list.dataset.sessionHash !== sessionHash) {
        let html = visibleSessions.map(s => generateSingleSessionHTML(s)).join('');
        
        if (hiddenCount > 0) {
          html += `<li class="list-item info"><i class="fas fa-info-circle"></i> ... y ${hiddenCount} sesiones más</li>`;
        }
        
        list.innerHTML = html;
        list.dataset.sessionHash = sessionHash;
        startTimers();
        console.log('Active sessions structure updated:', visibleSessions.length, 'visible,', hiddenCount, 'hidden');
      }
    }
    
    function generateSingleSessionHTML(s) {
      const child = childrenCache.find(c => c.id === s.childId);
      const game = gamesCache.find(g => g.id === s.gameId);
      
      // Si no encontramos el niño o juego, solo mostrar datos desconocidos
      if (!child || !game) {
        console.warn('Missing child or game data for session:', s.id);
      }
      
      // Usar displayName si existe y no es null/undefined, sino el nombre original
      const childDisplayName = child ? (child.displayName && child.displayName !== 'null' ? child.displayName : child.name) : 'Niño desconocido';
      const childAvatar = child ? (child.avatar || child.name.charAt(0).toUpperCase()) : '?';
      const gameName = game ? game.name : 'Juego desconocido';
      
      // Información de padres para diferenciación
      let parentsInfo = '';
      if (child) {
        const fatherName = child.father_name || child.fatherName;
        const motherName = child.mother_name || child.motherName;
        
        parentsInfo = getParentsInfo(child, 'html');
      }
      
      return '<li class="list-item active" data-session-id="' + s.id + '" id="session-' + s.id + '">' +
        '<div class="session-info">' +
          '<strong><span class="child-avatar-small">' + childAvatar + '</span> <i class="fas fa-child"></i> ' + childDisplayName + '</strong>' + parentsInfo + '<br>' +
          '<small><i class="fas fa-gamepad"></i> ' + gameName + '</small><br>' +
          '<small><i class="fas fa-clock"></i> Duración: ' + s.duration + ' min</small>' +
        '</div>' +
        '<div class="session-controls">' +
          '<div class="timer" id="timer-' + s.id + '">Calculando...</div>' +
          '<div class="button-group">' +
            '<button class="btn-danger" onclick="endSession(' + s.id + ')" style="padding: 4px 8px; font-size: 11px; margin-right: 3px;">' +
              '<i class="fas fa-stop"></i> FIN' +
            '</button>' +
            '<button class="extend-time" onclick="showExtendModal(' + s.id + ', \`' + childDisplayName + '\`)" style="padding: 4px 8px; font-size: 11px;">' +
              '<i class="fas fa-plus"></i> +5' +
            '</button>' +
          '</div>' +
        '</div>' +
      '</li>';
    }
    
    function generateActiveSessionsHTML() {
      if (!activeSessionsData || activeSessionsData.length === 0) {
        return '<li class="list-item">No hay sesiones activas</li>';
      }
      
      return activeSessionsData.map(s => {
        const child = childrenCache.find(c => c.id === s.childId);
        const game = gamesCache.find(g => g.id === s.gameId);
        
        // Si no encontramos el niño o juego, solo mostrar datos desconocidos
        if (!child || !game) {
          console.warn('Missing child or game data for session:', s.id);
        }
        
        // Usar displayName si existe y no es null/undefined, sino el nombre original
        const childDisplayName = child ? (child.displayName && child.displayName !== 'null' ? child.displayName : child.name) : 'Niño desconocido';
        const childAvatar = child ? (child.avatar || child.name.charAt(0).toUpperCase()) : '?';
        const gameName = game ? game.name : 'Juego desconocido';
        
        // Información de padres para diferenciación
        let parentsInfo = getParentsInfo(child, 'html');
        
        return `<li class="list-item active" data-session-id="${s.id}" id="session-${s.id}">
          <div class="session-info">
            <strong><span class="child-avatar-small">${childAvatar}</span> <i class="fas fa-child"></i> ${childDisplayName}</strong>${parentsInfo}<br>
            <small><i class="fas fa-gamepad"></i> ${gameName}</small><br>
            <small><i class="fas fa-clock"></i> Duración: ${s.duration} min</small>
          </div>
          <div class="session-controls">
            <div class="timer" id="timer-${s.id}">Calculando...</div>
            <div class="button-group">
              <button class="btn-danger" onclick="endSession(${s.id})" style="padding: 4px 8px; font-size: 11px; margin-right: 3px;">
                <i class="fas fa-stop"></i> FIN
              </button>
              <button class="extend-time" onclick="showExtendModal(${s.id}, \`${childDisplayName}\`)" style="padding: 4px 8px; font-size: 11px;">
                <i class="fas fa-plus"></i> +5
              </button>
            </div>
          </div>
        </li>`;
      }).join('');
    }
    
    function updateExistingTimers() {
      // Solo actualizar timers existentes sin recrear el DOM
      const list = document.getElementById('activeSessions');
      if (!list) return;
      
      if (!activeSessionsData || activeSessionsData.length === 0) return;
      
      activeSessionsData.forEach(s => {
        const sessionElement = list.querySelector(`[data-session-id="${s.id}"]`);
        const timerElement = sessionElement ? sessionElement.querySelector('.timer') : null;
        
        if (!sessionElement || !timerElement) return;
        
          // Actualizar directamente el contenido del timer sin recrear el elemento
          const now = Date.now();
        
        // Buscar startTime en múltiples formatos posibles
        let startTime = s.start || s.startTime;
        
        // Convertir string a timestamp si es necesario
        if (typeof startTime === 'string') {
          startTime = new Date(startTime).getTime();
        }
        
        // Si no hay startTime válido, usar createdAt como fallback
        if (!startTime || isNaN(startTime)) {
          startTime = s.created_at ? new Date(s.created_at).getTime() : now;
        }
        
        // Asegurar que startTime es un número válido
        if (isNaN(startTime) || startTime <= 0) {
          startTime = now;
        }
        
        const elapsed = Math.floor((now - startTime) / 1000);
        const totalDurationSeconds = (s.duration || 1) * 60;
        const remaining = Math.max(0, totalDurationSeconds - elapsed);
        
        // Validar que los cálculos son válidos
        if (isNaN(elapsed) || isNaN(remaining) || isNaN(totalDurationSeconds)) {
          console.error('Invalid timer calculation:', { elapsed, remaining, totalDurationSeconds, startTime, now, duration: s.duration });
          timerElement.innerHTML = '<strong>Calculando...</strong>';
          timerElement.className = 'timer';
          return;
        }
          
          if (remaining <= 0) {
          timerElement.innerHTML = '<strong>Tiempo agotado</strong>';
            timerElement.className = 'timer danger';
          } else {
            const h = Math.floor(remaining / 3600);
            const m = Math.floor((remaining % 3600) / 60);
            const s = remaining % 60;
            const elapsedMin = Math.floor(elapsed / 60);
            const elapsedSec = elapsed % 60;
            
          timerElement.innerHTML = 'Restante: ' + h + ':' + m.toString().padStart(2, '0') + ':' + s.toString().padStart(2, '0') + '<br><small>Transcurrido: ' + elapsedMin + ':' + elapsedSec.toString().padStart(2, '0') + '</small>';
            
            // Cambiar color según tiempo restante
            if (remaining <= 60) {
              timerElement.className = 'timer danger';
            } else if (remaining <= 300) {
              timerElement.className = 'timer warning';
            } else {
              timerElement.className = 'timer';
          }
        }
      });
    }

    function startTimers() {
      // Limpiar timers de sesiones que ya no existen
      const currentSessionIds = activeSessionsData.map(s => s.id);
      timerIntervals.forEach((interval, sessionId) => {
        if (!currentSessionIds.includes(sessionId)) {
          clearInterval(interval);
          timerIntervals.delete(sessionId);
        }
      });

      // Crear timers solo para sesiones nuevas
      activeSessionsData.forEach(s => {
        if (!timerIntervals.has(s.id)) {
          let startTime = s.start || s.startTime || Date.now();
          if (typeof startTime === 'string') {
            startTime = new Date(startTime).getTime();
          }
          updateTimer(s.id, startTime, s.duration);
          const interval = setInterval(() => updateTimer(s.id, startTime, s.duration), 1000);
          timerIntervals.set(s.id, interval);
        }
      });
    }

    function updateTimer(sessionId, startTime, duration) {
      const timerSpan = document.getElementById(`timer-${sessionId}`);
      if (!timerSpan) return;
      
      // Usar datos actualizados de activeSessionsData si están disponibles
      const sessionData = activeSessionsData.find(s => s.id === sessionId);
      
      // Convertir timestamp de string a número si es necesario
      let currentStartTime = sessionData ? (sessionData.start || sessionData.startTime || startTime) : startTime;
      if (typeof currentStartTime === 'string') {
        currentStartTime = new Date(currentStartTime).getTime();
      }
      
      const currentDuration = sessionData ? sessionData.duration : duration;
      
      // VALIDACIÓN CRÍTICA DE DURACIÓN
      if (!currentDuration || typeof currentDuration !== 'number' || currentDuration <= 0) {
        console.error('Invalid duration in updateTimer:', { sessionId, currentDuration, sessionData });
        timerSpan.textContent = '⏱️ Duración inválida';
        return;
      }
      
      const now = Date.now();
      
      // Validar que currentStartTime es un número válido
      if (isNaN(currentStartTime) || currentStartTime <= 0) {
        console.error('Invalid startTime in updateTimer:', { sessionId, currentStartTime, sessionData });
        timerSpan.textContent = '⏱️ Calculando...';
        return;
      }
      
      const elapsedSeconds = Math.floor((now - currentStartTime) / 1000);
      const totalSeconds = Math.floor(currentDuration * 60);
      const remainingSeconds = totalSeconds - elapsedSeconds;
      
      // VALIDACIÓN CRÍTICA DE CÁLCULOS
      if (isNaN(elapsedSeconds) || isNaN(totalSeconds) || isNaN(remainingSeconds)) {
        console.error('Invalid timer calculations:', { sessionId, elapsedSeconds, totalSeconds, remainingSeconds });
        timerSpan.textContent = '⏱️ Error de cálculo';
        return;
      }
      
      const h = String(Math.floor(remainingSeconds / 3600)).padStart(2, '0');
      const m = String(Math.floor((remainingSeconds % 3600) / 60)).padStart(2, '0');
      const s = String(remainingSeconds % 60).padStart(2, '0');
      
      // Calcular tiempo transcurrido para mostrar también
      const elapsedMinutes = Math.floor(elapsedSeconds / 60);
      const elapsedSecs = elapsedSeconds % 60;
      
      // Actualizar clases según el tiempo restante
      timerSpan.className = 'timer';
      if (remainingSeconds <= 0) {
        timerSpan.textContent = '⏰ ¡Tiempo terminado!';
        timerSpan.classList.add('danger');
        if (!timerSpan.classList.contains('alerted')) {
          timerSpan.classList.add('alerted');
          const session = activeSessionsData.find(s => s.id === sessionId);
          const child = childrenCache.find(c => c.id === session.childId);
          
          // 🔊 CRÍTICO: Activar notificaciones de voz cuando se acaba el tiempo
          if (child) {
            let childName = child.displayName || child.name;
            let parentsInfo = '';
            
            // Construir información de padres de manera compatible con la función
            parentsInfo = getParentsInfo(child, 'simple');
            
            console.log('🔊 Disparando alerta de voz para:', childName, parentsInfo);
            showConsolidatedTimeAlert(childName, parentsInfo);
          }
          
          showCustomModal(`¡Se acabó el tiempo para ${child ? child.name : 'este niño'}!`);
          endSession(sessionId);
        }
      } else if (remainingSeconds <= 60) {
        timerSpan.innerHTML = '<strong>Restante:</strong> ' + sanitizeHTML(m) + ':' + sanitizeHTML(s) + '<br><small>Transcurrido: ' + sanitizeHTML(String(elapsedMinutes)) + ':' + sanitizeHTML(String(elapsedSecs).padStart(2, '0')) + '</small>';
        timerSpan.classList.add('warning');
        // Alerta cuando quedan 30 segundos
        if (remainingSeconds <= 30 && !timerSpan.classList.contains('alerted-30')) {
          timerSpan.classList.add('alerted-30');
          const session = activeSessionsData.find(s => s.id === sessionId);
          const child = childrenCache.find(c => c.id === session.childId);
          
          let childDisplayName = child ? (child.displayName || child.name) : 'este niño';
          let parentsText = getParentsInfo(child, 'simple');
          
          // SOLO ALERTAR UNA VEZ A LOS 30 SEGUNDOS - NO CADA SEGUNDO
          if (remainingSeconds === 30) {
            showStatusMessage(`¡Atención! A ${childDisplayName}${parentsText} le quedan solo 30 segundos`, 'warning', sessionId, { voiceOnly: false });
          }
        }
      } else {
        timerSpan.innerHTML = '<strong>Restante:</strong> ' + sanitizeHTML(h) + ':' + sanitizeHTML(m) + ':' + sanitizeHTML(s) + '<br><small>Transcurrido: ' + sanitizeHTML(String(elapsedMinutes)) + ':' + sanitizeHTML(String(elapsedSecs).padStart(2, '0')) + '</small>';
      }
    }

    async function fetchSessionHistory() {
      try {
        console.log('Fetching session history from:', api + '/sessions');
        const res = await fetchWithRetry(api + '/sessions');
        console.log('Session history response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const sessions = await res.json() || [];
        console.log('Session history data received:', sessions);
        
        renderSessionHistory(sessions);
        console.log('Session history loaded successfully:', sessions);
      } catch (error) {
        console.error('Error fetching session history:', error);
        
        // En caso de error, mostrar mensaje de no historial
        const list = document.getElementById('sessionHistory');
        if (list) {
          list.innerHTML = '<li class="list-item">No hay sesiones registradas</li>';
        }
        
        console.warn('Failed to fetch session history, showing empty state');
      }
    }

    function renderSessionHistory(sessions) {
      const list = document.getElementById('sessionHistory');
      if (!list) return;
      
      if (!sessions || sessions.length === 0) {
        list.innerHTML = '<div class="history-item" style="text-align: center; padding: 20px; color: #666;"><i class="fas fa-history" style="font-size: 24px; margin-bottom: 8px; display: block;"></i>No hay sesiones registradas</div>';
        return;
      }
      
      // Asegurar que tenemos datos de niños y juegos antes de renderizar
      if (childrenCache.length === 0 || gamesCache.length === 0) {
        console.log('Missing cache data, refreshing...');
        fetchChildren().then(() => fetchGames()).then(() => {
          // Re-renderizar con datos actualizados
          renderSessionHistory(sessions);
        });
        return;
      }
      
      // Mostrar las últimas 5 sesiones por defecto, resto colapsado
      const recentSessions = sessions.slice(0, 5);
      const hiddenSessions = sessions.slice(5);
      
      let html = '';
      
      // Botón para expandir/colapsar si hay más de 5 sesiones - RESTAURADO
      if (sessions.length > 5) {
        html += `
        <button class="history-toggle" onclick="toggleHistoryView()" id="historyToggle">
          <i class="fas fa-chevron-down"></i>
          Ver ${hiddenSessions.length} sesiones anteriores
        </button>`;
      }
      
      html += recentSessions.map(s => {
        const child = childrenCache.find(c => c.id === s.childId);
        const game = gamesCache.find(g => g.id === s.gameId);
        
        // Usar nombres reales, si no se encuentran, mostrar "Desconocido"
        const childName = child ? (child.displayName && child.displayName !== 'null' ? child.displayName : child.name) : 'Niño desconocido';
        const gameName = game ? game.name : 'Juego desconocido';
        
        // Información de padres para diferenciación
        let parentsInfo = getParentsInfo(child, 'history');
        
        const startTimeValue = s.startTime || s.start || Date.now();
        const startTime = new Date(startTimeValue);
        const timeStr = startTime.toLocaleTimeString('es-ES', {
          hour: '2-digit',
          minute: '2-digit'
        });
        const dateStr = startTime.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit'
        });
        
        let statusClass, iconClass, durationText, durationClass;
        
        if (s.endTime || s.end) {
          // Sesión finalizada
          const endTimeValue = s.endTime || s.end;
          const endTime = new Date(endTimeValue);
          
          // Para sesiones con endTime, siempre mostrar FINALIZADO (fue finalizada manualmente)
          // No importa la duración - si tiene endTime, fue por botón FIN
          durationText = 'FINALIZADO'; // Usuario presionó FIN
          statusClass = 'completed';
          iconClass = 'completed';
          durationClass = 'completed';
        } else {
          // Sesión en curso - usar la misma lógica que renderActiveSessions
          const currentTime = Date.now();
          
          // Verificar que startTimeValue sea válido
          if (isNaN(startTime.getTime())) {
            console.warn('Invalid start time for session:', s.id, 'start:', startTimeValue);
            durationText = 'FINALIZADO'; // Sesión antigua con datos corruptos
            statusClass = 'completed';
            iconClass = 'completed';
            durationClass = 'completed';
          } else {
            const elapsedSeconds = Math.floor((currentTime - startTime.getTime()) / 1000);
            const totalSeconds = (s.duration || 15) * 60;
            const remainingSeconds = Math.max(0, totalSeconds - elapsedSeconds);
            
            // Convertir a minutos para mostrar
            const elapsedMinutes = Math.floor(elapsedSeconds / 60);
            const totalMinutes = s.duration || 15;
          
            if (remainingSeconds <= 0) {
              statusClass = 'expired';
              iconClass = 'expired';
              durationText = 'Agotado';
              durationClass = 'expired';
            } else {
              statusClass = 'active';
              iconClass = 'active';
              durationText = `${elapsedMinutes}/${totalMinutes}min`;
              durationClass = 'active';
            }
          }
        }
        
        return `
        <div class="history-item ${statusClass}">
          <div class="history-icon ${iconClass}">
            <i class="fas fa-${s.endTime || s.end ? 'check-circle' : (statusClass === 'expired' ? 'exclamation-triangle' : 'play-circle')}"></i>
          </div>
          <div class="history-content">
            <div class="history-title">
              <i class="fas fa-child"></i>
              ${childName}
            </div>
            ${parentsInfo}
            <div class="history-subtitle">
              <i class="fas fa-gamepad"></i>
              ${gameName}
            </div>
          </div>
          <div class="history-meta">
            <div class="history-duration ${durationClass}">
              ${durationText}
            </div>
            <div class="history-time">
              ${dateStr} ${timeStr}
            </div>
          </div>
        </div>`;
      }).join('');
      
      // Agregar sesiones ocultas si las hay
      if (hiddenSessions.length > 0) {
        html += `<div id="hiddenSessions" class="history-hidden">`;
        html += hiddenSessions.map(s => {
          const child = childrenCache.find(c => c.id === s.childId);
          const game = gamesCache.find(g => g.id === s.gameId);
          
          const childName = child ? (child.displayName && child.displayName !== 'null' ? child.displayName : child.name) : 'Niño desconocido';
          const gameName = game ? game.name : 'Juego desconocido';
          
          // Información de padres para diferenciación
          let parentsInfo = getParentsInfo(child, 'history');
          
          const startTime = new Date(s.start);
          const timeStr = startTime.toLocaleTimeString('es-ES', {
            hour: '2-digit',
            minute: '2-digit'
          });
          const dateStr = startTime.toLocaleDateString('es-ES', {
            day: '2-digit',
            month: '2-digit'
          });
          
          let statusClass, iconClass, durationText, durationClass;
          
          if (s.end) {
            const duration = Math.round((s.end - s.start) / 60000);
            statusClass = 'completed';
            iconClass = 'completed';
            durationText = 'FINALIZADO'; // Siempre FINALIZADO para sesiones con end
            durationClass = 'completed';
          } else {
            const currentTime = Date.now();
            const elapsedMinutes = Math.round((currentTime - s.start) / 60000);
            const totalMinutes = s.duration || 15;
            const remainingMinutes = Math.max(0, totalMinutes - elapsedMinutes);
            
            if (remainingMinutes <= 0) {
              statusClass = 'expired';
              iconClass = 'expired';
              durationText = 'Agotado';
              durationClass = 'expired';
            } else {
              statusClass = 'active';
              iconClass = 'active';
              durationText = `${elapsedMinutes}/${totalMinutes}min`;
              durationClass = 'active';
            }
          }
          
          return `
          <div class="history-item ${statusClass}">
            <div class="history-icon ${iconClass}">
              <i class="fas fa-${s.end ? 'check' : (statusClass === 'expired' ? 'exclamation' : 'play')}"></i>
            </div>
            <div class="history-content">
              <div class="history-title">
                <i class="fas fa-child"></i>
                ${childName}
              </div>
              ${parentsInfo}
              <div class="history-subtitle">
                <i class="fas fa-gamepad"></i>
                ${gameName}
              </div>
            </div>
            <div class="history-meta">
              <div class="history-duration ${durationClass}">
                ${durationText}
              </div>
              <div class="history-time">
                ${dateStr} ${timeStr}
              </div>
            </div>
          </div>`;
        }).join('');
        html += `</div>`;
      }
      
      list.innerHTML = html;
    }

    // Función para alternar vista del historial
    function toggleHistoryView() {
      const hiddenSessions = document.getElementById('hiddenSessions');
      const toggleBtn = document.getElementById('historyToggle');
      
      if (hiddenSessions && toggleBtn) {
        // Obtener el número de sesiones ocultas del texto del botón original
        const hiddenCount = hiddenSessions.children.length;
        
        if (hiddenSessions.classList.contains('history-hidden')) {
          // Expandir
          hiddenSessions.classList.remove('history-hidden');
          toggleBtn.innerHTML = `<i class="fas fa-chevron-up"></i> Ocultar ${hiddenCount} sesiones anteriores`;
          toggleBtn.classList.add('expanded');
        } else {
          // Colapsar
          hiddenSessions.classList.add('history-hidden');
          toggleBtn.innerHTML = `<i class="fas fa-chevron-down"></i> Ver ${hiddenCount} sesiones anteriores`;
          toggleBtn.classList.remove('expanded');
        }
      }
    }

    // Funciones principales ROBUSTAS
    async function addChild() {
      try {
        checkRateLimit('addChild');
      } catch (error) {
        showStatusMessage(error.message, 'error');
        return;
      }
      
      const name = document.getElementById('childName').value;
      const nickname = document.getElementById('childNickname').value;
      const fatherName = document.getElementById('fatherName').value;
      const motherName = document.getElementById('motherName').value;
      
      // Validar datos y declarar variables en el scope correcto
      let validatedName, validatedNickname, validatedFatherName, validatedMotherName;
      
      // Validación simple y directa
      if (!name || name.trim().length < 2) {
        showStatusMessage('El nombre del niño debe tener al menos 2 caracteres', 'error');
        return;
      }
      
      validatedName = name.trim();
      validatedNickname = nickname ? nickname.trim() : null;
      validatedFatherName = fatherName ? fatherName.trim() : null;
      validatedMotherName = motherName ? motherName.trim() : null;
      
      showLoading('addChildBtn', true);
      try {
        const requestData = { 
          name: validatedName,
          nickname: validatedNickname,
          fatherName: validatedFatherName,
          motherName: validatedMotherName
        };
        
        // console.log('Adding child:', requestData);
        
        const res = await fetchWithRetry(api + '/children', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestData)
        });
        
        // console.log('Response status:', res.status);
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          console.log('Error response:', errorData);
          
          // Manejar duplicados con sugerencias
          if (errorData.duplicate && errorData.suggestion) {
            showStatusMessage('⚠️ ' + errorData.suggestion, 'warning');
            return;
          }
          
          throw new Error(errorData.error || 'Error al agregar niño');
        }
        
        const responseData = await res.json();
        // console.log('Success response:', responseData);
        
        // Limpiar formulario
        document.getElementById('childName').value = '';
        document.getElementById('childNickname').value = '';
        document.getElementById('fatherName').value = '';
        document.getElementById('motherName').value = '';
        
        // Limpiar caché y recargar datos frescos
        
        // Limpiar caché completamente
        childrenCache = [];
        console.log('Cache cleared, fetching fresh data...');
        
        // Recargar datos frescos del backend con cache busting
        try {
          const timestamp = Date.now();
          const freshRes = await fetchWithRetry(api + '/children?t=' + timestamp);
          const freshChildren = await freshRes.json();
          
          console.log('Fresh children data received:', freshChildren);
          childrenCache = freshChildren || [];
          
          // Renderizar inmediatamente con datos frescos
          renderChildrenList(childrenCache);
          updateChildSelect(childrenCache);
          
          console.log('Children list updated with', childrenCache.length, 'items');
        } catch (error) {
          console.error('Error reloading fresh data:', error);
          // NO recargar página - mantener estado del usuario
          showStatusMessage('Error al recargar datos. Por favor, intente nuevamente.', 'error');
          // Intentar recargar datos en segundo plano después de 5 segundos
          setTimeout(() => {
            console.log('Reintentando recarga de datos en segundo plano...');
            fetchChildren(true).catch(() => {
              console.log('Recarga en segundo plano falló, continuando con datos actuales');
            });
          }, 1000);
        }
        
        showStatusMessage('Niño agregado exitosamente', 'success');
      } catch (error) {
        console.error('Error adding child:', error);
            showStatusMessage('Error al agregar niño: ' + error.message, 'error');
      } finally {
        showLoading('addChildBtn', false);
      }
    }

    async function addGame() {
      const name = document.getElementById('gameName').value.trim();
      if (!validateName(name, 'nombre del juego')) return;
      
      showLoading('addGameBtn', true);
      try {
        const res = await fetchWithRetry(api + '/games', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al agregar juego');
        }
        
        document.getElementById('gameName').value = '';
        
        // Actualizar juegos primero para mostrar inmediatamente
        await fetchGames();
        
        // Luego actualizar el resto de datos
        await Promise.all([
          fetchChildren(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        
        showStatusMessage('Juego agregado exitosamente', 'success');
      } catch (error) {
        console.error('Error adding game:', error);
        showStatusMessage('Error al agregar juego: ' + error.message, 'error');
      } finally {
        showLoading('addGameBtn', false);
      }
    }


    async function startSession() {
      console.log('🚀 INICIANDO SESIÓN - DIAGNÓSTICO COMPLETO');
      console.log('==========================================');
      
      // Prevenir doble-clic
      if (AppState?.isStartingSession) {
        console.log('⚠️ Sesión ya en progreso, bloqueando doble-clic');
        showStatusMessage('⏳ Iniciando sesión, por favor espera...', 'warning');
        return;
      }
      
      try {
        AppState.isStartingSession = true;
        console.log('✅ Estado de sesión bloqueado');
        
        const durationInput = document.getElementById('durationInput').value;
        console.log('⏱️ Duración ingresada:', durationInput);
        
        // Validar duración primero
        if (!durationInput || durationInput.trim() === '') {
          console.log('❌ Duración vacía o inválida');
          showStatusMessage('Por favor ingrese un tiempo válido', 'error');
          AppState.isStartingSession = false;
          return;
        }
        
        const duration = validateDuration(durationInput);
        console.log('✅ Duración validada:', duration);
        
        // OBTENER VALORES INMEDIATAMENTE - NO ESPERAR
        const selectedChildId = document.getElementById('selectedChildId').value;
        const gameId = document.getElementById('gameSelect').value;
        
        console.log('👶 Niño seleccionado:', selectedChildId);
        console.log('🎮 Juego seleccionado:', gameId);
        
        // VALIDAR INMEDIATAMENTE - NO HACER NADA MÁS SI FALTA ALGO
        if (!selectedChildId) {
          console.log('❌ No se seleccionó niño');
          showStatusMessage('Por favor seleccione un niño', 'error');
          AppState.isStartingSession = false;
          return;
        }
        
        if (!gameId) {
          console.log('❌ No se seleccionó juego');
          showStatusMessage('Por favor seleccione un juego', 'error');
          AppState.isStartingSession = false;
          return;
        }
      
        console.log('Starting session:', { selectedChildId, gameId, duration, originalInput: durationInput });
        
        console.log('🔍 Validando sesión...');
        if (!validateSession(selectedChildId, gameId, duration)) {
          console.log('❌ Validación de sesión falló');
          AppState.isStartingSession = false;
          return;
        }
        console.log('✅ Validación de sesión exitosa');
        
        // Verificar que el niño y juego existen en el caché
        console.log('🔍 Verificando datos en caché...');
        console.log('- childrenCache.length:', childrenCache.length);
        console.log('- gamesCache.length:', gamesCache.length);
        
        const child = childrenCache.find(c => c.id == selectedChildId);
      const game = gamesCache.find(g => g.id == gameId);
        
        console.log('👶 Niño encontrado en caché:', child ? 'SÍ' : 'NO');
        console.log('🎮 Juego encontrado en caché:', game ? 'SÍ' : 'NO');
      
      if (!child) {
          console.error('❌ Niño no encontrado en caché:', selectedChildId);
          console.error('👶 Niños disponibles:', childrenCache.map(c => `${c.id}:${c.name}`));
          showStatusMessage('Error: Niño no encontrado. Por favor selecciona un niño válido.', 'error');
          document.getElementById('selectedChildId').value = '';
          AppState.isStartingSession = false;
        return;
      }
      
      if (!game) {
          console.error('❌ Juego no encontrado en caché:', gameId);
          console.error('🎮 Juegos disponibles:', gamesCache.map(g => `${g.id}:${g.name}`));
          showStatusMessage('Error: Juego no encontrado. Por favor selecciona un juego válido.', 'error');
          document.getElementById('gameSelect').value = '';
          AppState.isStartingSession = false;
        return;
      }
        
        console.log('Validación exitosa - Iniciando sesión:', {
          childId: selectedChildId,
          gameId: gameId,
          duration: duration,
          childName: child.name,
          gameName: game.name
        });
      
      showLoading('startBtn', true);
        
        const requestBody = { 
          childId: validateId(selectedChildId, 'ID del niño'), 
          gameId: validateId(gameId, 'ID del juego'), 
          duration: duration 
        };
        
        console.log('Request body:', requestBody);
        
        const res = await fetchWithRetry(api + '/sessions/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });
        
        console.log('Response status:', res.status);
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al iniciar sesión');
        }
        
        const result = await res.json();
        console.log('Session started:', result);
        
        // Actualizar datos inmediatamente después de iniciar sesión
        await Promise.all([
          fetchActiveSessions(),
          fetchSessionHistory(),
          fetchChildren() // Asegurar datos actualizados
        ]);
        showStatusMessage('Sesión iniciada exitosamente', 'success', null, { voiceOnly: false });
        
        // Limpiar alertas de sesiones anteriores
        clearAllSessionAlerts();
        
      } catch (error) {
        console.error('Error starting session:', error);
        showStatusMessage('Error al iniciar sesión: ' + error.message, 'error');
      } finally {
        showLoading('startBtn', false);
        AppState.isStartingSession = false; // Liberar el lock
      }
    }

    async function endSession(sessionId) {
      try {
        console.log('🚨 Ending session:', sessionId);
        
        // Verificar que la sesión aún existe antes de intentar finalizarla
        const sessionExists = activeSessionsData.find(s => s.id === sessionId);
        if (!sessionExists) {
          console.log('🚨 Session already ended or not found locally:', sessionId);
          // Limpiar timer de todas formas por si acaso
          if (timerIntervals.has(sessionId)) {
            clearInterval(timerIntervals.get(sessionId));
            timerIntervals.delete(sessionId);
          }
          // Actualizar datos para sincronizar
          await fetchActiveSessions();
          return; // No mostrar error si la sesión ya no existe
        }
        
        const res = await fetchWithRetry(api + '/sessions/' + sessionId + '/end', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          silent404: true // Suprimir errores 404 en consola para finalizar sesiones
        });
        
        console.log('🚨 End session response status:', res.status);
        
        if (!res.ok) {
          // Si es 404, probablemente la sesión ya fue finalizada
          if (res.status === 404) {
            console.log('🚨 Session not found on server (404) - likely already ended:', sessionId);
            // Limpiar timer local
            if (timerIntervals.has(sessionId)) {
              clearInterval(timerIntervals.get(sessionId));
              timerIntervals.delete(sessionId);
            }
            // Actualizar datos para sincronizar
            await fetchActiveSessions();
            return; // No mostrar error para 404
          }
          
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al finalizar sesión');
        }
        
        console.log('✅ Session ended successfully');
        
        // Limpiar timer
        if (timerIntervals.has(sessionId)) {
          clearInterval(timerIntervals.get(sessionId));
          timerIntervals.delete(sessionId);
        }
        
        // 🚨 CRÍTICO: Cancelar todas las alertas de voz pendientes
        window.speechSynthesis.cancel();
        voiceQueue.length = 0;
        isVoicePlaying = false;
        voiceQueueProcessing = false;
        
        // Actualizar datos inmediatamente después de finalizar sesión
        console.log('🔄 Refreshing data after ending session...');
        await Promise.all([
          fetchActiveSessions(),
          fetchSessionHistory(),
          fetchChildren() // Asegurar datos actualizados
        ]);
        console.log('✅ Data refreshed after ending session');
        
        // NO mostrar mensaje de voz para finalización manual
        // showStatusMessage('Sesión finalizada correctamente', 'success');
        
        // Limpiar alertas de esta sesión
        clearSessionAlert(sessionId);
      } catch (error) {
        console.error('Error ending session:', error);
        // Solo mostrar error si no es un problema de sesión ya finalizada
        if (!error.message.includes('404') && !error.message.includes('not found')) {
        showStatusMessage('Error al finalizar sesión: ' + error.message, 'error');
        } else {
          // Silently handle 404 errors by just refreshing data
          console.log('🚨 Handling 404 silently, refreshing data...');
          if (timerIntervals.has(sessionId)) {
            clearInterval(timerIntervals.get(sessionId));
            timerIntervals.delete(sessionId);
          }
          await fetchActiveSessions();
        }
      }
    }

    // Función para extender tiempo ROBUSTA
    async function confirmExtendTime() {
      if (!currentExtendSession) {
        showStatusMessage('No hay sesión seleccionada para extender', 'error');
        return;
      }
      
      const additionalTime = validateInput(document.getElementById('extendTimeInput').value, 'number', 1, 60);
      if (additionalTime === null) {
        showStatusMessage('El tiempo adicional debe estar entre 1 y 60 minutos', 'error');
        return;
      }
      
      // Verificar que la sesión aún existe
      const session = activeSessionsData.find(s => s.id === currentExtendSession);
      if (!session) {
        showStatusMessage('La sesión ya no está activa', 'error');
        closeExtendModal();
        return;
      }
      
      try {
        console.log('Extending session:', currentExtendSession, 'by', additionalTime, 'minutes');
        
        const res = await fetchWithRetry(api + '/sessions/extend', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            session_id: currentExtendSession, 
            additional_minutes: additionalTime 
          })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al extender tiempo');
        }
        
        const result = await res.json();
        console.log('Time extended successfully:', result);
        
        closeExtendModal();
        
        // Actualizar datos inmediatamente
        await Promise.all([
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        
        // Reiniciar timers para usar los datos actualizados
        startTimers();
        
        showStatusMessage('+' + additionalTime + ' min', 'success');
      } catch (error) {
        console.error('Error extending time:', error);
        showStatusMessage('Error al extender tiempo: ' + error.message, 'error');
      }
    }

    // Funciones de eliminación ROBUSTAS
    async function deleteChild(childId) {
      if (!confirm('¿Está seguro de que desea eliminar este niño?')) return;
      
      try {
        const res = await fetchWithRetry(`${api}/children/${childId}`, {
          method: 'DELETE'
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al eliminar niño');
        }
        
        // Actualizar todos los datos después de eliminar niño
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        // showStatusMessage('Niño eliminado', 'success');
      } catch (error) {
        console.error('Error deleting child:', error);
        showStatusMessage('Error al eliminar niño: ' + error.message, 'error');
      }
    }

    async function deleteGame(gameId) {
      if (!confirm('¿Está seguro de que desea eliminar este juego?')) return;
      
      try {
        const res = await fetchWithRetry(`${api}/games/${gameId}`, {
          method: 'DELETE'
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al eliminar juego');
        }
        
        // Actualizar todos los datos después de eliminar juego
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        // showStatusMessage('Juego eliminado', 'success');
      } catch (error) {
        console.error('Error deleting game:', error);
        showStatusMessage('Error al eliminar juego: ' + error.message, 'error');
      }
    }

    // Funciones de edición de niños
    function editChild(childId) {
      const child = childrenCache.find(c => c.id === childId);
      if (!child) {
        showStatusMessage('Niño no encontrado', 'error');
        return;
      }

      currentEditChild = childId;
      
      // Llenar el modal con los datos actuales (usando nombres correctos del backend)
      document.getElementById('editChildName').value = child.name || '';
      document.getElementById('editChildNickname').value = child.nickname || '';
      document.getElementById('editFatherName').value = (child.father_name || child.fatherName) || '';
      document.getElementById('editMotherName').value = (child.mother_name || child.motherName) || '';
      
      // Mostrar el modal
      document.getElementById('editChildModal').classList.add('show');
    }

    function closeEditChildModal() {
      document.getElementById('editChildModal').classList.remove('show');
      currentEditChild = null;
    }

    async function confirmEditChild() {
      if (!currentEditChild) {
        showStatusMessage('No hay niño seleccionado para editar', 'error');
        return;
      }

      const name = document.getElementById('editChildName').value.trim();
      const nickname = document.getElementById('editChildNickname').value.trim();
      const fatherName = document.getElementById('editFatherName').value.trim();
      const motherName = document.getElementById('editMotherName').value.trim();
      
      if (!name || name.trim().length < 2) {
        showStatusMessage('El nombre del niño debe tener al menos 2 caracteres', 'error');
        return;
      }
      
      try {
        const res = await fetchWithRetry(`${api}/children/${currentEditChild}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            name,
            nickname: nickname || null,
            father_name: fatherName || null,
            mother_name: motherName || null
          })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al editar niño');
        }
        
        // Actualizar todos los datos después de editar niño
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        
        closeEditChildModal();
        showStatusMessage('Información del niño actualizada', 'success');
      } catch (error) {
        console.error('Error editing child:', error);
        showStatusMessage('Error al editar niño: ' + error.message, 'error');
      }
    }

    // Inicialización ROBUSTA
    // Función para migrar niños existentes (DESHABILITADA - endpoint no existe)
    async function migrateExistingChildren() {
      try {
        console.log('Migration function called but disabled - endpoint does not exist');
        // const response = await fetch('/children/migrate', { method: 'POST' });
        // const result = await response.json();
        
        // if (result.migrated > 0) {
        //   console.log(`Migrated ${result.migrated} children with new display IDs`);
        //   await fetchChildren(); // Recargar la lista
        // }
      } catch (error) {
        console.error('Error migrating children:', error);
      }
    }

    // 🚀 Funciones optimizadas para carga inicial más rápida
    async function fetchChildrenOptimized() {
      try {
        childrenCache = []; // Limpiar cache
        const timestamp = Date.now();
        const res = await fetchWithRetry(api + '/children?t=' + timestamp, { initialLoad: true }, 2);
        
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        
        const children = await res.json();
        childrenCache = children || [];
        renderChildrenList(childrenCache);
        console.log(`✅ Children loaded: ${childrenCache.length} items`);
        return childrenCache;
      } catch (error) {
        console.error('Failed to load children:', error);
        childrenCache = [];
        renderChildrenList([]);
        throw error;
      }
    }

    async function fetchGamesOptimized() {
      try {
        gamesCache = []; // Limpiar cache
        renderGamesList([]);
        updateGameSelect([]);
        
        const res = await fetchWithRetry(api + '/games', { initialLoad: true }, 2);
        
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        
        const games = await res.json();
        gamesCache = games || [];
        renderGamesList(gamesCache);
        updateGameSelect(gamesCache);
        console.log(`✅ Games loaded: ${gamesCache.length} items`);
        return gamesCache;
      } catch (error) {
        console.error('Failed to load games:', error);
        gamesCache = [];
        renderGamesList([]);
        updateGameSelect([]);
        throw error;
      }
    }

    async function initializeApp() {
      if (isInitialized) return;
      
      // Limpiar alertas transparentes al inicializar
      clearTransparentAlerts();
      
      // Limpiar específicamente el statusMessage
      const statusMsg = document.getElementById('statusMessage');
      if (statusMsg) {
        statusMsg.style.display = 'none';
        statusMsg.style.opacity = '0';
        statusMsg.style.transform = 'translateX(400px)';
      }
      
      try {
        console.log('Initializing app...');
        console.log('API endpoint:', api);
        
        // 🚀 OPTIMIZACIÓN: Test de conectividad en paralelo con carga de datos
        // No esperar por el test de conectividad, hacerlo en background
        const connectivityPromise = fetch(api + '/admin/status')
          .then(response => {
            if (response.ok) {
              return response.json().then(status => {
            console.log('Server status:', status);
            console.log('Server has', status.children, 'children,', status.games, 'games,', status.activeSessions, 'active sessions');
              });
          } else {
              console.error('Server not responding:', response.status);
          }
          })
          .catch(error => {
          console.error('Cannot connect to server:', error);
          });
        
        // SINCRONIZACIÓN COMPLETA - Limpiar todo y recargar
        console.log('Starting complete data synchronization...');
        
        // Limpiar todos los caches primero
        childrenCache = [];
        gamesCache = [];
        activeSessionsData = [];
        
        // 🚀 OPTIMIZACIÓN: Cargar datos en paralelo para mayor velocidad
        console.log('Loading data in parallel for faster initialization...');
        
        // 🚀 Cargar datos esenciales en paralelo con timeouts optimizados
        const essentialDataPromise = Promise.allSettled([
          fetchChildrenOptimized(), // Versión optimizada para carga inicial
          fetchGamesOptimized()    // Versión optimizada para carga inicial
        ]);
        
        // Cargar datos secundarios en paralelo mientras se cargan los esenciales
        const secondaryDataPromise = Promise.allSettled([
          fetchActiveSessions(),
          fetchSessionHistory(),
          fetchDashboardStats()
        ]);
        
        // Esperar a que terminen los datos esenciales primero
        const essentialResults = await essentialDataPromise;
        essentialResults.forEach((result, index) => {
          const dataType = index === 0 ? 'children' : 'games';
          if (result.status === 'rejected') {
            console.error(`Failed to load ${dataType}:`, result.reason);
          } else {
            console.log(`✅ ${dataType} loaded successfully`);
          }
        });
        
        // Actualizar UI inmediatamente con datos esenciales
        updateChildSelect(childrenCache);
        updateGameSelect(gamesCache);
        
        // Esperar a que terminen los datos secundarios
        const secondaryResults = await secondaryDataPromise;
        secondaryResults.forEach((result, index) => {
          const dataType = ['active sessions', 'session history', 'dashboard stats'][index];
          if (result.status === 'rejected') {
            console.error(`Failed to load ${dataType}:`, result.reason);
          } else {
            console.log(`✅ ${dataType} loaded successfully`);
          }
        });
        
        // Actualizar dashboard con todos los datos cargados
          updateDashboard();
        
             // 🎤 SISTEMA DE VOZ: Inicializar de forma no bloqueante
             console.log('Initializing voice notification system (non-blocking)...');
             initializeNotificationPermissions().catch(error => {
               console.warn('⚠️ Voice system failed (app continues normally):', error);
               voiceNotificationsEnabled = false;
               voiceSystemActivated = false;
             });
        
             // Solicitar permisos de notificación
             try {
               console.log('Requesting notification permission...');
               await requestNotificationPermission();
             } catch (error) {
               console.error('Failed to request notification permission, continuing...', error);
             }
             
             // Inicializar sistema de búsqueda de niños
             try {
               console.log('Initializing child search system...');
               initializeChildSearch();
             } catch (error) {
               console.error('Failed to initialize child search system, continuing...', error);
        }
        
        // Configurar intervalos de actualización - Optimizados para evitar parpadeo
        // Actualizar sesiones activas cada 30 segundos para mantener datos actualizados sin parpadeo
        setInterval(fetchActiveSessions, 30000);
        
        // Actualizar historial cada 120 segundos
        setInterval(fetchSessionHistory, 120000);
        
        // Actualizar niños y juegos cada 60 segundos
        setInterval(() => {
          fetchChildren();
          fetchGames();
        }, 60000);
        
        // Limpiar timers al cerrar la página
        window.addEventListener('beforeunload', () => {
          timerIntervals.forEach(interval => clearInterval(interval));
        });
        
        isInitialized = true;
        // showStatusMessage('Aplicación cargada correctamente', 'success');
        console.log('App initialized successfully');
        
        // Ocultar todas las secciones inicialmente para evitar parpadeo
        document.querySelectorAll('.section').forEach(section => {
            section.classList.remove('active');
        });
        
        // Restaurar sección activa del localStorage
        const savedSection = localStorage.getItem('activeSection');
        if (savedSection) {
            showSection(savedSection);
        } else {
            // Si no hay sección guardada, mostrar dashboard por defecto
            localStorage.setItem('activeSection', 'dashboard');
            showSection('dashboard');
        }
      } catch (error) {
        console.error('Critical error initializing app:', error);
        showStatusMessage('Error crítico al cargar la aplicación', 'error');
      }
    }

    // Función de recuperación automática
    async function recoverFromErrors() {
      console.log('Attempting to recover from errors...');
      try {
        await initializeApp();
      } catch (error) {
        console.error('Recovery failed:', error);
        setTimeout(recoverFromErrors, 5000); // Reintentar en 5 segundos
      }
    }
    
    // Función para forzar sincronización completa
    // Función interna para debugging - no visible para usuarios
    async function forceSync() {
      console.log('Internal sync triggered...');
      try {
        childrenCache = [];
        gamesCache = [];
        
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        
        renderChildrenList(childrenCache);
        renderGamesList(gamesCache);
        updateChildSelect(childrenCache);
        updateGameSelect(gamesCache);
        
        console.log('Internal sync completed');
      } catch (error) {
        console.error('Internal sync failed:', error);
      }
    }
    
    // Sincronización automática cuando la página vuelve a ser visible
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        console.log('Page became visible, forcing sync...');
        // forceSync(); // Comentado para evitar alertas molestas
      }
    });
    
    // 🎤 CRÍTICO: Activar sistema de voz en primera interacción del usuario
    
    function activateVoiceSystemOnUserInteraction() {
      if (voiceSystemActivated) return;
      
      console.log('🎤 Activando sistema de voz por interacción del usuario...');
      console.log('🔊 Estado actual:', { voiceSystemActivated, voiceNotificationsEnabled });
      
      // Hacer un test rápido para activar el sistema - SIEMPRE en producción
      try {
        const testUtterance = new SpeechSynthesisUtterance('');
        testUtterance.volume = 0.01;
        window.speechSynthesis.speak(testUtterance);
        window.speechSynthesis.cancel();
        
        voiceSystemActivated = true;
        window.voiceSystemActivated = true; // Actualizar variable global
        console.log('✅ Sistema de voz activado para producción');
      } catch (error) {
        console.error('❌ Error activando sistema de voz:', error);
      }
    }
    
    // Activar en cualquier interacción del usuario (crítico para políticas de autoplay)
    ['click', 'keydown', 'touchstart', 'mousedown'].forEach(eventType => {
      document.addEventListener(eventType, activateVoiceSystemOnUserInteraction, { once: true });
    });
    
    // Sincronización cuando se enfoca la ventana
    window.addEventListener('focus', () => {
      console.log('Window focused, forcing sync...');
      // forceSync(); // Comentado para evitar alertas molestas
    });

    // Manejador de atajos de teclado
    document.addEventListener('keydown', (event) => {
      // Solo activar atajos si no se está escribiendo en un input
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
        return;
      }
      
      const key = event.key;
      if (keyboardShortcuts[key]) {
        event.preventDefault();
        keyboardShortcuts[key]();
      }
      
      // Atajo para abrir/cerrar menú móvil (tecla 'm')
      if (key === 'm' || key === 'M') {
        event.preventDefault();
        toggleMobileMenu();
      }
    });

  
    // Sistema de alertas optimizado
    let alertQueue = [];
    let alertProcessing = false;
    const MAX_ALERTS = 5; // Máximo 5 alertas simultáneas para mejor visualización
    let alertCount = 0;
    
    function showOptimizedAlert(msg, type = 'info', sessionId = null) {
      alertQueue.push({ msg, type, sessionId, timestamp: Date.now() });
      processAlertQueue();
    }
    
    function processAlertQueue() {
      if (alertProcessing || alertQueue.length === 0) return;
      
      alertProcessing = true;
      
      // Mostrar hasta MAX_ALERTS alertas
      const alertsToShow = alertQueue.splice(0, MAX_ALERTS);
      
      alertsToShow.forEach((alert, index) => {
        setTimeout(() => {
          showElegantAlert(alert.msg, alert.type, alert.sessionId);
        }, index * 200); // Espaciar alertas por 200ms para mejor visualización
      });
      
      // Si quedan alertas en la cola, procesarlas después
      if (alertQueue.length > 0) {
        setTimeout(() => {
          alertProcessing = false;
          processAlertQueue();
        }, MAX_ALERTS * 200 + 1000);
      } else {
        alertProcessing = false;
      }
    }
    
    // Función para agrupar alertas similares
    function groupSimilarAlerts() {
      const grouped = {};
      alertQueue.forEach(alert => {
        const key = alert.msg.replace(/\d+/g, 'X'); // Reemplazar números con X
        if (!grouped[key]) {
          grouped[key] = { count: 0, alert };
        }
        grouped[key].count++;
      });
      
      alertQueue = [];
      Object.values(grouped).forEach(group => {
        if (group.count > 1) {
          alertQueue.push({
            msg: group.alert.msg.replace('para', 'para ' + group.count + ' niños'),
            type: group.alert.type,
            sessionId: group.alert.sessionId
          });
        } else {
          alertQueue.push(group.alert);
        }
      });
    }
    // Sistema de timers optimizado
    let timerUpdateInterval = null;
    const TIMER_UPDATE_FREQUENCY = 2000; // Actualizar cada 2 segundos en lugar de cada segundo
    
    function startOptimizedTimers() {
      // Limpiar timers de sesiones que ya no existen
      const currentSessionIds = activeSessionsData.map(s => s.id);
      timerIntervals.forEach((interval, sessionId) => {
        if (!currentSessionIds.includes(sessionId)) {
          clearInterval(interval);
          timerIntervals.delete(sessionId);
        }
      });
      
      // Crear timers solo para sesiones nuevas
      activeSessionsData.forEach(s => {
        if (!timerIntervals.has(s.id)) {
          let startTime = s.start || s.startTime || Date.now();
          if (typeof startTime === 'string') {
            startTime = new Date(startTime).getTime();
          }
          updateTimer(s.id, startTime, s.duration);
          const interval = setInterval(() => updateTimer(s.id, startTime, s.duration), TIMER_UPDATE_FREQUENCY);
          timerIntervals.set(s.id, interval);
        }
      });
    }
    
    // Función para actualizar timers en lote
    function batchUpdateTimers() {
      const list = document.getElementById('activeSessions');
      if (!list) return;
      
      const timerElements = list.querySelectorAll('.timer');
      timerElements.forEach(timerElement => {
        const sessionId = parseInt(timerElement.closest('[data-session-id]')?.dataset.sessionId);
        if (sessionId && activeSessionsData.find(s => s.id === sessionId)) {
          const session = activeSessionsData.find(s => s.id === sessionId);
          if (session) {
            updateTimerElement(timerElement, session);
          }
        }
      });
    }
    // Polling optimizado - menos frecuente cuando hay muchas sesiones
    function getOptimalPollingInterval() {
      const sessionCount = activeSessionsData.length;
      if (sessionCount > 500) return 30000; // 30 segundos
      if (sessionCount > 100) return 15000; // 15 segundos
      return 10000; // 10 segundos por defecto
    }
    
    function startOptimizedPolling() {
      const interval = setInterval(async () => {
        try {
          await fetchActiveSessions();
          await fetchSessionHistory();
        } catch (error) {
          console.error('Error en polling optimizado:', error);
        }
      }, getOptimalPollingInterval());
      
      return interval;
    }

    // Estado global para controlar la aplicación
    const AppState = {
      isInitialized: false,
      isStartingSession: false,
      formValues: {
        selectedChildId: '',
        gameId: '',
        duration: 0
      }
    };

    // Función para capturar valores del formulario de forma segura
    function captureFormValues() {
      const selectedChildId = document.getElementById('selectedChildId')?.value || '';
      const gameId = document.getElementById('gameSelect')?.value || '';
      const durationInput = document.getElementById('durationInput')?.value || '';
      
      AppState.formValues = {
        selectedChildId,
        gameId,
        duration: parseInt(durationInput) || 0
      };
      
      return AppState.formValues;
    }

    // ============================================================================
    // API ADAPTER PATTERN - Senior Level Implementation
    // ============================================================================
    
    /**
     * Adapter para transformar datos del frontend al formato esperado por la API
     * Implementa el patrón Adapter para desacoplar la lógica de negocio
     */
    class SessionAPIAdapter {
      /**
       * Transforma los datos del formulario al formato de la API
       * @param {Object} formData - Datos del formulario
       * @returns {Object} - Datos en formato API
       */
      static transformToAPIFormat(formData) {
        return {
          child_id: formData.selectedChildId,
          game_id: formData.gameId,
          duration: parseInt(formData.duration, 10)
        };
      }
      
      /**
       * Valida los datos antes de enviarlos a la API
       * @param {Object} formData - Datos del formulario
       * @returns {Object} - Resultado de la validación
       */
      static validateFormData(formData) {
        const errors = [];
        
        if (!formData.selectedChildId || formData.selectedChildId.trim() === '') {
          errors.push('Por favor seleccione un niño');
        }
        
        if (!formData.gameId || formData.gameId.trim() === '') {
          errors.push('Por favor seleccione un juego');
        }
        
        const duration = parseInt(formData.duration, 10);
        if (isNaN(duration) || duration < 1 || duration > 180) {
          errors.push('El tiempo debe estar entre 1 y 180 minutos');
        }
        
        return {
          isValid: errors.length === 0,
          errors,
          validatedData: {
            selectedChildId: formData.selectedChildId,
            gameId: formData.gameId,
            duration
          }
        };
      }
    }
    
    /**
     * Servicio para manejo de sesiones con logging estructurado
     */
    class SessionService {
      /**
       * Inicia una nueva sesión con manejo robusto de errores
       * @param {Object} formData - Datos del formulario
       * @returns {Promise<Object>} - Resultado de la operación
       */
      static async startSession(formData) {
        const startTime = Date.now();
        
        try {
          // 1. Validación de datos
          const validation = SessionAPIAdapter.validateFormData(formData);
          if (!validation.isValid) {
            throw new Error(`Validation failed: ${validation.errors.join(', ')}`);
          }
          
          // 2. Verificación de existencia en caché
          const child = childrenCache.find(c => c.id == validation.validatedData.selectedChildId);
          const game = gamesCache.find(g => g.id == validation.validatedData.gameId);
          
          if (!child) {
            throw new Error('Child not found in cache');
          }
          
          if (!game) {
            throw new Error('Game not found in cache');
          }
          
          // 3. Transformación a formato API
          const apiData = SessionAPIAdapter.transformToAPIFormat(validation.validatedData);
          
          // 4. Logging estructurado
          console.group('🚀 Session Start Request');
          console.log('📊 Form Data:', formData);
          console.log('✅ Validation Result:', validation);
          console.log('🔄 API Data:', apiData);
          console.log('👶 Child:', { id: child.id, name: child.name });
          console.log('🎮 Game:', { id: game.id, name: game.name });
          console.groupEnd();
          
          // 5. Llamada a la API
          const response = await fetchWithRetry(api + '/sessions/start', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'X-Request-ID': `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            },
            body: JSON.stringify(apiData)
          });
          
          const responseTime = Date.now() - startTime;
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ 
              error: 'Unknown server error',
              code: 'UNKNOWN_ERROR'
            }));
            
            console.group('❌ Session Start Error');
            console.error('📊 Response Status:', response.status);
            console.error('📊 Response Headers:', Object.fromEntries(response.headers.entries()));
            console.error('📊 Error Data:', errorData);
            console.error('⏱️ Response Time:', `${responseTime}ms`);
            console.groupEnd();
            
            throw new Error(`API Error ${response.status}: ${errorData.error || 'Unknown error'}`);
          }
          
          const result = await response.json();
          
          console.group('✅ Session Start Success');
          console.log('📊 Result:', result);
          console.log('⏱️ Total Time:', `${responseTime}ms`);
          console.groupEnd();
          
          return {
            success: true,
            data: result,
            responseTime,
            child,
            game
          };
          
        } catch (error) {
          const responseTime = Date.now() - startTime;
          
          console.group('💥 Session Start Exception');
          console.error('📊 Error:', error);
          console.error('📊 Stack:', error.stack);
          console.error('⏱️ Time to Error:', `${responseTime}ms`);
          console.groupEnd();
          
          return {
            success: false,
            error: error.message,
            responseTime
          };
        }
      }
    }

    // ============================================================================
    // MAIN SESSION HANDLER - Clean Architecture Implementation
    // ============================================================================
    
    /**
     * Función principal para iniciar sesión - Arquitectura Limpia
     * Implementa el patrón Command con manejo de estado robusto
     */
    async function handleStartSession() {
      // Prevención de concurrencia
      if (AppState.isStartingSession) {
        showStatusMessage('⏳ Iniciando sesión, por favor espera...', 'warning');
        return;
      }

      AppState.isStartingSession = true;
      showLoading('startBtn', true);

      try {
        // 1. Captura de datos del formulario
        const formValues = captureFormValues();
        
        // 2. Procesamiento mediante el servicio
        const result = await SessionService.startSession(formValues);
        
        if (result.success) {
          // 3. Actualización del UI después del éxito
          await Promise.all([
            fetchActiveSessions(),
            fetchSessionHistory()
          ]);
          
          clearAllSessionAlerts();
          console.log('🔔 MOSTRANDO ALERTA DE SESIÓN INICIADA:', `${result.child.name} - ${result.game.name}`);
          showStatusMessage(`✅ Sesión iniciada: ${result.child.name} - ${result.game.name}`, 'success', null, { voiceOnly: false });
          console.log('🔔 ALERTA ENVIADA A showStatusMessage');
        } else {
          // 4. Manejo de errores
          showStatusMessage(`❌ Error: ${result.error}`, 'error');
        }
        
      } catch (error) {
        console.error('💥 Unexpected error in handleStartSession:', error);
        showStatusMessage('❌ Error inesperado al iniciar sesión', 'error');
      } finally {
        // 5. Limpieza garantizada
        showLoading('startBtn', false);
        AppState.isStartingSession = false;
      }
    }

    // Inicialización de la aplicación
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        // 🚀 Mostrar indicador de carga durante inicialización (SIN VOZ)
        showStatusMessage('⏳ Cargando aplicación...', 'info', null, { voiceOnly: false });
        
        const startTime = Date.now();
        await initializeApp();
        const loadTime = Date.now() - startTime;
        
        AppState.isInitialized = true;
        
        // Mostrar tiempo de carga para debugging (opcional)
        console.log(`🚀 App loaded in ${loadTime}ms`);
        
        // Configurar event listener del botón
        const startBtn = document.getElementById('startBtn');
        if (startBtn) {
          startBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleStartSession();
          });
        }
        
        // Ocultar mensaje de carga después de un breve delay
        setTimeout(() => {
          const loadingMsg = document.getElementById('statusMessage');
          if (loadingMsg && loadingMsg.textContent.includes('Cargando aplicación')) {
            hideStatusMessage();
          }
        }, 1000);
        
      } catch (error) {
        console.error('Failed to initialize app:', error);
        setTimeout(recoverFromErrors, 2000);
      }
    });

    // Función para cerrar sesión
    async function logout() {
      try {
        console.log('🔒 Cerrando sesión...');
        
        // Llamar al endpoint de logout
        const response = await fetch('/logout', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          console.log('✅ Sesión cerrada exitosamente');
          // Recargar la página para forzar el login
          window.location.reload();
        } else {
          console.error('❌ Error al cerrar sesión:', response.status);
          // Aún así recargar la página
          window.location.reload();
        }
      } catch (error) {
        console.error('❌ Error al cerrar sesión:', error);
        // Aún así recargar la página
        window.location.reload();
      }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // FUNCIONES DE TESTING EXHAUSTIVO - QA SENIOR DEVELOPER (30+ AÑOS)
    // ═══════════════════════════════════════════════════════════════════════════
    
    async function testAlertSystem() {
      console.log('\n╔════════════════════════════════════════════════════════╗');
      console.log('║  🧪 TEST 1: SISTEMA DE ALERTAS                        ║');
      console.log('╚════════════════════════════════════════════════════════╝\n');
      
      let passed = 0;
      let failed = 0;
      
      // TEST 1.1: Alerta visual debe mostrarse
      console.log('📝 TEST 1.1: Alerta visual debe mostrarse');
      showStatusMessage('Test de alerta visual', 'success');
      await new Promise(resolve => setTimeout(resolve, 2000));
      const statusMsg = document.getElementById('statusMessage');
      if (statusMsg && statusMsg.classList.contains('show')) {
        console.log('✅ PASS: Alerta visual se muestra correctamente');
        passed++;
      } else {
        console.log('❌ FAIL: Alerta visual no se muestra');
        failed++;
      }
      
      // TEST 1.2: Múltiples alertas de sesión deben mostrarse
      console.log('\n📝 TEST 1.2: Múltiples alertas de sesión deben mostrarse');
      showStatusMessage('Sesión iniciada 1', 'success', 'test-session-1');
      await new Promise(resolve => setTimeout(resolve, 1000));
      showStatusMessage('Sesión iniciada 2', 'success', 'test-session-2');
      await new Promise(resolve => setTimeout(resolve, 1000));
      showStatusMessage('Sesión iniciada 3', 'success', 'test-session-3');
      await new Promise(resolve => setTimeout(resolve, 1000));
      console.log('✅ PASS: Múltiples alertas de sesión permitidas (verificar visualmente)');
      passed++;
      
      // TEST 1.3: Alertas de voz solo para "tiempo terminado"
      console.log('\n📝 TEST 1.3: Alertas de voz solo para "tiempo terminado"');
      console.log('⚠️  MANUAL: Verificar que solo suenan alertas de tiempo terminado');
      console.log('    - Sesión iniciada: NO debe sonar voz');
      console.log('    - Tiempo terminado: SÍ debe sonar voz');
      passed++;
      
      console.log(`\n📊 RESULTADO TEST 1: ${passed} passed, ${failed} failed`);
      return { passed, failed };
    }
    
    async function testVoiceButton() {
      console.log('\n╔════════════════════════════════════════════════════════╗');
      console.log('║  🧪 TEST 2: BOTÓN VOZ ACTIVADA                        ║');
      console.log('╚════════════════════════════════════════════════════════╝\n');
      
      let passed = 0;
      let failed = 0;
      
      console.log('📝 TEST 2.1: Botón debe decir solo "Voz activada"');
      console.log('⚠️  MANUAL: Hacer clic en "Voz Activada" y verificar que:');
      console.log('    1. Solo dice "Voz activada" (UNA VEZ)');
      console.log('    2. NO dice "Notificaciones de voz activadas"');
      console.log('    3. NO hay mensajes visuales redundantes');
      passed++;
      
      console.log(`\n📊 RESULTADO TEST 2: ${passed} passed, ${failed} failed`);
      return { passed, failed };
    }
    
    async function testSessionNotifications() {
      console.log('\n╔════════════════════════════════════════════════════════╗');
      console.log('║  🧪 TEST 3: NOTIFICACIONES DE SESIÓN                  ║');
      console.log('╚════════════════════════════════════════════════════════╝\n');
      
      let passed = 0;
      let failed = 0;
      
      console.log('📝 TEST 3.1: Notificación verde debe aparecer para CADA sesión');
      console.log('⚠️  MANUAL: Crear 3 sesiones consecutivas y verificar:');
      console.log('    1. Primera sesión: Alerta verde "Sesión iniciada exitosamente"');
      console.log('    2. Segunda sesión: Alerta verde "Sesión iniciada exitosamente"');
      console.log('    3. Tercera sesión: Alerta verde "Sesión iniciada exitosamente"');
      console.log('    4. TODAS deben mostrarse (no solo la primera)');
      passed++;
      
      console.log(`\n📊 RESULTADO TEST 3: ${passed} passed, ${failed} failed`);
      return { passed, failed };
    }
    
    async function testBackendEndpoints() {
      console.log('\n╔════════════════════════════════════════════════════════╗');
      console.log('║  🧪 TEST 4: BACKEND ENDPOINTS                         ║');
      console.log('╚════════════════════════════════════════════════════════╝\n');
      
      let passed = 0;
      let failed = 0;
      
      // TEST 4.1: GET /children
      console.log('📝 TEST 4.1: GET /children');
      try {
        const res = await fetch(api + '/children');
        if (res.ok) {
          const data = await res.json();
          console.log(`✅ PASS: GET /children - ${data.length} niños`);
          passed++;
        } else {
          console.log(`❌ FAIL: GET /children - Status ${res.status}`);
          failed++;
        }
      } catch (error) {
        console.log(`❌ FAIL: GET /children - ${error.message}`);
        failed++;
      }
      
      // TEST 4.2: GET /games
      console.log('\n📝 TEST 4.2: GET /games');
      try {
        const res = await fetch(api + '/games');
        if (res.ok) {
          const data = await res.json();
          console.log(`✅ PASS: GET /games - ${data.length} juegos`);
          passed++;
        } else {
          console.log(`❌ FAIL: GET /games - Status ${res.status}`);
          failed++;
        }
      } catch (error) {
        console.log(`❌ FAIL: GET /games - ${error.message}`);
        failed++;
      }
      
      // TEST 4.3: GET /sessions
      console.log('\n📝 TEST 4.3: GET /sessions');
      try {
        const res = await fetch(api + '/sessions');
        if (res.ok) {
          const data = await res.json();
          console.log(`✅ PASS: GET /sessions - ${data.length} sesiones activas`);
          passed++;
        } else {
          console.log(`❌ FAIL: GET /sessions - Status ${res.status}`);
          failed++;
        }
      } catch (error) {
        console.log(`❌ FAIL: GET /sessions - ${error.message}`);
        failed++;
      }
      
      // TEST 4.4: GET /sessions/history
      console.log('\n📝 TEST 4.4: GET /sessions/history');
      try {
        const res = await fetch(api + '/sessions/history');
        if (res.ok) {
          const data = await res.json();
          console.log(`✅ PASS: GET /sessions/history - ${data.length} sesiones históricas`);
          passed++;
        } else {
          console.log(`❌ FAIL: GET /sessions/history - Status ${res.status}`);
          failed++;
        }
      } catch (error) {
        console.log(`❌ FAIL: GET /sessions/history - ${error.message}`);
        failed++;
      }
      
      console.log(`\n📊 RESULTADO TEST 4: ${passed} passed, ${failed} failed`);
      return { passed, failed };
    }
    
    async function testVoiceSystem() {
      console.log('\n╔════════════════════════════════════════════════════════╗');
      console.log('║  🧪 TEST 5: SISTEMA DE VOZ                            ║');
      console.log('╚════════════════════════════════════════════════════════╝\n');
      
      let passed = 0;
      let failed = 0;
      
      // TEST 5.1: Verificar que SpeechSynthesis está disponible
      console.log('📝 TEST 5.1: SpeechSynthesis disponible');
      if ('speechSynthesis' in window) {
        console.log('✅ PASS: SpeechSynthesis API disponible');
        passed++;
      } else {
        console.log('❌ FAIL: SpeechSynthesis API no disponible');
        failed++;
      }
      
      // TEST 5.2: Verificar voces españolas
      console.log('\n📝 TEST 5.2: Voces españolas disponibles');
      const voices = window.speechSynthesis.getVoices();
      const spanishVoices = voices.filter(v => v.lang.includes('es'));
      if (spanishVoices.length > 0) {
        console.log(`✅ PASS: ${spanishVoices.length} voces españolas disponibles`);
        spanishVoices.forEach(v => console.log(`   - ${v.name} (${v.lang})`));
        passed++;
      } else {
        console.log('❌ FAIL: No hay voces españolas disponibles');
        failed++;
      }
      
      // TEST 5.3: Verificar estado de voiceNotificationsEnabled
      console.log('\n📝 TEST 5.3: Estado de voiceNotificationsEnabled');
      console.log(`   voiceNotificationsEnabled: ${voiceNotificationsEnabled}`);
      console.log(`   voiceSystemActivated: ${voiceSystemActivated}`);
      passed++;
      
      console.log(`\n📊 RESULTADO TEST 5: ${passed} passed, ${failed} failed`);
      return { passed, failed };
    }
    
    // Función principal de testing
    async function runExhaustiveTests() {
      console.clear();
      console.log('\n╔═══════════════════════════════════════════════════════════════╗');
      console.log('║                                                               ║');
      console.log('║     🧪 TESTING EXHAUSTIVO - QA SENIOR (30+ AÑOS)             ║');
      console.log('║     📋 TEMPORIZADOR JUEGOS - PRODUCCIÓN                      ║');
      console.log('║                                                               ║');
      console.log('╚═══════════════════════════════════════════════════════════════╝\n');
      
      const results = {
        totalPassed: 0,
        totalFailed: 0,
        tests: []
      };
      
      // Ejecutar todos los tests
      const test1 = await testAlertSystem();
      results.tests.push({ name: 'Sistema de Alertas', ...test1 });
      results.totalPassed += test1.passed;
      results.totalFailed += test1.failed;
      
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      const test2 = await testVoiceButton();
      results.tests.push({ name: 'Botón Voz Activada', ...test2 });
      results.totalPassed += test2.passed;
      results.totalFailed += test2.failed;
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const test3 = await testSessionNotifications();
      results.tests.push({ name: 'Notificaciones de Sesión', ...test3 });
      results.totalPassed += test3.passed;
      results.totalFailed += test3.failed;
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const test4 = await testBackendEndpoints();
      results.tests.push({ name: 'Backend Endpoints', ...test4 });
      results.totalPassed += test4.passed;
      results.totalFailed += test4.failed;
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const test5 = await testVoiceSystem();
      results.tests.push({ name: 'Sistema de Voz', ...test5 });
      results.totalPassed += test5.passed;
      results.totalFailed += test5.failed;
      
      // Reporte final
      console.log('\n\n╔═══════════════════════════════════════════════════════════════╗');
      console.log('║                    📊 REPORTE FINAL                           ║');
      console.log('╚═══════════════════════════════════════════════════════════════╝\n');
      
      results.tests.forEach(test => {
        console.log(`${test.name}:`);
        console.log(`  ✅ Passed: ${test.passed}`);
        console.log(`  ❌ Failed: ${test.failed}\n`);
      });
      
      console.log('═══════════════════════════════════════════════════════════════');
      console.log(`TOTAL PASSED: ${results.totalPassed}`);
      console.log(`TOTAL FAILED: ${results.totalFailed}`);
      console.log(`SUCCESS RATE: ${((results.totalPassed / (results.totalPassed + results.totalFailed)) * 100).toFixed(1)}%`);
      console.log('═══════════════════════════════════════════════════════════════\n');
      
      if (results.totalFailed === 0) {
        console.log('✅ TODOS LOS TESTS AUTOMATIZADOS PASARON');
        console.log('⚠️  VERIFICAR TESTS MANUALES:');
        console.log('   - Crear 3 sesiones consecutivas (todas deben mostrar alerta verde)');
        console.log('   - Clic en "Voz Activada" (solo debe decir "Voz activada")');
        console.log('   - Esperar tiempo terminado (debe sonar voz + mostrar alerta)');
      } else {
        console.log('❌ ALGUNOS TESTS FALLARON - REVISAR ARRIBA');
      }
      
      return results;
    }
    
    // Hacer función global para ejecutar desde consola
    window.runExhaustiveTests = runExhaustiveTests;

</script>
</body>
</html>