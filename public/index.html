<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Temporizador de Juegos</title>
  <!-- Deployment trigger: v1.9 - FONT AWESOME UPDATE + FAVICON: Updated to 6.4.0 and added favicon -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>⏱️</text></svg>">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      color: #333;
      box-sizing: border-box;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 10px;
      box-sizing: border-box;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      color: white;
      position: relative;
      padding-left: 80px;
      padding-right: 20px;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    /* Navegación principal */
         .main-nav {
           display: flex;
           justify-content: flex-start;
           gap: 10px;
           margin-top: 20px;
           flex-wrap: wrap;
           margin-left: 20px;
         }

         /* Desktop Sidebar */
         .desktop-sidebar {
           display: none;
         }

         .main-content {
           width: 100%;
         }

         /* Desktop - mostrar sidebar y ocultar menú móvil */
         @media (min-width: 769px) {
           .desktop-sidebar {
             display: flex;
             flex-direction: column;
             position: fixed;
             left: 0;
             top: 0;
             width: 250px;
             height: 100vh;
             background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
             z-index: 100;
             box-shadow: 2px 0 10px rgba(0,0,0,0.3);
           }

           .sidebar-header {
             padding: 30px 20px 20px;
             border-bottom: 1px solid rgba(255,255,255,0.1);
           }

           .sidebar-header h2 {
      color: white;
             font-size: 1.5rem;
             font-weight: 600;
             text-align: center;
             margin: 0;
           }

           .desktop-nav {
             padding: 20px 0;
             flex: 1;
           }

           .desktop-nav-btn {
             display: flex;
             align-items: center;
             gap: 12px;
             width: 100%;
             padding: 15px 20px;
             background: none;
             border: none;
             color: rgba(255,255,255,0.9);
             font-size: 14px;
             font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
             text-align: left;
             border-left: 3px solid transparent;
           }

           .desktop-nav-btn:hover {
             background: rgba(255,255,255,0.15);
             color: white;
             transform: translateX(5px);
           }

           .desktop-nav-btn.active {
             background: rgba(255,255,255,0.2);
             color: white;
             border-left-color: white;
             font-weight: 600;
           }

           .desktop-nav-btn i {
             font-size: 16px;
             width: 20px;
           }

           .main-content {
             margin-left: 250px;
             width: calc(100% - 250px);
           }
           
        .mobile-menu-toggle {
          display: none !important;
        }
        
        /* Ocultar botón X en móvil */
        .close-button {
          display: none !important;
        }
           
           .header {
             padding-left: 20px !important;
             text-align: center !important;
           }
         }

         /* Menú lateral para móviles */
         .mobile-menu-toggle {
           display: none;
           background: transparent !important;
      color: white;
           border: none !important;
           padding: 8px;
      border-radius: 0;
      cursor: pointer;
      width: auto;
      height: auto;
           transition: all 0.3s ease;
           box-shadow: none !important;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
         .hamburger-lines {
           display: flex;
           flex-direction: column;
           gap: 3px;
           width: 18px;
         }

         .hamburger-lines span {
           width: 100%;
           height: 2px;
           background-color: white;
           border-radius: 1px;
           transition: all 0.3s ease;
         }

         .mobile-menu-toggle:hover {
           background: rgba(255, 255, 255, 0.1) !important;
           opacity: 0.8;
         }

         /* Asegurar que el botón no se vea afectado por otros estilos */
         .mobile-menu-toggle * {
           text-align: center !important;
           position: static !important;
         }

         /* Sobrescribir estilos globales de botones */
         .mobile-menu-toggle {
           width: auto !important;
           max-width: none !important;
           min-width: auto !important;
           flex: none !important;
           box-sizing: border-box !important;
         }

         .sidebar {
           position: fixed;
           top: 0;
           left: -300px;
           width: 280px;
           height: 100vh;
           background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
           padding: 80px 20px 20px;
           z-index: 1002;
           transition: left 0.3s ease;
           box-shadow: 2px 0 10px rgba(0,0,0,0.3);
         }

         .sidebar.open {
           left: 0;
         }

         .sidebar .nav-btn {
           width: 100%;
           margin-bottom: 10px;
           justify-content: flex-start;
           min-width: auto;
         }

         .sidebar-overlay {
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background: rgba(0, 0, 0, 0.5);
           z-index: 1000;
           opacity: 0;
           visibility: hidden;
           transition: all 0.3s ease;
         }

         .sidebar-overlay.active {
           opacity: 1;
           visibility: visible;
         }

         /* Sistema de búsqueda de niños */
         .child-search-container {
           position: relative;
         }

         .child-search-results {
           position: absolute;
           top: 100%;
           left: 0;
           right: 0;
           background: white;
           border: 1px solid #ddd;
           border-radius: 8px;
           max-height: 200px;
           overflow-y: auto;
      z-index: 100;
           display: none;
           box-shadow: 0 4px 12px rgba(0,0,0,0.15);
         }

         .child-search-results.show {
           display: block;
         }

         .child-search-item {
           padding: 12px 15px;
           cursor: pointer;
           border-bottom: 1px solid #f0f0f0;
           display: flex;
           align-items: center;
           gap: 10px;
           transition: background-color 0.2s ease;
         }

         .child-search-item:hover {
           background-color: #f8f9fa;
         }

         .child-search-item:last-child {
           border-bottom: none;
         }

         .child-search-item .child-avatar {
           width: 30px;
           height: 30px;
           border-radius: 50%;
           background: linear-gradient(135deg, #667eea, #764ba2);
           color: white;
      display: flex;
      align-items: center;
      justify-content: center;
           font-weight: bold;
           font-size: 14px;
         }

         .child-search-item .child-info {
           flex: 1;
         }

         .child-search-item .child-name {
           font-weight: 600;
           color: #333;
           margin-bottom: 2px;
         }

         .child-search-item .child-parents {
           font-size: 12px;
           color: #666;
         }

         .child-search-item .child-stats {
           font-size: 11px;
           color: #999;
           text-align: right;
         }

         .no-results {
           padding: 15px;
           text-align: center;
           color: #666;
           font-style: italic;
         }

    .nav-btn {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      padding: 12px 20px;
      border-radius: 25px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      min-width: 140px;
      justify-content: center;
    }

    .nav-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
      transform: translateY(-2px);
    }

    .nav-btn.active {
      background: rgba(255, 255, 255, 0.9);
      color: #667eea;
      border-color: white;
    }

    .shortcut-key {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 10px;
      font-weight: bold;
      margin-left: 8px;
      opacity: 0.8;
    }

    /* Secciones */
    .section {
      display: none;
    }

    .section.active {
      display: block;
    }

    /* Dashboard de estadísticas */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      transition: transform 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-5px);
    }

    .stat-number {
      font-size: 2.5rem;
      font-weight: bold;
      color: #667eea;
      margin-bottom: 10px;
    }

    .stat-label {
      color: #666;
      font-size: 1rem;
      margin-bottom: 5px;
    }

    .stat-description {
      color: #999;
      font-size: 0.9rem;
    }

    .chart-container {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }

    .chart-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: #333;
      margin-bottom: 15px;
      text-align: center;
    }

    .ranking-list {
      list-style: none;
      padding: 0;
    }

    .ranking-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      margin-bottom: 8px;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #667eea;
    }

    .ranking-item:nth-child(1) {
      border-left-color: #ffd700;
      background: linear-gradient(135deg, #fff9c4, #f8f9fa);
    }

    .ranking-item:nth-child(2) {
      border-left-color: #c0c0c0;
      background: linear-gradient(135deg, #f0f0f0, #f8f9fa);
    }

    .ranking-item:nth-child(3) {
      border-left-color: #cd7f32;
      background: linear-gradient(135deg, #ffe4b5, #f8f9fa);
    }

    .ranking-position {
      font-weight: bold;
      color: #667eea;
      font-size: 1.2rem;
      min-width: 30px;
    }

    .ranking-name {
      flex: 1;
      margin: 0 15px;
      font-weight: 500;
    }

    .ranking-time {
      color: #666;
      font-weight: 600;
    }
    
    /* Sync button removed for better UX - data syncs automatically */

    .header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    .dismiss-all-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      opacity: 0.8;
    }

    .dismiss-all-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
      opacity: 1;
      transform: translateY(-1px);
    }


    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(0,0,0,0.15);
    }

    .card h2 {
      color: #4a5568;
      margin-bottom: 20px;
      font-size: 1.3rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-row {
      display: flex;
      gap: 15px;
      align-items: end;
      flex-wrap: wrap;
    }

    .form-row .form-group {
      flex: 1;
      min-width: 120px;
    }

    .form-row .form-group:last-child {
      flex: 0 0 auto;
      min-width: 140px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #4a5568;
    }

    input, select, button {
      width: 100%;
      padding: 12px 15px;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      font-size: 14px;
      transition: all 0.3s ease;
      background: white;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: all 0.3s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    button:disabled {
      background: #cbd5e0;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-danger {
      background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
    }

    .btn-success {
      background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
    }

    .btn-warning {
      background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
    }

    .list {
      list-style: none;
      margin-top: 15px;
    }

    .list-item {
      background: #f7fafc;
      padding: 12px 15px;
      margin-bottom: 8px;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.3s ease;
      overflow: hidden;
      word-wrap: break-word;
      position: relative;
    }

    .list-item:hover {
      background: #edf2f7;
      transform: translateX(5px);
    }

    .list-item.active {
      border-left-color: #38a169;
      background: #f0fff4;
    }

    .session-info {
      flex: 1;
      min-width: 0;
      margin-right: 10px;
    }

    .session-controls {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      min-width: 0;
      flex-shrink: 0;
    }

    .button-group {
      display: flex;
      gap: 3px;
      margin-top: 5px;
      flex-wrap: nowrap;
    }
    
    /* Estilos para avatares y identificadores únicos */
    .child-info {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
    }
    
    .child-avatar {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 50%;
      font-weight: bold;
      font-size: 14px;
      flex-shrink: 0;
    }
    
    .child-avatar-small {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 50%;
      font-weight: bold;
      font-size: 10px;
      margin-right: 5px;
    }
    
    .child-details {
      flex: 1;
      min-width: 0;
    }
    
    .original-name {
      display: block;
      color: #666;
      font-size: 11px;
      margin-top: 2px;
      font-style: italic;
    }
    
    /* Estilos para formulario mejorado de niños */
    .child-form {
      margin-bottom: 20px;
    }
    
    .child-form label {
      display: block;
      margin-bottom: 5px;
      font-weight: 600;
      color: #333;
      font-size: 14px;
    }
    
    .child-form input {
      width: 100%;
      padding: 10px;
      border: 2px solid #e1e5e9;
      border-radius: 8px;
      font-size: 14px;
      transition: all 0.3s ease;
      box-sizing: border-box;
    }
    
    .child-form input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    .child-form input[required] {
      border-color: #667eea;
    }
    
    .child-form .form-row {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    .child-form .form-row .form-group {
      flex: 1;
    }
    
    .child-form {
      margin-bottom: 20px;
    }

    .child-form .form-row {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
    }

    .child-form .form-group {
      flex: 1;
      min-width: 0;
    }

    .child-form label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      color: #333;
      font-size: 14px;
    }

    .child-form input {
      width: 100%;
      padding: 10px;
      border: 2px solid #e1e5e9;
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.3s ease;
      box-sizing: border-box;
    }

    .child-form input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .child-form small {
      display: block;
      color: #666;
      font-size: 12px;
      margin-top: 5px;
      font-style: italic;
    }

    /* Safari iPhone specific fixes */
    @supports (-webkit-touch-callout: none) {
      .btn-small, .btn-edit {
        -webkit-appearance: none !important;
        appearance: none !important;
        -webkit-tap-highlight-color: transparent !important;
        touch-action: manipulation !important;
      }
      
      .list-item {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }
    }

    /* Responsive design for mobile */
    @media (max-width: 768px) {
      .child-form .form-row {
        flex-direction: column;
        gap: 10px;
      }
      
      .child-form .form-group {
        flex: none;
      }

      .child-info {
        flex-direction: column;
        align-items: flex-start !important;
        gap: 8px;
      }

      .child-details {
        width: 100% !important;
      }

      .list-item {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }

      .btn-small {
        align-self: flex-end;
        margin-top: 8px;
        padding: 14px 18px !important;
        font-size: 16px !important;
        min-width: 48px !important;
        min-height: 48px !important;
        touch-action: manipulation !important;
        -webkit-tap-highlight-color: transparent !important;
      }

      .btn-edit {
        padding: 14px 18px !important;
        font-size: 16px !important;
        min-width: 48px !important;
        min-height: 48px !important;
        touch-action: manipulation !important;
        -webkit-tap-highlight-color: transparent !important;
      }

      .delete-button-container {
        min-width: 120px;
        height: 48px;
        gap: 8px;
      }

      .button-group-small {
        gap: 8px;
      }

      .list-item {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      .child-info {
        margin-right: 0 !important;
      }

      .container {
        padding: 10px;
      }

      .card {
        margin-bottom: 15px;
      }

      h2 {
        font-size: 18px;
      }
    }

    /* Tablet responsive */
    @media (max-width: 1024px) and (min-width: 769px) {
      .grid {
        grid-template-columns: 1fr;
        gap: 20px;
      }
      
      .child-form .form-row {
        gap: 12px;
      }
    }
    
    /* Estilos para elementos de niños mejorados */
    .child-item {
      border-left: 4px solid #667eea;
      background: #f8f9ff;
      transition: all 0.3s ease;
    }

    .child-item:hover {
      background: #e8f2ff;
    }

    .child-name {
      font-size: 16px;
      font-weight: 600;
      color: #333;
      margin-bottom: 4px;
    }

    .nickname-text {
      color: #666;
      font-weight: 400;
      font-style: italic;
    }

    .child-time {
      color: #666;
      font-size: 14px;
    }

    .child-parents {
      color: #555;
      font-size: 12px;
      font-style: italic;
      margin: 2px 0;
      background: rgba(102, 126, 234, 0.05);
      padding: 2px 6px;
      border-radius: 4px;
      border-left: 2px solid #667eea;
    }

    .btn-small {
      padding: 12px 16px !important;
      font-size: 14px !important;
      min-width: 44px !important;
      min-height: 44px !important;
      border-radius: 8px !important;
      opacity: 0.9;
      transition: all 0.2s ease !important;
      width: auto !important;
      height: auto !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      touch-action: manipulation !important;
      -webkit-tap-highlight-color: transparent !important;
    }

    .btn-small:hover {
      opacity: 1;
      transform: none;
      background: #e53e3e !important;
    }

    .btn-small i {
      font-size: 14px !important;
    }

    .btn-edit {
      padding: 12px 16px !important;
      font-size: 14px !important;
      min-width: 44px !important;
      min-height: 44px !important;
      border-radius: 8px !important;
      opacity: 0.9;
      transition: all 0.2s ease !important;
      width: auto !important;
      height: auto !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
      color: white !important;
      border: none !important;
      margin-right: 8px !important;
      touch-action: manipulation !important;
      -webkit-tap-highlight-color: transparent !important;
    }

    .btn-edit:hover {
      opacity: 1;
      transform: none;
      background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%) !important;
    }

    .btn-edit i {
      font-size: 14px !important;
    }

    .delete-button-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      min-width: 60px;
      height: 32px;
    }

    .button-group-small {
      display: flex;
      gap: 5px;
      align-items: center;
    }

    .parents-info {
      color: #555;
      font-size: 11px;
      font-style: italic;
      background: rgba(102, 126, 234, 0.05);
      padding: 2px 6px;
      border-radius: 4px;
      border-left: 2px solid #667eea;
      margin: 2px 0;
      display: inline-block;
    }

    .history-parents {
      color: #555;
      font-size: 11px;
      font-style: italic;
      background: rgba(102, 126, 234, 0.05);
      padding: 2px 6px;
      border-radius: 4px;
      border-left: 2px solid #667eea;
      margin: 2px 0;
      display: block;
    }

    /* Historial compacto y responsive */
    .history-item {
      background: white;
      margin-bottom: 8px;
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 12px;
      align-items: center;
      transition: all 0.2s ease;
      border-left: 4px solid transparent;
    }

    .history-item:hover {
      transform: translateX(2px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }

    .history-item.active {
      border-left-color: #4CAF50;
      background: linear-gradient(135deg, #f8fff8, #ffffff);
    }

    .history-item.completed {
      border-left-color: #2196F3;
      opacity: 0.8;
    }

    .history-item.expired {
      border-left-color: #f44336;
      background: linear-gradient(135deg, #fff5f5, #ffffff);
    }

    .history-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      color: white;
    }

    .history-icon.active {
      background: linear-gradient(135deg, #4CAF50, #45a049);
    }

    .history-icon.completed {
      background: linear-gradient(135deg, #2196F3, #1976D2);
    }

    .history-icon.expired {
      background: linear-gradient(135deg, #f44336, #d32f2f);
    }

    .history-content {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .history-title {
      font-weight: 600;
      color: #333;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .history-subtitle {
      font-size: 12px;
      color: #666;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .history-meta {
      text-align: right;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 80px;
    }

    .history-duration {
      font-size: 12px;
      font-weight: 600;
      padding: 2px 6px;
      border-radius: 4px;
      color: white;
    }

    .history-duration.active {
      background: #4CAF50;
    }

    .history-duration.completed {
      background: #2196F3;
    }

    .history-duration.expired {
      background: #f44336;
    }

    .history-time {
      font-size: 11px;
      color: #999;
    }

    /* Botón para expandir/colapsar historial */
    .history-toggle {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      margin: 10px 0;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .history-toggle:hover {
      background: linear-gradient(135deg, #5a6fd8, #6a4190);
      transform: translateY(-1px);
    }

    .history-toggle i {
      transition: transform 0.3s ease;
    }

    .history-toggle.expanded i {
      transform: rotate(180deg);
    }

    .history-hidden {
      display: none;
    }

    .history-summary {
      background: #f8f9fa;
      border-radius: 6px;
      padding: 8px 12px;
      margin: 8px 0;
      font-size: 12px;
      color: #666;
      text-align: center;
      border: 1px solid #e9ecef;
    }

    /* Responsive design para historial */
    @media (max-width: 768px) {
      .history-item {
        grid-template-columns: auto 1fr;
        gap: 8px;
      }

      .history-meta {
        grid-column: 1 / -1;
        text-align: left;
        flex-direction: row;
        justify-content: space-between;
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #eee;
      }

      .history-content {
        grid-column: 2;
      }
    }

    @media (max-width: 480px) {
      .history-item {
        padding: 10px;
        margin-bottom: 6px;
      }

      .history-icon {
        width: 32px;
        height: 32px;
        font-size: 14px;
      }

      .history-title {
        font-size: 13px;
      }

      .history-subtitle {
        font-size: 11px;
      }

      .history-toggle {
        padding: 6px 12px;
        font-size: 11px;
      }
    }

    .timer {
      font-weight: bold;
      color: #38a169;
      font-family: 'Courier New', monospace;
      font-size: 1.1rem;
      line-height: 1.3;
      text-align: center;
      min-width: 120px;
    }

    .timer.warning {
      color: #f6ad55;
    }

    .timer.danger {
      color: #e53e3e;
      animation: pulse 1s infinite;
    }

    .timer strong {
      display: block;
      font-size: 1.2rem;
      margin-bottom: 2px;
    }

    .timer small {
      font-size: 0.9rem;
      opacity: 0.8;
      font-weight: normal;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .status-message {
      position: fixed;
      top: 80px;
      right: 20px;
      padding: 12px 16px;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      font-size: 14px;
      line-height: 1.4;
      z-index: 1000;
      transform: translateX(400px);
      transition: transform 0.3s ease;
      display: flex;
      align-items: flex-start;
      gap: 8px;
      max-width: 380px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      word-wrap: break-word;
      hyphens: auto;
    }

    .status-text {
      flex: 1;
      word-wrap: break-word;
    }

    .status-close {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      opacity: 0.8;
      transition: opacity 0.2s ease;
      flex-shrink: 0;
    }

    .status-close:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.1);
    }

    .status-message.show {
      transform: translateX(0);
    }

    .status-message.success {
      background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
    }

    .status-message.error {
      background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
    }

    .status-message.warning {
      background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(5px);
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      animation: modalSlideIn 0.3s ease;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: scale(0.8) translateY(-50px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .modal h2 {
      color: #4a5568;
      margin-bottom: 20px;
      font-size: 1.5rem;
    }

    .modal p {
      font-size: 1.1rem;
      margin-bottom: 30px;
      color: #666;
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .modal-buttons button {
      flex: 1;
      max-width: 120px;
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .extend-time {
      background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
      margin-left: 5px;
      padding: 5px 10px;
      font-size: 12px;
    }

    /* Responsive Design para navegación */
    @media (max-width: 768px) {
      .stats-grid {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }
      
      .stat-card {
        padding: 15px;
      }
      
      .stat-number {
        font-size: 2rem;
      }
      
      .chart-container {
        padding: 15px;
      }
    }

    @media (max-width: 480px) {
      .nav-btn {
        padding: 8px 12px;
        font-size: 12px;
      }
      
      .stats-grid {
        grid-template-columns: 1fr;
      }
      
      .ranking-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      
      .ranking-meta {
        display: flex;
        justify-content: space-between;
        width: 100%;
      }
    }

    /* Sistema de alertas mejorado */
    .alert-container {
      position: fixed;
      top: 80px;
      right: 20px;
      z-index: 10000;
      max-width: 380px;
      max-height: 60vh;
      overflow-y: auto;
      pointer-events: none;
    }
    
    .alert-container::-webkit-scrollbar {
      width: 4px;
    }
    
    .alert-container::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .alert-container::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
    }
    
    .persistent-alert {
      background: linear-gradient(135deg, #ff4757, #ff3742);
      color: white;
      border-radius: 8px;
      padding: 0;
      margin-bottom: 8px;
      box-shadow: 0 4px 20px rgba(255, 71, 87, 0.25);
      transform: translateX(0);
      opacity: 1;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: auto;
      border: none;
      backdrop-filter: blur(8px);
      overflow: hidden;
    }
    
    .persistent-alert:hover {
      transform: translateX(-4px);
      box-shadow: 0 6px 25px rgba(255, 71, 87, 0.35);
    }
    
    .alert-content {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      padding: 10px 14px;
      gap: 10px;
    }
    
    .alert-message {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
      line-height: 1.3;
      word-wrap: break-word;
      white-space: pre-line; /* Permitir saltos de línea */
      overflow-wrap: break-word;
      hyphens: auto;
    }
    
    .alert-close {
      background: rgba(255, 255, 255, 0.15);
      border: none;
      color: white;
      cursor: pointer;
      padding: 6px;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      flex-shrink: 0;
    }
    
    .alert-close:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: scale(1.1);
    }
    
    .alert-close i {
      font-size: 11px;
    }
    
    /* Animación de entrada mejorada */
    .persistent-alert {
      animation: slideInRight 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Indicador de nuevas alertas */
    .alert-indicator {
      position: fixed;
      top: 70px;
      right: 20px;
      background: #ff4757;
      color: white;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      z-index: 10001;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    /* Agrupación de alertas similares */
    .alert-group {
      background: linear-gradient(135deg, #ff6b6b, #ff5252);
      border-radius: 8px;
      margin-bottom: 8px;
      overflow: hidden;
    }
    
    .alert-group-header {
      background: rgba(255, 255, 255, 0.1);
      padding: 8px 16px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .alert-group-content {
      padding: 8px 16px;
    }
    
    .alert-group-item {
      font-size: 12px;
      margin-bottom: 4px;
      opacity: 0.9;
    }
    
    .alert-group-item:last-child {
      margin-bottom: 0;
    }
    
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* Optimizaciones específicas para desktop */
    @media (min-width: 769px) {
      .status-message {
        max-width: 400px;
        font-size: 14px;
        padding: 12px 18px;
      }
      
      .alert-container {
        max-width: 400px;
      }
      
      .alert-content {
        padding: 12px 16px;
      }
      
      .alert-message {
        font-size: 14px;
        line-height: 1.4;
        white-space: pre-line; /* Permitir saltos de línea */
      }
      
      /* Ocultar botón X en desktop también */
      .alert-close {
        display: none !important;
      }
      
      .status-close {
        display: none !important;
      }
    }

    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      
      .mobile-menu-toggle {
        display: block !important;
        position: fixed !important;
        top: 20px !important;
        left: 20px !important;
        z-index: 9999 !important;
        transform: none !important;
        transition: none !important;
      }
      
      /* Asegurar que el botón hamburguesa se mantenga fijo */
      .mobile-menu-toggle:hover {
        background: rgba(255, 255, 255, 0.2) !important;
        border-color: rgba(255, 255, 255, 0.5) !important;
      }
      
      .main-nav {
        display: none !important;
      }
      
      .header {
        padding-left: 20px !important;
        text-align: center !important;
      }
      
      .container {
        padding-left: 10px;
      }
      
      .header {
        padding-left: 20px !important;
        padding-right: 20px !important;
        text-align: center !important;
      }

      .header h1 {
        font-size: 1.5rem;
        margin-left: 0;
      }
      
      .header p {
        font-size: 0.9rem;
        margin-left: 0;
      }

      .grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .card {
        padding: 20px;
      }

      .form-row {
        flex-direction: column !important;
        gap: 10px;
        align-items: stretch !important;
      }

      .form-row .form-group {
        min-width: auto !important;
        max-width: none !important;
        flex: none !important;
        width: 100% !important;
      }

      .form-row .form-group:last-child {
        min-width: auto !important;
        max-width: none !important;
        flex: none !important;
        width: 100% !important;
      }

      input, select, button {
        width: 100% !important;
        max-width: none !important;
        font-size: 16px; /* Evita zoom en iOS */
      }
      
      /* Mejorar alertas en móviles */
      .alert-container {
        top: 70px;
        right: 10px;
        left: 10px;
        max-width: none;
        max-height: 50vh;
      }
      
      /* Ocultar botón X en alertas móviles */
      .alert-close {
        display: none !important;
      }
      
      /* Ocultar botón X en status message móvil */
      .status-close {
        display: none !important;
      }
      
      /* Ocultar botones en móvil */
      .dismiss-all-btn {
        display: none !important;
      }
      
      .persistent-alert {
        margin-bottom: 6px;
        border-radius: 6px;
      }
      
      .alert-content {
        padding: 10px 14px;
        gap: 10px;
      }
      
      .alert-message {
        font-size: 12px;
        line-height: 1.3;
        white-space: pre-line; /* Permitir saltos de línea */
      }
      
      .alert-close {
        width: 20px;
        height: 20px;
        padding: 4px;
      }
      
      .alert-close i {
        font-size: 10px;
      }
      
      /* Mejorar botones en móviles */
      .list-item .btn {
        padding: 8px 12px;
        font-size: 12px;
        margin: 2px;
      }

      .status-message {
        right: 10px;
        left: 10px;
        transform: translateY(-100px);
      }

      .status-message.show {
        transform: translateY(0);
      }
    }

    @media (max-width: 480px) {
      .header h1 {
        font-size: 1.8rem;
      }
      
      /* Sync button responsive rules removed */

      .card {
        padding: 15px;
      }

      .modal-content {
        padding: 30px 20px;
      }

      .form-row {
        flex-direction: column !important;
        gap: 8px;
      }

      .form-row .form-group {
        width: 100% !important;
        flex: none !important;
      }

      input, select, button {
        width: 100% !important;
        padding: 10px 12px;
        font-size: 14px;
      }
    }

    /* Reglas responsive para sesiones activas */
    @media (max-width: 768px) {
      .list-item.active {
        flex-direction: column;
        align-items: stretch;
      }
      
      .session-controls {
        align-items: center;
        margin-top: 10px;
      }
      
      .button-group {
        justify-content: center;
        width: 100%;
      }
    }

    @media (max-width: 480px) {
      .button-group button {
        padding: 6px 10px !important;
        font-size: 12px !important;
      }
    }

    /* Regla específica para pantallas muy pequeñas */
    @media (max-width: 360px) {
      .form-row {
        flex-direction: column !important;
        gap: 5px;
      }

      .form-row .form-group {
        width: 100% !important;
        margin-bottom: 10px;
      }

      input, select, button {
        width: 100% !important;
        padding: 8px 10px;
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
    <!-- Menú móvil - Posicionado fuera del flujo normal -->
    <div style="position: fixed; top: 20px; left: 20px; z-index: 9999;">
      <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">
        <div class="hamburger-lines">
          <span></span>
          <span></span>
          <span></span>
        </div>
      </button>
    </div>
    
    <div class="sidebar-overlay" onclick="closeMobileMenu()"></div>
    
    <div class="sidebar" id="sidebar">
      <button onclick="showSection('dashboard')" class="nav-btn" id="nav-dashboard">
        <i class="fas fa-chart-bar"></i> Dashboard <span class="shortcut-key">1</span>
      </button>
      <button onclick="showSection('sessions')" class="nav-btn" id="nav-sessions">
        <i class="fas fa-play-circle"></i> Sesiones <span class="shortcut-key">2</span>
      </button>
      <button onclick="showSection('children')" class="nav-btn" id="nav-children">
        <i class="fas fa-child"></i> Niños <span class="shortcut-key">3</span>
      </button>
      <button onclick="showSection('games')" class="nav-btn" id="nav-games">
        <i class="fas fa-gamepad"></i> Juegos <span class="shortcut-key">4</span>
      </button>
    </div>

  <!-- Desktop Sidebar -->
  <div class="desktop-sidebar">
    <div class="sidebar-header">
      <h2><i class="fas fa-gamepad"></i> Temporizador</h2>
    </div>
    <nav class="desktop-nav">
      <button onclick="showSection('dashboard')" class="desktop-nav-btn" id="nav-dashboard">
        <i class="fas fa-chart-bar"></i> Dashboard
      </button>
      <button onclick="showSection('sessions')" class="desktop-nav-btn" id="nav-sessions">
        <i class="fas fa-play-circle"></i> Sesiones
      </button>
      <button onclick="showSection('children')" class="desktop-nav-btn" id="nav-children">
        <i class="fas fa-child"></i> Niños
      </button>
      <button onclick="showSection('games')" class="desktop-nav-btn" id="nav-games">
        <i class="fas fa-gamepad"></i> Juegos
      </button>
    </nav>
  </div>

  <div class="main-content">
    <div class="header">
      <h1><i class="fas fa-gamepad"></i> Temporizador de Juegos</h1>
      <p>Controla el tiempo de juego de los niños de forma divertida</p>
      <button onclick="dismissAllAlerts()" class="dismiss-all-btn" title="Cerrar todas las alertas (Ctrl+Delete)">
        <i class="fas fa-times-circle"></i> Cerrar Alertas
      </button>
    </div>

    <!-- Dashboard Section -->
    <div id="dashboard-section" class="section">
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-number" id="totalChildren">0</div>
          <div class="stat-label">Niños Registrados</div>
          <div class="stat-description">Total de niños en el sistema</div>
          </div>
        <div class="stat-card">
          <div class="stat-number" id="totalGames">0</div>
          <div class="stat-label">Juegos Disponibles</div>
          <div class="stat-description">Juegos registrados</div>
          </div>
        <div class="stat-card">
          <div class="stat-number" id="activeSessionsCount">0</div>
          <div class="stat-label">Sesiones Activas</div>
          <div class="stat-description">Jugando ahora</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="totalTimePlayed">0</div>
          <div class="stat-label">Tiempo Total (min)</div>
          <div class="stat-description">Tiempo jugado acumulado</div>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">🏆 Ranking de Tiempo Jugado</div>
        <ul class="ranking-list" id="childrenRanking">
          <li class="ranking-item">No hay datos disponibles</li>
        </ul>
          </div>

      <div class="chart-container">
        <div class="chart-title">🎮 Juegos Más Populares</div>
        <ul class="ranking-list" id="gamesRanking">
          <li class="ranking-item">No hay datos disponibles</li>
        </ul>
          </div>
      </div>

    <!-- Sessions Section -->
    <div id="sessions-section" class="section">
      <div class="grid">
      <!-- Iniciar Sesión -->
      <div class="card">
        <h2><i class="fas fa-play-circle"></i> Iniciar Sesión de Juego</h2>
        <div class="form-group">
          <label><i class="fas fa-user"></i> Niño:</label>
                     <div class="child-search-container">
                       <input type="text" id="childSearchInput" placeholder="Buscar niño por nombre..." autocomplete="off">
                       <div class="child-search-results" id="childSearchResults"></div>
                       <input type="hidden" id="selectedChildId" value="">
                     </div>
        </div>
        <div class="form-group">
          <label><i class="fas fa-gamepad"></i> Juego:</label>
          <select id="gameSelect">
            <option value="">Seleccione un juego</option>
          </select>
        </div>
        <div class="form-group">
          <label><i class="fas fa-clock"></i> Tiempo (minutos):</label>
          <input type="number" id="durationInput" min="1" max="180" value="15">
        </div>
        <button id="startBtn" type="button">
          <i class="fas fa-play"></i> Iniciar Sesión
        </button>
      </div>

      <!-- Sesiones Activas -->
      <div class="card">
        <h2><i class="fas fa-stopwatch"></i> Sesiones Activas</h2>
        <ul class="list" id="activeSessions">
          <li class="list-item">Cargando sesiones activas...</li>
        </ul>
      </div>

      <!-- Historial -->
      <div class="card">
        <h2><i class="fas fa-history"></i> Historial de Sesiones</h2>
        <ul class="list" id="sessionHistory"></ul>
      </div>
    </div>
  </div>

    <!-- Children Section -->
    <div id="children-section" class="section">
      <div class="grid">
        <!-- Registrar Niño -->
        <div class="card">
          <h2><i class="fas fa-child"></i> Registrar Niño</h2>
            <div class="child-form">
              <div class="form-row">
                <div class="form-group">
                  <label for="childName">Nombre del niño</label>
                  <input type="text" id="childName" placeholder="Ej: Juan" maxlength="30" required>
                </div>
                <div class="form-group">
                  <label for="childNickname">Apodo (opcional)</label>
                  <input type="text" id="childNickname" placeholder="Ej: Juanito" maxlength="20">
                </div>
              </div>
              <div class="form-row">
                <div class="form-group">
                  <label for="fatherName">Nombre del padre (opcional)</label>
                  <input type="text" id="fatherName" placeholder="Ej: Carlos" maxlength="30">
                </div>
                <div class="form-group">
                  <label for="motherName">Nombre de la madre (opcional)</label>
                  <input type="text" id="motherName" placeholder="Ej: María" maxlength="30">
                </div>
              </div>
              <button onclick="addChild()" id="addChildBtn" class="btn-primary">
                <i class="fas fa-plus"></i> AGREGAR NIÑO
              </button>
            </div>
          <ul class="list" id="childrenList"></ul>
        </div>
      </div>
    </div>

    <!-- Games Section -->
    <div id="games-section" class="section">
      <div class="grid">
        <!-- Registrar Juego -->
        <div class="card">
          <h2><i class="fas fa-dice"></i> Registrar Juego</h2>
          <div class="form-row">
            <div class="form-group">
              <input type="text" id="gameName" placeholder="Nombre del juego" maxlength="50">
            </div>
            <div class="form-group">
              <button onclick="addGame()" id="addGameBtn">
                <i class="fas fa-plus"></i> Agregar Juego
              </button>
            </div>
          </div>
          <ul class="list" id="gamesList"></ul>
        </div>
      </div>
    </div>
  </div>
  </div> <!-- Cerrar main-content -->

  <!-- Status Message -->
  <div id="statusMessage" class="status-message">
    <span class="status-text"></span>
    <button class="status-close" onclick="hideStatusMessage()" title="Cerrar">
      <i class="fas fa-times"></i>
    </button>
  </div>

  <!-- Modal -->
  <div id="customModal" class="modal">
    <div class="modal-content">
      <h2 id="modalTitle"><i class="fas fa-bell"></i> ¡Tiempo terminado!</h2>
      <p id="modalMsg"></p>
      <button onclick="closeModal()" class="btn-success">
        <i class="fas fa-check"></i> Entendido
      </button>
    </div>
  </div>

  <!-- Modal de Extensión de Tiempo -->
  <div id="extendModal" class="modal">
    <div class="modal-content">
      <h2><i class="fas fa-clock"></i> Extender Tiempo</h2>
      <p id="extendMsg"></p>
      <div class="form-group">
        <label>Tiempo adicional (minutos):</label>
        <input type="number" id="extendTimeInput" min="1" max="60" value="5">
      </div>
      <div class="modal-buttons">
        <button onclick="confirmExtendTime()" class="btn-success">
          <i class="fas fa-plus"></i> Extender
        </button>
        <button onclick="closeExtendModal()" class="btn-danger">
          <i class="fas fa-times"></i> Cancelar
        </button>
      </div>
    </div>
  </div>

  <!-- Modal de Edición de Niño -->
  <div id="editChildModal" class="modal">
    <div class="modal-content">
      <h2><i class="fas fa-edit"></i> Editar Información del Niño</h2>
      <div class="form-group">
        <label for="editChildName">Nombre del niño:</label>
        <input type="text" id="editChildName" placeholder="Ej: Juan" maxlength="30" required>
      </div>
      <div class="form-group">
        <label for="editChildNickname">Apodo (opcional):</label>
        <input type="text" id="editChildNickname" placeholder="Ej: Juanito" maxlength="20">
      </div>
      <div class="form-group">
        <label for="editFatherName">Nombre del padre (opcional):</label>
        <input type="text" id="editFatherName" placeholder="Ej: Carlos" maxlength="30">
      </div>
      <div class="form-group">
        <label for="editMotherName">Nombre de la madre (opcional):</label>
        <input type="text" id="editMotherName" placeholder="Ej: María" maxlength="30">
      </div>
      <div class="modal-buttons">
        <button onclick="confirmEditChild()" class="btn-success">
          <i class="fas fa-save"></i> Guardar Cambios
        </button>
        <button onclick="closeEditChildModal()" class="btn-danger">
          <i class="fas fa-times"></i> Cancelar
        </button>
      </div>
    </div>
  </div>

  <script>
    // Configuración de API - detectar entorno
    const api = window.location.origin;
    console.log('API URL:', api);
    console.log('Environment:', window.location.hostname);

    // Variables para el dashboard
    let dashboardStats = null;
    
    // Variables para notificaciones
    let notificationPermission = null;
    
    // Variables para atajos de teclado
    let keyboardShortcuts = {
      '1': () => showSection('dashboard'),
      '2': () => showSection('sessions'),
      '3': () => showSection('children'),
      '4': () => showSection('games'),
      'Escape': () => closeModal() || closeExtendModal() || closeEditChildModal(),
      'Delete': () => dismissAllAlerts() // Ctrl+Delete para cerrar todas las alertas
    };

    // Funciones de notificaciones push
    async function requestNotificationPermission() {
      if (!('Notification' in window)) {
        console.log('Este navegador no soporta notificaciones');
        return false;
      }
      
      if (Notification.permission === 'granted') {
        return true;
      }
      
      if (Notification.permission === 'denied') {
        console.log('Notificaciones denegadas por el usuario');
        return false;
      }
      
      const permission = await Notification.requestPermission();
      notificationPermission = permission === 'granted';
      return notificationPermission;
    }

    function showBrowserNotification(title, message, icon = null) {
      if (notificationPermission && 'Notification' in window) {
        const notification = new Notification(title, {
          body: message,
          icon: icon || '/favicon.ico',
          tag: 'temporizador-juegos',
          requireInteraction: true
        });
        
        // Auto-cerrar después de 10 segundos
        setTimeout(() => {
          notification.close();
        }, 10000);
        
        // Cerrar al hacer click
        notification.onclick = () => {
          window.focus();
          notification.close();
        };
      }
    }

    // Funciones de navegación
    function showSection(sectionName) {
      // Ocultar todas las secciones
      document.querySelectorAll('.section').forEach(section => {
        section.classList.remove('active');
      });
      
      // Desactivar todos los botones de navegación
      document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Mostrar la sección seleccionada
      const section = document.getElementById(sectionName + '-section');
      if (section) {
        section.classList.add('active');
      }
      
      // Activar el botón correspondiente (tanto desktop como móvil)
      const desktopNavBtn = document.getElementById('nav-' + sectionName);
      const mobileNavBtn = document.querySelector('.sidebar .nav-btn[id="nav-' + sectionName + '"]');
      
      // Desactivar todos los botones primero
      document.querySelectorAll('.desktop-nav-btn, .nav-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Activar el botón correspondiente
      if (desktopNavBtn) {
        desktopNavBtn.classList.add('active');
      }
      if (mobileNavBtn) {
        mobileNavBtn.classList.add('active');
      }
      
      // Actualizar dashboard si es necesario
      if (sectionName === 'dashboard') {
        updateDashboard();
      }
      
      // Cerrar menú móvil al navegar
      closeMobileMenu();
      
      // Limpiar alertas persistentes al cambiar de sección
      clearAllPersistentAlerts();
      
      // Guardar sección activa en localStorage
      localStorage.setItem('activeSection', sectionName);
    }

    // Funciones del menú móvil
    function toggleMobileMenu() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.querySelector('.sidebar-overlay');
      
      sidebar.classList.toggle('open');
      overlay.classList.toggle('active');
    }

    function closeMobileMenu() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.querySelector('.sidebar-overlay');
      
      sidebar.classList.remove('open');
      overlay.classList.remove('active');
    }

    // Sistema de búsqueda de niños
    function initializeChildSearch() {
      const searchInput = document.getElementById('childSearchInput');
      const searchResults = document.getElementById('childSearchResults');
      const selectedChildId = document.getElementById('selectedChildId');

      if (!searchInput) return;

      let searchTimeout;

      searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim().toLowerCase();

        if (query.length < 2) {
          hideSearchResults();
          return;
        }

        searchTimeout = setTimeout(() => {
          searchChildren(query);
        }, 300);
      });

      searchInput.addEventListener('focus', () => {
        if (searchInput.value.trim().length >= 2) {
          searchChildren(searchInput.value.trim().toLowerCase());
        }
      });

      // Cerrar resultados al hacer clic fuera
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.child-search-container')) {
          hideSearchResults();
        }
      });
    }

    function searchChildren(query) {
      const results = childrenCache.filter(child => {
        const name = (child.displayName || child.name).toLowerCase();
        const fatherName = (child.fatherName || '').toLowerCase();
        const motherName = (child.motherName || '').toLowerCase();
        
        return name.includes(query) || 
               fatherName.includes(query) || 
               motherName.includes(query);
      });

      displaySearchResults(results);
    }

    function displaySearchResults(results) {
      const searchResults = document.getElementById('childSearchResults');
      const searchInput = document.getElementById('childSearchInput');

      if (!searchResults || !searchInput) return;

      if (results.length === 0) {
        searchResults.innerHTML = '<div class="no-results">No se encontraron niños</div>';
      } else {
        searchResults.innerHTML = results.map(child => {
          const displayName = child.displayName || child.name;
          const avatar = child.avatar || child.name.charAt(0).toUpperCase();
          
          let parentsInfo = '';
          if (child.fatherName && child.motherName) {
            parentsInfo = `${child.fatherName} & ${child.motherName}`;
          } else if (child.fatherName) {
            parentsInfo = `Papá: ${child.fatherName}`;
          } else if (child.motherName) {
            parentsInfo = `Mamá: ${child.motherName}`;
          }

          return `
            <div class="child-search-item" onclick="selectChild(${child.id}, '${displayName.replace(/'/g, "\\'")}')">
              <div class="child-avatar">${avatar}</div>
              <div class="child-info">
                <div class="child-name">${displayName}</div>
                ${parentsInfo ? `<div class="child-parents">${parentsInfo}</div>` : ''}
              </div>
              <div class="child-stats">${child.totalTimePlayed} min</div>
            </div>
          `;
        }).join('');
      }

      searchResults.classList.add('show');
    }

    function selectChild(childId, childName) {
      const searchInput = document.getElementById('childSearchInput');
      const selectedChildId = document.getElementById('selectedChildId');
      const searchResults = document.getElementById('childSearchResults');

      if (searchInput) {
        searchInput.value = childName;
      }
      if (selectedChildId) {
        selectedChildId.value = childId;
      }

      hideSearchResults();
    }

    function hideSearchResults() {
      const searchResults = document.getElementById('childSearchResults');
      if (searchResults) {
        searchResults.classList.remove('show');
      }
    }

    // Funciones del dashboard
    async function fetchDashboardStats() {
      try {
        const res = await fetchWithRetry(api + '/admin/status');
        if (res.ok) {
          dashboardStats = await res.json();
          return dashboardStats;
        }
      } catch (error) {
        console.error('Error fetching dashboard stats:', error);
      }
      return null;
    }

    function updateDashboard() {
      // Actualizar dashboard con datos del caché local
      renderDashboard();
    }

    function renderDashboard() {
      // Usar datos del caché local para mostrar información real
      const totalChildren = childrenCache.length;
      const totalGames = gamesCache.length;
      const activeSessions = activeSessionsData.length;
      
      // Calcular tiempo total jugado desde el caché - CON DEBUGGING
      let totalTimePlayed = 0;
      console.group('📊 Dashboard Stats Calculation');
      console.log('📊 Children Cache:', childrenCache);
      
      childrenCache.forEach((child, index) => {
        const childTime = child.totalTimePlayed || 0;
        totalTimePlayed += childTime;
        console.log(`👶 Child ${index + 1}:`, {
          name: child.name,
          totalTimePlayed: childTime,
          hasTimeData: !!child.totalTimePlayed
        });
      });
      
      console.log('📊 Total Time Played:', totalTimePlayed);
      console.groupEnd();

      // Actualizar estadísticas principales
      document.getElementById('totalChildren').textContent = totalChildren;
      document.getElementById('totalGames').textContent = totalGames;
      document.getElementById('activeSessionsCount').textContent = activeSessions;
      document.getElementById('totalTimePlayed').textContent = totalTimePlayed;

      // Actualizar ranking de niños basado en tiempo jugado - VERSIÓN MEJORADA
      const childrenRanking = document.getElementById('childrenRanking');
      const sortedChildren = [...childrenCache].sort((a, b) => (b.totalTimePlayed || 0) - (a.totalTimePlayed || 0));
      
      if (sortedChildren.length > 0) {
        childrenRanking.innerHTML = sortedChildren.slice(0, 5).map((child, index) => {
          // Información de padres para diferenciación en el ranking
          let parentsInfo = '';
          if (child.fatherName || child.motherName) {
            if (child.fatherName && child.motherName) {
              parentsInfo = `<br><small style="color: #666; font-size: 11px;">${child.fatherName} & ${child.motherName}</small>`;
            } else if (child.fatherName) {
              parentsInfo = `<br><small style="color: #666; font-size: 11px;">Papá: ${child.fatherName}</small>`;
            } else if (child.motherName) {
              parentsInfo = `<br><small style="color: #666; font-size: 11px;">Mamá: ${child.motherName}</small>`;
            }
          }
          
          return `
            <li class="ranking-item">
              <div class="ranking-position">${index + 1}°</div>
              <div class="ranking-name">
                ${child.displayName || child.name}${parentsInfo}
              </div>
              <div class="ranking-time">${child.totalTimePlayed || 0} min</div>
            </li>
          `;
        }).join('');
      } else {
        childrenRanking.innerHTML = '<li class="ranking-item">No hay datos disponibles</li>';
      }

      // Actualizar ranking de juegos (por ahora mostrar todos los juegos)
      const gamesRanking = document.getElementById('gamesRanking');
      if (gamesCache.length > 0) {
        gamesRanking.innerHTML = gamesCache.slice(0, 5).map((game, index) => `
          <li class="ranking-item">
            <div class="ranking-position">${index + 1}°</div>
            <div class="ranking-name">${game.name}</div>
            <div class="ranking-time">-</div>
          </li>
        `).join('');
      } else {
        gamesRanking.innerHTML = '<li class="ranking-item">No hay datos disponibles</li>';
      }
    }

    // Estado de la aplicación - ROBUSTO
    let isLoading = false;
    let activeSessionsData = [];
    let childrenCache = [];
    let gamesCache = [];
    let timerIntervals = new Map();
    let currentExtendSession = null;
    let currentEditChild = null; // Para almacenar el ID del niño que se está editando

    // ============================================================================
    // FUNCIONES DE SEGURIDAD CRÍTICAS PARA PRODUCCIÓN
    // ============================================================================
    
    // Sanitización HTML para prevenir XSS
    function sanitizeHTML(str) {
      if (typeof str !== 'string') return '';
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
    
    // Validación robusta de entrada
    function validateInput(input, type, min = null, max = null) {
      if (typeof input !== 'string') return null;
      
      const trimmed = input.trim();
      if (trimmed.length === 0) return null;
      
      switch (type) {
        case 'name':
          // Solo letras, espacios, números y caracteres básicos
          if (!/^[a-zA-ZáéíóúÁÉÍÓÚñÑ\s\d\-\.]+$/.test(trimmed)) return null;
          if (trimmed.length < 1 || trimmed.length > 50) return null;
          break;
        case 'number':
          const num = parseInt(trimmed);
          if (isNaN(num)) return null;
          if (min !== null && num < min) return null;
          if (max !== null && num > max) return null;
          return num;
        case 'id':
          const id = parseInt(trimmed);
          if (isNaN(id) || id <= 0) return null;
          return id;
        default:
          return trimmed;
      }
      
      return trimmed;
    }
    
    // Validación específica para duración
    function validateDuration(input) {
      const duration = validateInput(input, 'number', 1, 1440); // 1 min a 24 horas
      if (duration === null) {
        throw new Error('Duración inválida. Debe ser un número entre 1 y 1440 minutos.');
      }
      return duration;
    }
    
    // Validación específica para IDs
    function validateId(input, fieldName) {
      const id = validateInput(input, 'id');
      if (id === null) {
        throw new Error(`${fieldName} inválido. Debe ser un número positivo.`);
      }
      return id;
    }
    
    // Validación específica para nombres
    function validateName(input, fieldName) {
      const name = validateInput(input, 'name');
      if (name === null) {
        throw new Error(`${fieldName} inválido. Solo se permiten letras, números y espacios.`);
      }
      return name;
    }
    
    // Circuit Breaker para APIs
    class CircuitBreaker {
      constructor(threshold = 5, timeout = 60000) {
        this.failures = 0;
        this.threshold = threshold;
        this.timeout = timeout;
        this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
        this.nextAttempt = Date.now();
      }
      
      async execute(fn) {
        if (this.state === 'OPEN') {
          if (Date.now() < this.nextAttempt) {
            throw new Error('Circuit breaker is OPEN. Servicio temporalmente no disponible.');
          }
          this.state = 'HALF_OPEN';
        }
        
        try {
          const result = await fn();
          this.onSuccess();
          return result;
        } catch (error) {
          this.onFailure();
          throw error;
        }
      }
      
      onSuccess() {
        this.failures = 0;
        this.state = 'CLOSED';
      }
      
      onFailure() {
        this.failures++;
        if (this.failures >= this.threshold) {
          this.state = 'OPEN';
          this.nextAttempt = Date.now() + this.timeout;
        }
      }
    }
    
    // Circuit breakers por endpoint
    const circuitBreakers = {
      children: new CircuitBreaker(3, 30000),
      games: new CircuitBreaker(3, 30000),
      sessions: new CircuitBreaker(3, 30000)
    };
    
    // Rate Limiting para operaciones del usuario
    class RateLimiter {
      constructor(maxRequests = 10, windowMs = 60000) {
        this.maxRequests = maxRequests;
        this.windowMs = windowMs;
        this.requests = [];
      }
      
      canMakeRequest() {
        const now = Date.now();
        // Limpiar requests antiguos
        this.requests = this.requests.filter(time => now - time < this.windowMs);
        
        if (this.requests.length >= this.maxRequests) {
          return false;
        }
        
        this.requests.push(now);
        return true;
      }
      
      getTimeUntilReset() {
        if (this.requests.length === 0) return 0;
        const oldestRequest = Math.min(...this.requests);
        return Math.max(0, this.windowMs - (Date.now() - oldestRequest));
      }
    }
    
    const rateLimiter = new RateLimiter(15, 60000); // 15 requests por minuto
    
    // Función para verificar rate limit antes de operaciones
    function checkRateLimit(operation) {
      if (!rateLimiter.canMakeRequest()) {
        const timeLeft = Math.ceil(rateLimiter.getTimeUntilReset() / 1000);
        throw new Error(`Demasiadas solicitudes. Espere ${timeLeft} segundos antes de intentar nuevamente.`);
      }
    }
    let isInitialized = false;
    let isFirstLoad = true;
    let alertedSessions = new Set(); // Para evitar alertas duplicadas
    let pendingTimeAlerts = new Map(); // Para consolidar alertas de tiempo terminado
    let timeAlertTimeout = null; // Para agrupar alertas cercanas en tiempo

    // Utilidades mejoradas
    function showStatusMessage(text, type = 'success', sessionId = null) {
      const msg = document.getElementById('statusMessage');
      
      // Si es una alerta de sesión, verificar si ya se mostró
      if (sessionId && alertedSessions.has(sessionId)) {
        return; // No mostrar alerta duplicada
      }
      
      // Reproducir sonido según el tipo
      if (type === 'warning' || type === 'danger') {
        playNotificationSound(type);
      }
      
      // Limpiar cualquier timeout anterior
      if (msg.timeoutId) {
        clearTimeout(msg.timeoutId);
      }
      
      // Usar el span para el texto
      const textSpan = msg.querySelector('.status-text');
      if (textSpan) {
        textSpan.textContent = text;
      } else {
        msg.textContent = text; // Fallback para compatibilidad
      }
      msg.className = `status-message ${type} show`;
      
      // Marcar sesión como alertada si es una alerta de sesión
      if (sessionId) {
        alertedSessions.add(sessionId);
      }
      
      // Auto-ocultar después de tiempo apropiado según el tipo
      let timeoutDuration;
      if (type === 'error') {
        timeoutDuration = 6000; // Errores más tiempo para leer
      } else if (type === 'warning') {
        // Alertas de warning con texto largo (nombres + padres) necesitan más tiempo
        timeoutDuration = text.length > 50 ? 8000 : 6000; // Más tiempo para texto largo
      } else {
        timeoutDuration = text.length < 10 ? 2000 : 4000; // Éxito menos tiempo
      }
      
      msg.timeoutId = setTimeout(() => {
        // Ocultar mensaje con transición suave
        msg.classList.remove('show');
        msg.timeoutId = null;
        
        // Limpiar contenido después de la transición
        setTimeout(() => {
          const textSpan = msg.querySelector('.status-text');
          if (textSpan) {
            textSpan.textContent = '';
          } else {
            msg.textContent = '';
          }
          msg.className = 'status-message';
        }, 300); // Esperar a que termine la transición CSS
        
        // Limpiar alerta de sesión después de mostrar
        if (sessionId) {
          setTimeout(() => {
            alertedSessions.delete(sessionId);
          }, 1000);
        }
      }, timeoutDuration);
    }

    // Función para ocultar manualmente el mensaje de estado
    function hideStatusMessage() {
      const msg = document.getElementById('statusMessage');
      
      // Limpiar timeout si existe
      if (msg.timeoutId) {
        clearTimeout(msg.timeoutId);
        msg.timeoutId = null;
      }
      
      // Ocultar con transición suave
      msg.classList.remove('show');
      
      // Limpiar contenido después de la transición
      setTimeout(() => {
        const textSpan = msg.querySelector('.status-text');
        if (textSpan) {
          textSpan.textContent = '';
        } else {
          msg.textContent = '';
        }
        msg.className = 'status-message';
      }, 300); // Esperar a que termine la transición CSS
    }

    function showLoading(buttonId, show = true) {
      const button = document.getElementById(buttonId);
      if (!button) return;
      
      if (show) {
        button.disabled = true;
        button.innerHTML = '<div class="loading"></div> Procesando...';
      } else {
        button.disabled = false;
        // Restaurar texto original basado en el botón
        if (buttonId === 'addChildBtn') {
          button.innerHTML = '<i class="fas fa-plus"></i> Agregar Niño';
        } else if (buttonId === 'addGameBtn') {
          button.innerHTML = '<i class="fas fa-plus"></i> Agregar Juego';
        } else if (buttonId === 'startBtn') {
          button.innerHTML = '<i class="fas fa-play"></i> Iniciar Sesión';
        }
      }
    }

    // Función para limpiar todas las alertas de sesiones
    function clearAllSessionAlerts() {
      alertedSessions.clear();
      pendingTimeAlerts.clear();
      if (timeAlertTimeout) {
        clearTimeout(timeAlertTimeout);
        timeAlertTimeout = null;
      }
      const msg = document.getElementById('statusMessage');
      if (msg) {
        if (msg.timeoutId) {
          clearTimeout(msg.timeoutId);
          msg.timeoutId = null;
        }
        msg.classList.remove('show');
        msg.textContent = '';
        msg.className = 'status-message';
      }
    }

    // Función para cerrar manualmente todas las alertas (para casos críticos)
    function dismissAllAlerts() {
      clearAllSessionAlerts();
      showStatusMessage('✅ Todas las alertas cerradas', 'success');
    }

    // Función inteligente para determinar si mostrar información de padres
    function shouldShowParentsInfo(context, children) {
      switch(context) {
        case 'search':
        case 'list':
        case 'history':
          return true; // Siempre mostrar en estos contextos
          
        case 'alert':
          // En alertas, solo si hay nombres duplicados
          const nameCount = {};
          children.forEach(child => {
            nameCount[child.name] = (nameCount[child.name] || 0) + 1;
          });
          return Object.values(nameCount).some(count => count > 1);
          
        case 'ranking':
          // En ranking, solo si hay duplicados
          const rankingNames = {};
          children.forEach(child => {
            rankingNames[child.name] = (rankingNames[child.name] || 0) + 1;
          });
          return Object.values(rankingNames).some(count => count > 1);
          
        default:
          return false;
      }
    }



    // Función para limpiar alerta específica de sesión
    function clearSessionAlert(sessionId) {
      alertedSessions.delete(sessionId);
      const msg = document.getElementById('statusMessage');
      if (msg && msg.textContent.includes('quedan solo') && msg.textContent.includes('segundos')) {
        if (msg.timeoutId) {
          clearTimeout(msg.timeoutId);
          msg.timeoutId = null;
        }
        msg.classList.remove('show');
        msg.textContent = '';
        msg.className = 'status-message';
      }
    }

    // Función para consolidar alertas de tiempo terminado
    function showConsolidatedTimeAlert(childName, parentsInfo) {
      // Crear clave única usando nombre + padres para evitar duplicados
      const uniqueKey = `${childName}|${parentsInfo || 'sin_padres'}`;
      
      // Agregar a la lista de alertas pendientes
      pendingTimeAlerts.set(uniqueKey, { name: childName, parents: parentsInfo });
      
      // Limpiar timeout anterior si existe
      if (timeAlertTimeout) {
        clearTimeout(timeAlertTimeout);
      }
      
      // Esperar 2 segundos para agrupar alertas cercanas
      timeAlertTimeout = setTimeout(() => {
        const alertCount = pendingTimeAlerts.size;
        let alertText;
        
        if (alertCount === 1) {
          // Una sola alerta - mostrar individualmente
          const { name, parents } = pendingTimeAlerts.values().next().value;
          alertText = `⏰ ${name}${parents ? ` (${parents})` : ''} terminó su tiempo de juego`;
        } else if (alertCount === 2) {
          // Dos alertas - mostrar ambas individualmente
          const childrenList = Array.from(pendingTimeAlerts.values()).map(child => {
            return child.parents ? `${child.name} (${child.parents})` : child.name;
          });
          alertText = `⏰ Tiempo terminado para:\n${childrenList.join('\n')}`;
        } else if (alertCount <= 5) {
          // 3-5 alertas: mostrar lista consolidada
          const childrenList = Array.from(pendingTimeAlerts.values()).map(child => {
            return child.parents ? `${child.name} (${child.parents})` : child.name;
          });
          alertText = `⏰ Tiempo terminado para:\n${childrenList.join('\n')}`;
        } else {
          // Más de 5: mostrar contador + algunos nombres
          const childrenList = Array.from(pendingTimeAlerts.values()).slice(0, 3).map(child => {
            return child.parents ? `${child.name} (${child.parents})` : child.name;
          });
          const remaining = alertCount - 3;
          alertText = `⏰ Tiempo terminado para ${alertCount} niños:\n${childrenList.join('\n')}\n+ ${remaining} más (ver historial)`;
        }
        
        // Mostrar alerta consolidada
        showStatusMessage(alertText, 'warning');
        
        // Limpiar lista de alertas pendientes
        pendingTimeAlerts.clear();
        timeAlertTimeout = null;
      }, 2000);
    }

    // Sistema de notificaciones con sonido
    function playNotificationSound(type = 'default') {
      try {
        // Crear audio context para sonidos
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        let frequency = 800;
        let duration = 0.2;
        
        switch(type) {
          case 'warning':
            frequency = 600;
            duration = 0.3;
            break;
          case 'danger':
            frequency = 400;
            duration = 0.5;
            break;
          case 'success':
            frequency = 1000;
            duration = 0.2;
            break;
        }
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
      } catch (error) {
        console.log('Could not play notification sound:', error);
      }
    }

    // Sistema de alertas mejorado
    function showCustomModal(msg) {
      // Reproducir sonido de notificación
      playNotificationSound('danger');
      
      // Mostrar notificación del navegador
      showBrowserNotification('⏰ Tiempo Terminado', msg);
      
      // Crear alerta persistente en la esquina
      const alertContainer = document.getElementById('alertContainer') || createAlertContainer();
      
      const alertId = 'alert-' + Date.now();
      const alert = document.createElement('div');
      alert.id = alertId;
      alert.className = 'persistent-alert';
      alert.innerHTML = `
        <div class="alert-content">
          <span class="alert-message">${msg}</span>
          <button class="alert-close" onclick="closeAlert('${alertId}')">
            <i class="fas fa-times"></i>
          </button>
        </div>
      `;
      
      alertContainer.appendChild(alert);
      
      // Auto-remover después de 10 segundos si no se cierra manualmente
      setTimeout(() => {
        if (document.getElementById(alertId)) {
          closeAlert(alertId);
        }
      }, 10000);
    }
    
    function createAlertContainer() {
      const container = document.createElement('div');
      container.id = 'alertContainer';
      container.className = 'alert-container';
      document.body.appendChild(container);
      return container;
    }
    
    function closeAlert(alertId) {
      const alert = document.getElementById(alertId);
      if (alert) {
        alert.style.opacity = '0';
        alert.style.transform = 'translateX(100%)';
        alert.style.transition = 'all 0.3s ease';
        setTimeout(() => {
          if (alert.parentNode) {
          alert.remove();
            updateAlertIndicator();
          }
        }, 300);
      }
    }
    
    // Función para actualizar el indicador de alertas
    function updateAlertIndicator() {
      let indicator = document.getElementById('alertIndicator');
      const container = document.getElementById('alertContainer') || createAlertContainer();
      const activeAlerts = container.children.length;
      
      if (activeAlerts > 0 && !indicator) {
        indicator = document.createElement('div');
        indicator.id = 'alertIndicator';
        indicator.className = 'alert-indicator';
        indicator.textContent = activeAlerts > 9 ? '9+' : activeAlerts;
        document.body.appendChild(indicator);
      } else if (indicator && activeAlerts === 0) {
        indicator.remove();
      } else if (indicator) {
        indicator.textContent = activeAlerts > 9 ? '9+' : activeAlerts;
      }
    }
    
    // Función para mostrar alertas elegantes
    function showElegantAlert(msg, type = 'info', sessionId = null) {
      const container = document.getElementById('alertContainer') || createAlertContainer();
      const alertId = `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      const alertElement = document.createElement('div');
      alertElement.className = 'persistent-alert';
      alertElement.id = alertId;
      
      // Truncar mensaje si es muy largo
      const truncatedMsg = msg.length > 60 ? msg.substring(0, 57) + '...' : msg;
      
      alertElement.innerHTML = `
        <div class="alert-content">
          <div class="alert-message">${truncatedMsg}</div>
          <button class="alert-close" onclick="closeAlert('${alertId}')">
            <i class="fas fa-times"></i>
          </button>
        </div>
      `;
      
      container.appendChild(alertElement);
      
      // Auto-cerrar después de 8 segundos
      setTimeout(() => {
        closeAlert(alertId);
      }, 8000);
      
      // Actualizar indicador de alertas
      updateAlertIndicator();
    }

    // Función para limpiar todas las alertas persistentes
    function clearAllPersistentAlerts() {
      const alertContainer = document.getElementById('alertContainer');
      if (alertContainer) {
        alertContainer.innerHTML = '';
      }
      // También limpiar cualquier alerta que pueda estar fuera del contenedor
      document.querySelectorAll('.persistent-alert').forEach(alert => {
        alert.remove();
      });
    }

    function closeModal() {
      document.getElementById('customModal').classList.remove('show');
    }

    function showExtendModal(sessionId, childName) {
      currentExtendSession = sessionId;
      
      // Buscar información del niño para mostrar padres si existen
      const session = activeSessionsData.find(s => s.id === sessionId);
      const child = session ? childrenCache.find(c => c.id === session.childId) : null;
      
      let displayMessage = `¿Cuánto tiempo adicional quiere darle a ${childName}?`;
      if (child && (child.fatherName || child.motherName)) {
        let parentsText = '';
        if (child.fatherName && child.motherName) {
          parentsText = ` (${child.fatherName} & ${child.motherName})`;
        } else if (child.fatherName) {
          parentsText = ` (Papá: ${child.fatherName})`;
        } else if (child.motherName) {
          parentsText = ` (Mamá: ${child.motherName})`;
        }
        displayMessage = `¿Cuánto tiempo adicional quiere darle a ${childName}${parentsText}?`;
      }
      
      document.getElementById('extendMsg').textContent = displayMessage;
      document.getElementById('extendTimeInput').value = 5;
      document.getElementById('extendModal').classList.add('show');
    }

    function closeExtendModal() {
      document.getElementById('extendModal').classList.remove('show');
      currentExtendSession = null;
    }

    // Validaciones ROBUSTAS
    function validateName(name, type) {
      if (!name || name.trim().length === 0) {
        showStatusMessage(`Por favor ingrese el ${type}`, 'error');
        return false;
      }
      if (name.trim().length < 2) {
        showStatusMessage(`El ${type} debe tener al menos 2 caracteres`, 'error');
        return false;
      }
      if (name.trim().length > 50) {
        showStatusMessage(`El ${type} no puede tener más de 50 caracteres`, 'error');
        return false;
      }
      return true;
    }

    function validateSession(childId, gameId, duration) {
      // Solo validar duración aquí, los otros valores ya se validaron arriba
      if (isNaN(duration)) {
        showStatusMessage('El tiempo debe ser un número válido', 'error');
        return false;
      }
      if (duration < 1) {
        showStatusMessage('El tiempo mínimo es 1 minuto', 'error');
        return false;
      }
      if (duration > 180) {
        showStatusMessage('El tiempo máximo es 180 minutos', 'error');
        return false;
      }
      return true;
    }

    // Funciones de fetch ROBUSTAS con reintentos
    async function fetchWithRetry(url, options = {}, retries = 3) {
      const timeoutMs = 10000; // 10 segundos timeout
      
      for (let i = 0; i < retries; i++) {
        try {
          // Crear AbortController para timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
          
          const fetchOptions = {
            ...options,
            signal: controller.signal
          };
          
          const res = await fetch(url, fetchOptions);
          clearTimeout(timeoutId);
          
          if (res.ok) {
            return res;
          }
          
          // Manejo especial para rate limiting (429)
          if (res.status === 429) {
            const retryAfter = res.headers.get('retry-after') || '60';
            const waitTime = parseInt(retryAfter) * 1000;
            console.warn(`Rate limited, esperando ${retryAfter} segundos...`);
            await new Promise(resolve => setTimeout(resolve, waitTime));
            continue; // Reintentar sin contar como fallo
          }
          
          if (i === retries - 1) {
            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          }
        } catch (error) {
          if (error.name === 'AbortError') {
            throw new Error(`Timeout: La solicitud tardó más de ${timeoutMs/1000} segundos`);
          }
          
          if (i === retries - 1) {
            throw error;
          }
          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
      }
    }

    async function fetchChildren(forceRefresh = false) {
      try {
        // Limpiar caché si es refresh forzado
        if (forceRefresh) {
          childrenCache = [];
        }
        
        const timestamp = Date.now();
        const res = await fetchWithRetry(api + '/children?t=' + timestamp);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        // Validar que la respuesta sea JSON válido
        let children;
        try {
          const text = await res.text();
          if (!text || text.trim() === '') {
            throw new Error('Respuesta vacía del servidor');
          }
          children = JSON.parse(text);
        } catch (parseError) {
          console.error('Error parsing JSON:', parseError);
          throw new Error('Respuesta inválida del servidor');
        }
        
        // Verificar que los datos son válidos
        if (!Array.isArray(children)) {
          console.error('Invalid children data format:', children);
          throw new Error('Invalid children data format');
        }
        
        childrenCache = children || [];
        
        // Renderizar inmediatamente
        renderChildrenList(childrenCache);
        updateChildSelect(childrenCache);
        
        return childrenCache;
      } catch (error) {
        console.error('Error fetching children:', error);
        showStatusMessage('Error al cargar la lista de niños', 'error');
        childrenCache = [];
        renderChildrenList([]);
        updateChildSelect([]);
        throw error; // Re-throw para que initializeApp pueda manejarlo
      }
    }


    async function fetchGames() {
      try {
        console.log('Fetching games from:', api + '/games');
        
        // LIMPIAR CACHÉ ANTES DE FETCH
        gamesCache = [];
        renderGamesList([]);
        updateGameSelect([]);
        
        const res = await fetchWithRetry(api + '/games');
        console.log('Games response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        // Validar que la respuesta sea JSON válido
        let games;
        try {
          const text = await res.text();
          if (!text || text.trim() === '') {
            throw new Error('Respuesta vacía del servidor');
          }
          games = JSON.parse(text);
        } catch (parseError) {
          console.error('Error parsing games JSON:', parseError);
          throw new Error('Respuesta inválida del servidor');
        }
        
        console.log('Games data received:', games, 'Length:', games ? games.length : 0);
        
        // VALIDAR Y ASIGNAR DATOS
        gamesCache = Array.isArray(games) ? games : [];
        
        // RENDERIZAR INMEDIATAMENTE
        renderGamesList(gamesCache);
        updateGameSelect(gamesCache);
        
        console.log('Games loaded successfully - Cache length:', gamesCache.length, 'Cache content:', gamesCache.map(g => `${g.id}:${g.name}`));
      } catch (error) {
        console.error('Error fetching games:', error);
        showStatusMessage('Error al cargar la lista de juegos', 'error');
        gamesCache = [];
        renderGamesList([]);
        updateGameSelect([]);
        throw error; // Re-throw para que initializeApp pueda manejarlo
      }
    }

    function renderChildrenList(children) {
      const list = document.getElementById('childrenList');
      console.log('renderChildrenList called with:', children ? children.length : 0, 'children');
      console.log('Children data:', children);
      
      if (!list) {
        console.error('childrenList element not found');
        return;
      }
      
      if (!children || children.length === 0) {
        console.log('No children to render, showing empty message');
        list.innerHTML = '<li class="list-item">No hay niños registrados</li>';
        return;
      }
      
      console.log('Rendering children list with', children.length, 'items');
        list.innerHTML = children.map(child => {
          const displayName = sanitizeHTML(child.displayName || child.name);
          const avatar = sanitizeHTML(child.avatar || child.name.charAt(0).toUpperCase());
          const fatherName = sanitizeHTML((child.father_name || child.fatherName) || '');
          const motherName = sanitizeHTML((child.mother_name || child.motherName) || '');
          const totalTime = child.totalTimePlayed || 0;
          
          // Información de padres mejorada para mejor diferenciación
          let parentsInfo = '';
          // Usar los nombres correctos del backend (con guión bajo)
          const backendFatherName = child.father_name || child.fatherName;
          const backendMotherName = child.mother_name || child.motherName;
          
          console.log(`Child ${child.name} parent data:`, { 
            fatherName: backendFatherName, 
            motherName: backendMotherName 
          });
          
          if (backendFatherName && backendMotherName) {
            parentsInfo = `<div class="child-parents" style="color: #555; font-size: 12px; font-style: italic; margin-top: 2px;">
              <i class="fas fa-users" style="margin-right: 4px;"></i>${backendFatherName} & ${backendMotherName}
            </div>`;
          } else if (backendFatherName) {
            parentsInfo = `<div class="child-parents" style="color: #555; font-size: 12px; font-style: italic; margin-top: 2px;">
              <i class="fas fa-male" style="margin-right: 4px;"></i>Papá: ${backendFatherName}
            </div>`;
          } else if (backendMotherName) {
            parentsInfo = `<div class="child-parents" style="color: #555; font-size: 12px; font-style: italic; margin-top: 2px;">
              <i class="fas fa-female" style="margin-right: 4px;"></i>Mamá: ${backendMotherName}
            </div>`;
          }

          return `<li class="list-item child-item">
            <div class="child-info" style="flex: 1; margin-right: 10px;">
              <span class="child-avatar">${avatar}</span>
              <div class="child-details">
                <div class="child-name">${displayName}</div>
                ${parentsInfo}
                <div class="child-time">${totalTime} min</div>
              </div>
            </div>
            <div class="delete-button-container" style="flex-shrink: 0;">
              <div class="button-group-small">
                <button onclick="editChild(${child.id})" class="btn-edit" title="Editar información">
                  <i class="fas fa-edit"></i>
                </button>
                <button onclick="deleteChild(${child.id})" class="btn-danger btn-small" title="Eliminar niño">
            <i class="fas fa-trash"></i>
          </button>
              </div>
            </div>
          </li>`;
        }).join('');
        
        console.log('Children list rendered with', children.length, 'items');
        console.log('List HTML length:', list.innerHTML.length);
    }

    function renderGamesList(games) {
      const list = document.getElementById('gamesList');
      if (!list) return;
      
      if (!games || games.length === 0) {
        list.innerHTML = '<li class="list-item">No hay juegos registrados</li>';
        return;
      }
      list.innerHTML = games.map(game => 
        `<li class="list-item">
          <div style="flex: 1; margin-right: 10px;">
          <span><i class="fas fa-dice"></i> ${sanitizeHTML(game.name)}</span>
          </div>
          <div class="delete-button-container" style="flex-shrink: 0;">
            <button onclick="deleteGame(${game.id})" class="btn-danger btn-small">
            <i class="fas fa-trash"></i>
          </button>
          </div>
        </li>`
      ).join('');
    }

    function updateChildSelect(children) {
      const select = document.getElementById('selectedChildId');
      if (!select) return;
      
      select.innerHTML = '<option value="">Seleccione un niño</option>' +
        (children || []).map(child => {
          const displayName = sanitizeHTML(child.displayName || child.name);
          
          // Agregar información de padres si existe para diferenciar
          let parentInfo = '';
          if (child.fatherName || child.motherName) {
            const father = sanitizeHTML(child.fatherName || '');
            const mother = sanitizeHTML(child.motherName || '');
            const separator = father && mother ? ', ' : '';
            parentInfo = ` (${father}${separator}${mother})`;
          }
          
          return `<option value="${child.id}">${displayName}${parentInfo}</option>`;
        }).join('');
    }

    function updateGameSelect(games) {
      const select = document.getElementById('gameSelect');
      if (!select) {
        console.warn('Game select element not found');
        return;
      }
      
      console.log('Updating game select with games:', games ? games.length : 0, 'games');
      
      if (!games || !Array.isArray(games) || games.length === 0) {
        console.warn('No games provided to updateGameSelect');
        select.innerHTML = '<option value="">Seleccione un juego</option>';
        return;
      }
      
      select.innerHTML = '<option value="">Seleccione un juego</option>' +
        games.map(game => `<option value="${game.id}">${sanitizeHTML(game.name)}</option>`).join('');
        
      console.log('Game select updated with', games.length, 'options');
    }

    // Función para forzar la recarga de juegos
    async function forceRefreshGames() {
      console.log('🔄 Forzando recarga de juegos...');
      showStatusMessage('Recargando lista de juegos...', 'info');
      
      try {
        // Limpiar caché completamente
        gamesCache = [];
        updateGameSelect([]);
        
        // Hacer fetch directo
        const response = await fetch(api + '/games');
        console.log('Force refresh - Response status:', response.status);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const games = await response.json();
        console.log('Force refresh - Games received:', games);
        
        if (Array.isArray(games)) {
          gamesCache = games;
          updateGameSelect(gamesCache);
          renderGamesList(gamesCache);
          
          console.log('✅ Juegos recargados exitosamente:', gamesCache.length);
          showStatusMessage(`✅ ${gamesCache.length} juegos cargados`, 'success');
        } else {
          throw new Error('Formato de datos inválido');
        }
        
      } catch (error) {
        console.error('❌ Error forzando recarga de juegos:', error);
        showStatusMessage('❌ Error al recargar juegos', 'error');
        gamesCache = [];
        updateGameSelect([]);
      }
    }

    // Funciones de sesiones activas ROBUSTAS
    async function fetchActiveSessions() {
      try {
        console.log('Fetching active sessions from:', api + '/sessions/active');
        const res = await fetchWithRetry(api + '/sessions/active');
        console.log('Active sessions response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const newActiveSessionsData = await res.json() || [];
        console.log('Active sessions data received:', newActiveSessionsData);
        
        // Actualizar siempre para mostrar cambios
        activeSessionsData = newActiveSessionsData;
        console.log('Active sessions data updated:', activeSessionsData);
        console.log('Children cache length:', childrenCache.length);
        console.log('Games cache length:', gamesCache.length);
        renderActiveSessions();
        console.log('Active sessions rendered:', activeSessionsData.length, 'sessions');
        
      } catch (error) {
        console.error('Error fetching active sessions:', error);
        
        // NO resetear las sesiones activas en caso de error
        console.warn('Failed to fetch active sessions, keeping current data');
        
        // Solo actualizar timers con datos existentes
        if (activeSessionsData.length > 0) {
          updateExistingTimers();
        } else {
          // Si no hay datos, mostrar mensaje de no sesiones activas
          const list = document.getElementById('activeSessions');
          if (list) {
            list.innerHTML = '<li class="list-item">No hay sesiones activas</li>';
          }
        }
      }
    }


    function renderActiveSessions() {
      const list = document.getElementById('activeSessions');
      if (!list) return;
      
      // Limitar a 50 sesiones visibles para mejor rendimiento
      const visibleSessions = activeSessionsData.slice(0, 50);
      const hiddenCount = activeSessionsData.length - 50;
      
      if (activeSessionsData.length === 0) {
        if (list.innerHTML !== '<li class="list-item">No hay sesiones activas</li>') {
          list.innerHTML = '<li class="list-item">No hay sesiones activas</li>';
        }
        return;
      }
      
      // Solo re-renderizar si la estructura cambió
      const sessionHash = visibleSessions.map(s => `${s.id}-${s.childId}-${s.gameId}-${s.duration}`).join('|');
      
      if (list.dataset.sessionHash !== sessionHash) {
        let html = visibleSessions.map(s => generateSingleSessionHTML(s)).join('');
        
        if (hiddenCount > 0) {
          html += `<li class="list-item info"><i class="fas fa-info-circle"></i> ... y ${hiddenCount} sesiones más</li>`;
        }
        
        list.innerHTML = html;
        list.dataset.sessionHash = sessionHash;
        startTimers();
        console.log('Active sessions structure updated:', visibleSessions.length, 'visible,', hiddenCount, 'hidden');
      }
    }
    
    function generateSingleSessionHTML(s) {
      const child = childrenCache.find(c => c.id === s.childId);
      const game = gamesCache.find(g => g.id === s.gameId);
      
      // Si no encontramos el niño o juego, solo mostrar datos desconocidos
      if (!child || !game) {
        console.warn('Missing child or game data for session:', s.id);
      }
      
      // Usar displayName si existe y no es null/undefined, sino el nombre original
      const childDisplayName = child ? (child.displayName && child.displayName !== 'null' ? child.displayName : child.name) : 'Niño desconocido';
      const childAvatar = child ? (child.avatar || child.name.charAt(0).toUpperCase()) : '?';
      const gameName = game ? game.name : 'Juego desconocido';
      
      // Información de padres para diferenciación
      let parentsInfo = '';
      if (child && (child.fatherName || child.motherName)) {
        if (child.fatherName && child.motherName) {
          parentsInfo = '<br><small class="parents-info"><i class="fas fa-users"></i> ' + child.fatherName + ' & ' + child.motherName + '</small>';
        } else if (child.fatherName) {
          parentsInfo = '<br><small class="parents-info"><i class="fas fa-users"></i> Papá: ' + child.fatherName + '</small>';
        } else if (child.motherName) {
          parentsInfo = '<br><small class="parents-info"><i class="fas fa-users"></i> Mamá: ' + child.motherName + '</small>';
        }
      }
      
      return '<li class="list-item active" data-session-id="' + s.id + '" id="session-' + s.id + '">' +
        '<div class="session-info">' +
          '<strong><span class="child-avatar-small">' + childAvatar + '</span> <i class="fas fa-child"></i> ' + childDisplayName + '</strong>' + parentsInfo + '<br>' +
          '<small><i class="fas fa-gamepad"></i> ' + gameName + '</small><br>' +
          '<small><i class="fas fa-clock"></i> Duración: ' + s.duration + ' min</small>' +
        '</div>' +
        '<div class="session-controls">' +
          '<div class="timer" id="timer-' + s.id + '">Calculando...</div>' +
          '<div class="button-group">' +
            '<button class="btn-danger" onclick="endSession(' + s.id + ')" style="padding: 4px 8px; font-size: 11px; margin-right: 3px;">' +
              '<i class="fas fa-stop"></i> FIN' +
            '</button>' +
            '<button class="extend-time" onclick="showExtendModal(' + s.id + ', \`' + childDisplayName + '\`)" style="padding: 4px 8px; font-size: 11px;">' +
              '<i class="fas fa-plus"></i> +5' +
            '</button>' +
          '</div>' +
        '</div>' +
      '</li>';
    }
    
    function generateActiveSessionsHTML() {
      if (!activeSessionsData || activeSessionsData.length === 0) {
        return '<li class="list-item">No hay sesiones activas</li>';
      }
      
      return activeSessionsData.map(s => {
        const child = childrenCache.find(c => c.id === s.childId);
        const game = gamesCache.find(g => g.id === s.gameId);
        
        // Si no encontramos el niño o juego, solo mostrar datos desconocidos
        if (!child || !game) {
          console.warn('Missing child or game data for session:', s.id);
        }
        
        // Usar displayName si existe y no es null/undefined, sino el nombre original
        const childDisplayName = child ? (child.displayName && child.displayName !== 'null' ? child.displayName : child.name) : 'Niño desconocido';
        const childAvatar = child ? (child.avatar || child.name.charAt(0).toUpperCase()) : '?';
        const gameName = game ? game.name : 'Juego desconocido';
        
        // Información de padres para diferenciación
        let parentsInfo = '';
        if (child && (child.fatherName || child.motherName)) {
          if (child.fatherName && child.motherName) {
            parentsInfo = `<br><small class="parents-info"><i class="fas fa-users"></i> ${child.fatherName} & ${child.motherName}</small>`;
          } else if (child.fatherName) {
            parentsInfo = `<br><small class="parents-info"><i class="fas fa-users"></i> Papá: ${child.fatherName}</small>`;
          } else if (child.motherName) {
            parentsInfo = `<br><small class="parents-info"><i class="fas fa-users"></i> Mamá: ${child.motherName}</small>`;
          }
        }
        
        return `<li class="list-item active" data-session-id="${s.id}" id="session-${s.id}">
          <div class="session-info">
            <strong><span class="child-avatar-small">${childAvatar}</span> <i class="fas fa-child"></i> ${childDisplayName}</strong>${parentsInfo}<br>
            <small><i class="fas fa-gamepad"></i> ${gameName}</small><br>
            <small><i class="fas fa-clock"></i> Duración: ${s.duration} min</small>
          </div>
          <div class="session-controls">
            <div class="timer" id="timer-${s.id}">Calculando...</div>
            <div class="button-group">
              <button class="btn-danger" onclick="endSession(${s.id})" style="padding: 4px 8px; font-size: 11px; margin-right: 3px;">
                <i class="fas fa-stop"></i> FIN
              </button>
              <button class="extend-time" onclick="showExtendModal(${s.id}, \`${childDisplayName}\`)" style="padding: 4px 8px; font-size: 11px;">
                <i class="fas fa-plus"></i> +5
              </button>
            </div>
          </div>
        </li>`;
      }).join('');
    }
    
    function updateExistingTimers() {
      // Solo actualizar timers existentes sin recrear el DOM
      const list = document.getElementById('activeSessions');
      if (!list) return;
      
      if (!activeSessionsData || activeSessionsData.length === 0) return;
      
      activeSessionsData.forEach(s => {
        const sessionElement = list.querySelector(`[data-session-id="${s.id}"]`);
        const timerElement = sessionElement ? sessionElement.querySelector('.timer') : null;
        
        if (!sessionElement || !timerElement) return;
        
          // Actualizar directamente el contenido del timer sin recrear el elemento
          const now = Date.now();
        
        // Buscar startTime en múltiples formatos posibles
        let startTime = s.start || s.startTime;
        
        // Convertir string a timestamp si es necesario
        if (typeof startTime === 'string') {
          startTime = new Date(startTime).getTime();
        }
        
        // Si no hay startTime válido, usar createdAt como fallback
        if (!startTime || isNaN(startTime)) {
          startTime = s.created_at ? new Date(s.created_at).getTime() : now;
        }
        
        // Asegurar que startTime es un número válido
        if (isNaN(startTime) || startTime <= 0) {
          startTime = now;
        }
        
        const elapsed = Math.floor((now - startTime) / 1000);
        const totalDurationSeconds = (s.duration || 1) * 60;
        const remaining = Math.max(0, totalDurationSeconds - elapsed);
        
        // Validar que los cálculos son válidos
        if (isNaN(elapsed) || isNaN(remaining) || isNaN(totalDurationSeconds)) {
          console.error('Invalid timer calculation:', { elapsed, remaining, totalDurationSeconds, startTime, now, duration: s.duration });
          timerElement.innerHTML = '<strong>Calculando...</strong>';
          timerElement.className = 'timer';
          return;
        }
          
          if (remaining <= 0) {
          timerElement.innerHTML = '<strong>Tiempo agotado</strong>';
            timerElement.className = 'timer danger';
          } else {
            const h = Math.floor(remaining / 3600);
            const m = Math.floor((remaining % 3600) / 60);
            const s = remaining % 60;
            const elapsedMin = Math.floor(elapsed / 60);
            const elapsedSec = elapsed % 60;
            
          timerElement.innerHTML = 'Restante: ' + h + ':' + m.toString().padStart(2, '0') + ':' + s.toString().padStart(2, '0') + '<br><small>Transcurrido: ' + elapsedMin + ':' + elapsedSec.toString().padStart(2, '0') + '</small>';
            
            // Cambiar color según tiempo restante
            if (remaining <= 60) {
              timerElement.className = 'timer danger';
            } else if (remaining <= 300) {
              timerElement.className = 'timer warning';
            } else {
              timerElement.className = 'timer';
          }
        }
      });
    }

    function startTimers() {
      // Limpiar timers de sesiones que ya no existen
      const currentSessionIds = activeSessionsData.map(s => s.id);
      timerIntervals.forEach((interval, sessionId) => {
        if (!currentSessionIds.includes(sessionId)) {
          clearInterval(interval);
          timerIntervals.delete(sessionId);
        }
      });

      // Crear timers solo para sesiones nuevas
      activeSessionsData.forEach(s => {
        if (!timerIntervals.has(s.id)) {
          let startTime = s.start || s.startTime || Date.now();
          if (typeof startTime === 'string') {
            startTime = new Date(startTime).getTime();
          }
          updateTimer(s.id, startTime, s.duration);
          const interval = setInterval(() => updateTimer(s.id, startTime, s.duration), 1000);
          timerIntervals.set(s.id, interval);
        }
      });
    }

    function updateTimer(sessionId, startTime, duration) {
      const timerSpan = document.getElementById(`timer-${sessionId}`);
      if (!timerSpan) return;
      
      // Usar datos actualizados de activeSessionsData si están disponibles
      const sessionData = activeSessionsData.find(s => s.id === sessionId);
      
      // Convertir timestamp de string a número si es necesario
      let currentStartTime = sessionData ? (sessionData.start || sessionData.startTime || startTime) : startTime;
      if (typeof currentStartTime === 'string') {
        currentStartTime = new Date(currentStartTime).getTime();
      }
      
      const currentDuration = sessionData ? sessionData.duration : duration;
      
      // VALIDACIÓN CRÍTICA DE DURACIÓN
      if (!currentDuration || typeof currentDuration !== 'number' || currentDuration <= 0) {
        console.error('Invalid duration in updateTimer:', { sessionId, currentDuration, sessionData });
        timerSpan.textContent = '⏱️ Duración inválida';
        return;
      }
      
      const now = Date.now();
      
      // Validar que currentStartTime es un número válido
      if (isNaN(currentStartTime) || currentStartTime <= 0) {
        console.error('Invalid startTime in updateTimer:', { sessionId, currentStartTime, sessionData });
        timerSpan.textContent = '⏱️ Calculando...';
        return;
      }
      
      const elapsedSeconds = Math.floor((now - currentStartTime) / 1000);
      const totalSeconds = Math.floor(currentDuration * 60);
      const remainingSeconds = totalSeconds - elapsedSeconds;
      
      // VALIDACIÓN CRÍTICA DE CÁLCULOS
      if (isNaN(elapsedSeconds) || isNaN(totalSeconds) || isNaN(remainingSeconds)) {
        console.error('Invalid timer calculations:', { sessionId, elapsedSeconds, totalSeconds, remainingSeconds });
        timerSpan.textContent = '⏱️ Error de cálculo';
        return;
      }
      
      const h = String(Math.floor(remainingSeconds / 3600)).padStart(2, '0');
      const m = String(Math.floor((remainingSeconds % 3600) / 60)).padStart(2, '0');
      const s = String(remainingSeconds % 60).padStart(2, '0');
      
      // Calcular tiempo transcurrido para mostrar también
      const elapsedMinutes = Math.floor(elapsedSeconds / 60);
      const elapsedSecs = elapsedSeconds % 60;
      
      // Actualizar clases según el tiempo restante
      timerSpan.className = 'timer';
      if (remainingSeconds <= 0) {
        timerSpan.textContent = '⏰ ¡Tiempo terminado!';
        timerSpan.classList.add('danger');
        if (!timerSpan.classList.contains('alerted')) {
          timerSpan.classList.add('alerted');
          const session = activeSessionsData.find(s => s.id === sessionId);
          const child = childrenCache.find(c => c.id === session.childId);
          showCustomModal(`¡Se acabó el tiempo para ${child ? child.name : 'este niño'}!`);
          endSession(sessionId);
        }
      } else if (remainingSeconds <= 60) {
        timerSpan.innerHTML = '<strong>Restante:</strong> ' + sanitizeHTML(m) + ':' + sanitizeHTML(s) + '<br><small>Transcurrido: ' + sanitizeHTML(String(elapsedMinutes)) + ':' + sanitizeHTML(String(elapsedSecs).padStart(2, '0')) + '</small>';
        timerSpan.classList.add('warning');
        // Alerta cuando quedan 30 segundos
        if (remainingSeconds <= 30 && !timerSpan.classList.contains('alerted-30')) {
          timerSpan.classList.add('alerted-30');
          const session = activeSessionsData.find(s => s.id === sessionId);
          const child = childrenCache.find(c => c.id === session.childId);
          
          let childDisplayName = child ? (child.displayName || child.name) : 'este niño';
          let parentsText = '';
          if (child && (child.fatherName || child.motherName)) {
            if (child.fatherName && child.motherName) {
              parentsText = ` (${child.fatherName} & ${child.motherName})`;
            } else if (child.fatherName) {
              parentsText = ` (Papá: ${child.fatherName})`;
            } else if (child.motherName) {
              parentsText = ` (Mamá: ${child.motherName})`;
            }
          }
          
          showStatusMessage(`¡Atención! A ${childDisplayName}${parentsText} le quedan solo ${remainingSeconds} segundos`, 'warning', sessionId);
        }
      } else {
        timerSpan.innerHTML = '<strong>Restante:</strong> ' + sanitizeHTML(h) + ':' + sanitizeHTML(m) + ':' + sanitizeHTML(s) + '<br><small>Transcurrido: ' + sanitizeHTML(String(elapsedMinutes)) + ':' + sanitizeHTML(String(elapsedSecs).padStart(2, '0')) + '</small>';
      }
    }

    async function fetchSessionHistory() {
      try {
        console.log('Fetching session history from:', api + '/sessions');
        const res = await fetchWithRetry(api + '/sessions');
        console.log('Session history response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const sessions = await res.json() || [];
        console.log('Session history data received:', sessions);
        
        renderSessionHistory(sessions);
        console.log('Session history loaded successfully:', sessions);
      } catch (error) {
        console.error('Error fetching session history:', error);
        
        // En caso de error, mostrar mensaje de no historial
        const list = document.getElementById('sessionHistory');
        if (list) {
          list.innerHTML = '<li class="list-item">No hay sesiones registradas</li>';
        }
        
        console.warn('Failed to fetch session history, showing empty state');
      }
    }

    function renderSessionHistory(sessions) {
      const list = document.getElementById('sessionHistory');
      if (!list) return;
      
      if (!sessions || sessions.length === 0) {
        list.innerHTML = '<div class="history-item" style="text-align: center; padding: 20px; color: #666;"><i class="fas fa-history" style="font-size: 24px; margin-bottom: 8px; display: block;"></i>No hay sesiones registradas</div>';
        return;
      }
      
      // Asegurar que tenemos datos de niños y juegos antes de renderizar
      if (childrenCache.length === 0 || gamesCache.length === 0) {
        console.log('Missing cache data, refreshing...');
        fetchChildren().then(() => fetchGames()).then(() => {
          // Re-renderizar con datos actualizados
          renderSessionHistory(sessions);
        });
        return;
      }
      
      // Mostrar las últimas 5 sesiones por defecto, resto colapsado
      const recentSessions = sessions.slice(0, 5);
      const hiddenSessions = sessions.slice(5);
      
      let html = '';
      
      // Botón para expandir/colapsar si hay más de 5 sesiones
      if (sessions.length > 5) {
        html += `
        <button class="history-toggle" onclick="toggleHistoryView()" id="historyToggle">
          <i class="fas fa-chevron-down"></i>
          Ver ${hiddenSessions.length} sesiones anteriores
        </button>`;
      }
      
      html += recentSessions.map(s => {
        const child = childrenCache.find(c => c.id === s.childId);
        const game = gamesCache.find(g => g.id === s.gameId);
        
        // Usar nombres reales, si no se encuentran, mostrar "Desconocido"
        const childName = child ? (child.displayName && child.displayName !== 'null' ? child.displayName : child.name) : 'Niño desconocido';
        const gameName = game ? game.name : 'Juego desconocido';
        
        // Información de padres para diferenciación
        let parentsInfo = '';
        if (child && ((child.father_name || child.fatherName) || (child.mother_name || child.motherName))) {
          const fatherName = child.father_name || child.fatherName;
          const motherName = child.mother_name || child.motherName;
          
          if (fatherName && motherName) {
            parentsInfo = `<div class="history-parents"><i class="fas fa-users"></i> ${fatherName} & ${motherName}</div>`;
          } else if (fatherName) {
            parentsInfo = `<div class="history-parents"><i class="fas fa-users"></i> Papá: ${fatherName}</div>`;
          } else if (motherName) {
            parentsInfo = `<div class="history-parents"><i class="fas fa-users"></i> Mamá: ${motherName}</div>`;
          }
        }
        
        const startTimeValue = s.startTime || s.start || Date.now();
        const startTime = new Date(startTimeValue);
        const timeStr = startTime.toLocaleTimeString('es-ES', {
          hour: '2-digit',
          minute: '2-digit'
        });
        const dateStr = startTime.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit'
        });
        
        let statusClass, iconClass, durationText, durationClass;
        
        if (s.endTime || s.end) {
          // Sesión finalizada
          const endTimeValue = s.endTime || s.end;
          const endTime = new Date(endTimeValue);
          
          // Verificar que las fechas sean válidas
          if (isNaN(startTime.getTime()) || isNaN(endTime.getTime())) {
            console.warn('Invalid dates for session:', s.id, 'start:', startTimeValue, 'end:', endTimeValue);
            durationText = `${s.duration || 0}min`;
          } else {
            const duration = Math.round((endTime.getTime() - startTime.getTime()) / 60000);
            durationText = `${Math.max(0, duration)}min`;
          }
          
          statusClass = 'completed';
          iconClass = 'completed';
          durationClass = 'completed';
        } else {
          // Sesión en curso - usar la misma lógica que renderActiveSessions
          const currentTime = Date.now();
          
          // Verificar que startTimeValue sea válido
          if (isNaN(startTime.getTime())) {
            console.warn('Invalid start time for session:', s.id, 'start:', startTimeValue);
            durationText = `${s.duration || 0}min`;
            statusClass = 'active';
            iconClass = 'active';
            durationClass = 'active';
          } else {
            const elapsedSeconds = Math.floor((currentTime - startTime.getTime()) / 1000);
            const totalSeconds = (s.duration || 15) * 60;
            const remainingSeconds = Math.max(0, totalSeconds - elapsedSeconds);
            
            // Convertir a minutos para mostrar
            const elapsedMinutes = Math.floor(elapsedSeconds / 60);
            const totalMinutes = s.duration || 15;
          
            if (remainingSeconds <= 0) {
              statusClass = 'expired';
              iconClass = 'expired';
              durationText = 'Agotado';
              durationClass = 'expired';
            } else {
              statusClass = 'active';
              iconClass = 'active';
              durationText = `${elapsedMinutes}/${totalMinutes}min`;
              durationClass = 'active';
            }
          }
        }
        
        return `
        <div class="history-item ${statusClass}">
          <div class="history-icon ${iconClass}">
            <i class="fas fa-${s.end ? 'check' : (statusClass === 'expired' ? 'exclamation' : 'play')}"></i>
          </div>
          <div class="history-content">
            <div class="history-title">
              <i class="fas fa-child"></i>
              ${childName}
            </div>
            ${parentsInfo}
            <div class="history-subtitle">
              <i class="fas fa-gamepad"></i>
              ${gameName}
            </div>
          </div>
          <div class="history-meta">
            <div class="history-duration ${durationClass}">
              ${durationText}
            </div>
            <div class="history-time">
              ${dateStr} ${timeStr}
            </div>
          </div>
        </div>`;
      }).join('');
      
      // Agregar sesiones ocultas si las hay
      if (hiddenSessions.length > 0) {
        html += `<div id="hiddenSessions" class="history-hidden">`;
        html += hiddenSessions.map(s => {
          const child = childrenCache.find(c => c.id === s.childId);
          const game = gamesCache.find(g => g.id === s.gameId);
          
          const childName = child ? (child.displayName && child.displayName !== 'null' ? child.displayName : child.name) : 'Niño desconocido';
          const gameName = game ? game.name : 'Juego desconocido';
          
          // Información de padres para diferenciación
          let parentsInfo = '';
          if (child && ((child.father_name || child.fatherName) || (child.mother_name || child.motherName))) {
            const fatherName = child.father_name || child.fatherName;
            const motherName = child.mother_name || child.motherName;
            
            if (fatherName && motherName) {
              parentsInfo = `<div class="history-parents"><i class="fas fa-users"></i> ${fatherName} & ${motherName}</div>`;
            } else if (fatherName) {
              parentsInfo = `<div class="history-parents"><i class="fas fa-users"></i> Papá: ${fatherName}</div>`;
            } else if (motherName) {
              parentsInfo = `<div class="history-parents"><i class="fas fa-users"></i> Mamá: ${motherName}</div>`;
            }
          }
          
          const startTime = new Date(s.start);
          const timeStr = startTime.toLocaleTimeString('es-ES', {
            hour: '2-digit',
            minute: '2-digit'
          });
          const dateStr = startTime.toLocaleDateString('es-ES', {
            day: '2-digit',
            month: '2-digit'
          });
          
          let statusClass, iconClass, durationText, durationClass;
          
          if (s.end) {
            const duration = Math.round((s.end - s.start) / 60000);
            statusClass = 'completed';
            iconClass = 'completed';
            durationText = `${duration}min`;
            durationClass = 'completed';
          } else {
            const currentTime = Date.now();
            const elapsedMinutes = Math.round((currentTime - s.start) / 60000);
            const totalMinutes = s.duration || 15;
            const remainingMinutes = Math.max(0, totalMinutes - elapsedMinutes);
            
            if (remainingMinutes <= 0) {
              statusClass = 'expired';
              iconClass = 'expired';
              durationText = 'Agotado';
              durationClass = 'expired';
            } else {
              statusClass = 'active';
              iconClass = 'active';
              durationText = `${elapsedMinutes}/${totalMinutes}min`;
              durationClass = 'active';
            }
          }
          
          return `
          <div class="history-item ${statusClass}">
            <div class="history-icon ${iconClass}">
              <i class="fas fa-${s.end ? 'check' : (statusClass === 'expired' ? 'exclamation' : 'play')}"></i>
            </div>
            <div class="history-content">
              <div class="history-title">
                <i class="fas fa-child"></i>
                ${childName}
              </div>
              ${parentsInfo}
              <div class="history-subtitle">
                <i class="fas fa-gamepad"></i>
                ${gameName}
              </div>
            </div>
            <div class="history-meta">
              <div class="history-duration ${durationClass}">
                ${durationText}
              </div>
              <div class="history-time">
                ${dateStr} ${timeStr}
              </div>
            </div>
          </div>`;
        }).join('');
        html += `</div>`;
      }
      
      list.innerHTML = html;
    }

    // Función para alternar vista del historial
    function toggleHistoryView() {
      const hiddenSessions = document.getElementById('hiddenSessions');
      const toggleBtn = document.getElementById('historyToggle');
      
      if (hiddenSessions && toggleBtn) {
        if (hiddenSessions.classList.contains('history-hidden')) {
          // Expandir
          hiddenSessions.classList.remove('history-hidden');
          toggleBtn.innerHTML = '<i class="fas fa-chevron-up"></i> Ocultar sesiones anteriores';
          toggleBtn.classList.add('expanded');
        } else {
          // Colapsar
          hiddenSessions.classList.add('history-hidden');
          toggleBtn.innerHTML = '<i class="fas fa-chevron-down"></i> Ver sesiones anteriores';
          toggleBtn.classList.remove('expanded');
        }
      }
    }

    // Funciones principales ROBUSTAS
    async function addChild() {
      try {
        checkRateLimit('addChild');
      } catch (error) {
        showStatusMessage(error.message, 'error');
        return;
      }
      
      const name = document.getElementById('childName').value;
      const nickname = document.getElementById('childNickname').value;
      const fatherName = document.getElementById('fatherName').value;
      const motherName = document.getElementById('motherName').value;
      
      // Validar datos y declarar variables en el scope correcto
      let validatedName, validatedNickname, validatedFatherName, validatedMotherName;
      
      // Validación simple y directa
      if (!name || name.trim().length < 2) {
        showStatusMessage('El nombre del niño debe tener al menos 2 caracteres', 'error');
        return;
      }
      
      validatedName = name.trim();
      validatedNickname = nickname ? nickname.trim() : null;
      validatedFatherName = fatherName ? fatherName.trim() : null;
      validatedMotherName = motherName ? motherName.trim() : null;
      
      showLoading('addChildBtn', true);
      try {
        const requestData = { 
          name: validatedName,
          nickname: validatedNickname,
          fatherName: validatedFatherName,
          motherName: validatedMotherName
        };
        
        // console.log('Adding child:', requestData);
        
        const res = await fetchWithRetry(api + '/children', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestData)
        });
        
        // console.log('Response status:', res.status);
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          console.log('Error response:', errorData);
          
          // Manejar duplicados con sugerencias
          if (errorData.duplicate && errorData.suggestion) {
            showStatusMessage('⚠️ ' + errorData.suggestion, 'warning');
            return;
          }
          
          throw new Error(errorData.error || 'Error al agregar niño');
        }
        
        const responseData = await res.json();
        // console.log('Success response:', responseData);
        
        // Limpiar formulario
        document.getElementById('childName').value = '';
        document.getElementById('childNickname').value = '';
        document.getElementById('fatherName').value = '';
        document.getElementById('motherName').value = '';
        
        // Limpiar caché y recargar datos frescos
        
        // Limpiar caché completamente
        childrenCache = [];
        console.log('Cache cleared, fetching fresh data...');
        
        // Recargar datos frescos del backend con cache busting
        try {
          const timestamp = Date.now();
          const freshRes = await fetchWithRetry(api + '/children?t=' + timestamp);
          const freshChildren = await freshRes.json();
          
          console.log('Fresh children data received:', freshChildren);
          childrenCache = freshChildren || [];
          
          // Renderizar inmediatamente con datos frescos
          renderChildrenList(childrenCache);
          updateChildSelect(childrenCache);
          
          console.log('Children list updated with', childrenCache.length, 'items');
        } catch (error) {
          console.error('Error reloading fresh data:', error);
          // NO recargar página - mantener estado del usuario
          showStatusMessage('Error al recargar datos. Por favor, intente nuevamente.', 'error');
          // Intentar recargar datos en segundo plano después de 5 segundos
          setTimeout(() => {
            console.log('Reintentando recarga de datos en segundo plano...');
            fetchChildren(true).catch(() => {
              console.log('Recarga en segundo plano falló, continuando con datos actuales');
            });
          }, 1000);
        }
        
        showStatusMessage('Niño agregado exitosamente', 'success');
      } catch (error) {
        console.error('Error adding child:', error);
            showStatusMessage('Error al agregar niño: ' + error.message, 'error');
      } finally {
        showLoading('addChildBtn', false);
      }
    }

    async function addGame() {
      const name = document.getElementById('gameName').value.trim();
      if (!validateName(name, 'nombre del juego')) return;
      
      showLoading('addGameBtn', true);
      try {
        const res = await fetchWithRetry(api + '/games', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al agregar juego');
        }
        
        document.getElementById('gameName').value = '';
        
        // Actualizar juegos primero para mostrar inmediatamente
        await fetchGames();
        
        // Luego actualizar el resto de datos
        await Promise.all([
          fetchChildren(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        
        showStatusMessage('Juego agregado exitosamente', 'success');
      } catch (error) {
        console.error('Error adding game:', error);
        showStatusMessage('Error al agregar juego: ' + error.message, 'error');
      } finally {
        showLoading('addGameBtn', false);
      }
    }


    async function startSession() {
      // Prevenir doble-clic
      if (AppState?.isStartingSession) {
        showStatusMessage('⏳ Iniciando sesión, por favor espera...', 'warning');
        return;
      }
      
      try {
        AppState.isStartingSession = true;
        
        const durationInput = document.getElementById('durationInput').value;
        
        // Validar duración primero
        if (!durationInput || durationInput.trim() === '') {
          showStatusMessage('Por favor ingrese un tiempo válido', 'error');
          return;
        }
        
        const duration = validateDuration(durationInput);
        
        // OBTENER VALORES INMEDIATAMENTE - NO ESPERAR
        const selectedChildId = document.getElementById('selectedChildId').value;
        const gameId = document.getElementById('gameSelect').value;
        
        // VALIDAR INMEDIATAMENTE - NO HACER NADA MÁS SI FALTA ALGO
        if (!selectedChildId) {
          showStatusMessage('Por favor seleccione un niño', 'error');
          AppState.isStartingSession = false;
          return;
        }
        
        if (!gameId) {
          showStatusMessage('Por favor seleccione un juego', 'error');
          AppState.isStartingSession = false;
          return;
        }
        
        console.log('Starting session:', { selectedChildId, gameId, duration, originalInput: durationInput });
        
        if (!validateSession(selectedChildId, gameId, duration)) {
          AppState.isStartingSession = false;
          return;
        }
        
        // Verificar que el niño y juego existen en el caché
        const child = childrenCache.find(c => c.id == selectedChildId);
        const game = gamesCache.find(g => g.id == gameId);
      
      if (!child) {
          console.error('Child not found:', selectedChildId, 'Available children:', childrenCache.map(c => `${c.id}:${c.name}`));
          showStatusMessage('Error: Niño no encontrado. Por favor selecciona un niño válido.', 'error');
          document.getElementById('selectedChildId').value = '';
        return;
      }
      
      if (!game) {
          console.error('Game not found:', gameId, 'Available games:', gamesCache.map(g => `${g.id}:${g.name}`));
          showStatusMessage('Error: Juego no encontrado. Por favor selecciona un juego válido.', 'error');
          document.getElementById('gameSelect').value = '';
        return;
      }
        
        console.log('Validación exitosa - Iniciando sesión:', {
          childId: selectedChildId,
          gameId: gameId,
          duration: duration,
          childName: child.name,
          gameName: game.name
        });
      
      showLoading('startBtn', true);
        
        const requestBody = { 
          childId: validateId(selectedChildId, 'ID del niño'), 
          gameId: validateId(gameId, 'ID del juego'), 
          duration: duration 
        };
        
        console.log('Request body:', requestBody);
        
        const res = await fetchWithRetry(api + '/sessions/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });
        
        console.log('Response status:', res.status);
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al iniciar sesión');
        }
        
        const result = await res.json();
        console.log('Session started:', result);
        
        // Actualizar datos inmediatamente después de iniciar sesión
        await Promise.all([
          fetchActiveSessions(),
          fetchSessionHistory(),
          fetchChildren() // Asegurar datos actualizados
        ]);
        // showStatusMessage('Sesión iniciada exitosamente', 'success');
        
        // Limpiar alertas de sesiones anteriores
        clearAllSessionAlerts();
        
      } catch (error) {
        console.error('Error starting session:', error);
        showStatusMessage('Error al iniciar sesión: ' + error.message, 'error');
      } finally {
        showLoading('startBtn', false);
        AppState.isStartingSession = false; // Liberar el lock
      }
    }

    async function endSession(sessionId) {
      try {
        const res = await fetchWithRetry(api + '/sessions/' + sessionId + '/end', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al finalizar sesión');
        }
        
        // Limpiar timer
        if (timerIntervals.has(sessionId)) {
          clearInterval(timerIntervals.get(sessionId));
          timerIntervals.delete(sessionId);
        }
        
        // Actualizar datos inmediatamente después de finalizar sesión
        await Promise.all([
          fetchActiveSessions(),
          fetchSessionHistory(),
          fetchChildren() // Asegurar datos actualizados
        ]);
        // showStatusMessage('Sesión finalizada', 'success');
        
        // Limpiar alertas de esta sesión
        clearSessionAlert(sessionId);
      } catch (error) {
        console.error('Error ending session:', error);
        showStatusMessage('Error al finalizar sesión: ' + error.message, 'error');
      }
    }

    // Función para extender tiempo ROBUSTA
    async function confirmExtendTime() {
      if (!currentExtendSession) {
        showStatusMessage('No hay sesión seleccionada para extender', 'error');
        return;
      }
      
      const additionalTime = validateInput(document.getElementById('extendTimeInput').value, 'number', 1, 60);
      if (additionalTime === null) {
        showStatusMessage('El tiempo adicional debe estar entre 1 y 60 minutos', 'error');
        return;
      }
      
      // Verificar que la sesión aún existe
      const session = activeSessionsData.find(s => s.id === currentExtendSession);
      if (!session) {
        showStatusMessage('La sesión ya no está activa', 'error');
        closeExtendModal();
        return;
      }
      
      try {
        console.log('Extending session:', currentExtendSession, 'by', additionalTime, 'minutes');
        
        const res = await fetchWithRetry(api + '/sessions/extend', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            session_id: currentExtendSession, 
            additional_minutes: additionalTime 
          })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al extender tiempo');
        }
        
        const result = await res.json();
        console.log('Time extended successfully:', result);
        
        closeExtendModal();
        
        // Actualizar datos inmediatamente
        await Promise.all([
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        
        // Reiniciar timers para usar los datos actualizados
        startTimers();
        
        showStatusMessage('+' + additionalTime + ' min', 'success');
      } catch (error) {
        console.error('Error extending time:', error);
        showStatusMessage('Error al extender tiempo: ' + error.message, 'error');
      }
    }

    // Funciones de eliminación ROBUSTAS
    async function deleteChild(childId) {
      if (!confirm('¿Está seguro de que desea eliminar este niño?')) return;
      
      try {
        const res = await fetchWithRetry(`${api}/children/${childId}`, {
          method: 'DELETE'
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al eliminar niño');
        }
        
        // Actualizar todos los datos después de eliminar niño
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        // showStatusMessage('Niño eliminado', 'success');
      } catch (error) {
        console.error('Error deleting child:', error);
        showStatusMessage('Error al eliminar niño: ' + error.message, 'error');
      }
    }

    async function deleteGame(gameId) {
      if (!confirm('¿Está seguro de que desea eliminar este juego?')) return;
      
      try {
        const res = await fetchWithRetry(`${api}/games/${gameId}`, {
          method: 'DELETE'
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al eliminar juego');
        }
        
        // Actualizar todos los datos después de eliminar juego
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        // showStatusMessage('Juego eliminado', 'success');
      } catch (error) {
        console.error('Error deleting game:', error);
        showStatusMessage('Error al eliminar juego: ' + error.message, 'error');
      }
    }

    // Funciones de edición de niños
    function editChild(childId) {
      const child = childrenCache.find(c => c.id === childId);
      if (!child) {
        showStatusMessage('Niño no encontrado', 'error');
        return;
      }

      currentEditChild = childId;
      
      // Llenar el modal con los datos actuales (usando nombres correctos del backend)
      document.getElementById('editChildName').value = child.name || '';
      document.getElementById('editChildNickname').value = child.nickname || '';
      document.getElementById('editFatherName').value = (child.father_name || child.fatherName) || '';
      document.getElementById('editMotherName').value = (child.mother_name || child.motherName) || '';
      
      // Mostrar el modal
      document.getElementById('editChildModal').classList.add('show');
    }

    function closeEditChildModal() {
      document.getElementById('editChildModal').classList.remove('show');
      currentEditChild = null;
    }

    async function confirmEditChild() {
      if (!currentEditChild) {
        showStatusMessage('No hay niño seleccionado para editar', 'error');
        return;
      }

      const name = document.getElementById('editChildName').value.trim();
      const nickname = document.getElementById('editChildNickname').value.trim();
      const fatherName = document.getElementById('editFatherName').value.trim();
      const motherName = document.getElementById('editMotherName').value.trim();
      
      if (!name || name.trim().length < 2) {
        showStatusMessage('El nombre del niño debe tener al menos 2 caracteres', 'error');
        return;
      }
      
      try {
        const res = await fetchWithRetry(`${api}/children/${currentEditChild}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            name,
            nickname: nickname || null,
            fatherName: fatherName || null,
            motherName: motherName || null
          })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al editar niño');
        }
        
        // Actualizar todos los datos después de editar niño
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        
        closeEditChildModal();
        showStatusMessage('Información del niño actualizada', 'success');
      } catch (error) {
        console.error('Error editing child:', error);
        showStatusMessage('Error al editar niño: ' + error.message, 'error');
      }
    }

    // Inicialización ROBUSTA
    // Función para migrar niños existentes (DESHABILITADA - endpoint no existe)
    async function migrateExistingChildren() {
      try {
        console.log('Migration function called but disabled - endpoint does not exist');
        // const response = await fetch('/children/migrate', { method: 'POST' });
        // const result = await response.json();
        
        // if (result.migrated > 0) {
        //   console.log(`Migrated ${result.migrated} children with new display IDs`);
        //   await fetchChildren(); // Recargar la lista
        // }
      } catch (error) {
        console.error('Error migrating children:', error);
      }
    }

    async function initializeApp() {
      if (isInitialized) return;
      
      try {
        console.log('Initializing app...');
        console.log('API endpoint:', api);
        
        // Test de conectividad primero
        try {
          const testResponse = await fetch(api + '/admin/status');
          if (testResponse.ok) {
            const status = await testResponse.json();
            console.log('Server status:', status);
            console.log('Server has', status.children, 'children,', status.games, 'games,', status.activeSessions, 'active sessions');
          } else {
            console.error('Server not responding:', testResponse.status);
          }
        } catch (error) {
          console.error('Cannot connect to server:', error);
        }
        
        // SINCRONIZACIÓN COMPLETA - Limpiar todo y recargar
        console.log('Starting complete data synchronization...');
        
        // Limpiar todos los caches primero
        childrenCache = [];
        gamesCache = [];
        activeSessionsData = [];
        
        // Cargar datos secuencialmente para mejor debugging
        try {
          console.log('Loading children with force refresh...');
          await fetchChildren(true); // Force refresh
          
          // Verificar si se cargaron todos los niños
          console.log('Children loaded, checking cache...');
          console.log('Current childrenCache length:', childrenCache.length);
        } catch (error) {
          console.error('Failed to load children, continuing...', error);
        }
        
        try {
          console.log('Loading games with fresh data...');
          await fetchGames(); // Ya limpia el cache internamente
          
          // Verificar consistencia de juegos
          console.log('Games loaded, checking cache...');
          console.log('Current gamesCache length:', gamesCache.length);
        } catch (error) {
          console.error('Failed to load games, continuing...', error);
        }
        
        // Migrar niños existentes si es necesario (DESHABILITADO)
        try {
          console.log('Migration disabled - endpoint does not exist');
          // await migrateExistingChildren();
        } catch (error) {
          console.error('Failed to migrate children, continuing...', error);
        }
        
        // Cargar sesiones activas
        try {
          console.log('Loading active sessions...');
          await fetchActiveSessions();
        } catch (error) {
          console.error('Failed to load active sessions, continuing...', error);
        }
        
        // Cargar historial de sesiones
        try {
          console.log('Loading session history...');
          await fetchSessionHistory();
        } catch (error) {
          console.error('Failed to load session history, continuing...', error);
        }
        
        // Cargar estadísticas del dashboard
        try {
          console.log('Loading dashboard stats...');
          await fetchDashboardStats();
          updateDashboard();
        } catch (error) {
          console.error('Failed to load dashboard stats, continuing...', error);
        }
        
             // Solicitar permisos de notificación
             try {
               console.log('Requesting notification permission...');
               await requestNotificationPermission();
             } catch (error) {
               console.error('Failed to request notification permission, continuing...', error);
             }
             
             // Inicializar sistema de búsqueda de niños
             try {
               console.log('Initializing child search system...');
               initializeChildSearch();
             } catch (error) {
               console.error('Failed to initialize child search system, continuing...', error);
        }
        
        // Configurar intervalos de actualización - Optimizados para evitar parpadeo
        // Actualizar sesiones activas cada 30 segundos para mantener datos actualizados sin parpadeo
        setInterval(fetchActiveSessions, 30000);
        
        // Actualizar historial cada 120 segundos
        setInterval(fetchSessionHistory, 120000);
        
        // Actualizar niños y juegos cada 60 segundos
        setInterval(() => {
          fetchChildren();
          fetchGames();
        }, 60000);
        
        // Limpiar timers al cerrar la página
        window.addEventListener('beforeunload', () => {
          timerIntervals.forEach(interval => clearInterval(interval));
        });
        
        isInitialized = true;
        // showStatusMessage('Aplicación cargada correctamente', 'success');
        console.log('App initialized successfully');
        
        // Ocultar todas las secciones inicialmente para evitar parpadeo
        document.querySelectorAll('.section').forEach(section => {
            section.classList.remove('active');
        });
        
        // Restaurar sección activa del localStorage
        const savedSection = localStorage.getItem('activeSection');
        if (savedSection) {
            showSection(savedSection);
        } else {
            // Si no hay sección guardada, mostrar dashboard por defecto
            localStorage.setItem('activeSection', 'dashboard');
            showSection('dashboard');
        }
      } catch (error) {
        console.error('Critical error initializing app:', error);
        showStatusMessage('Error crítico al cargar la aplicación', 'error');
      }
    }

    // Función de recuperación automática
    async function recoverFromErrors() {
      console.log('Attempting to recover from errors...');
      try {
        await initializeApp();
      } catch (error) {
        console.error('Recovery failed:', error);
        setTimeout(recoverFromErrors, 5000); // Reintentar en 5 segundos
      }
    }
    
    // Función para forzar sincronización completa
    // Función interna para debugging - no visible para usuarios
    async function forceSync() {
      console.log('Internal sync triggered...');
      try {
        childrenCache = [];
        gamesCache = [];
        
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        
        renderChildrenList(childrenCache);
        renderGamesList(gamesCache);
        updateChildSelect(childrenCache);
        updateGameSelect(gamesCache);
        
        console.log('Internal sync completed');
      } catch (error) {
        console.error('Internal sync failed:', error);
      }
    }
    
    // Sincronización automática cuando la página vuelve a ser visible
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        console.log('Page became visible, forcing sync...');
        // forceSync(); // Comentado para evitar alertas molestas
      }
    });
    
    // Sincronización cuando se enfoca la ventana
    window.addEventListener('focus', () => {
      console.log('Window focused, forcing sync...');
      // forceSync(); // Comentado para evitar alertas molestas
    });

    // Manejador de atajos de teclado
    document.addEventListener('keydown', (event) => {
      // Solo activar atajos si no se está escribiendo en un input
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
        return;
      }
      
      const key = event.key;
      if (keyboardShortcuts[key]) {
        event.preventDefault();
        keyboardShortcuts[key]();
      }
      
      // Atajo para abrir/cerrar menú móvil (tecla 'm')
      if (key === 'm' || key === 'M') {
        event.preventDefault();
        toggleMobileMenu();
      }
    });

  
    // Sistema de alertas optimizado
    let alertQueue = [];
    let alertProcessing = false;
    const MAX_ALERTS = 5; // Máximo 5 alertas simultáneas para mejor visualización
    let alertCount = 0;
    
    function showOptimizedAlert(msg, type = 'info', sessionId = null) {
      alertQueue.push({ msg, type, sessionId, timestamp: Date.now() });
      processAlertQueue();
    }
    
    function processAlertQueue() {
      if (alertProcessing || alertQueue.length === 0) return;
      
      alertProcessing = true;
      
      // Mostrar hasta MAX_ALERTS alertas
      const alertsToShow = alertQueue.splice(0, MAX_ALERTS);
      
      alertsToShow.forEach((alert, index) => {
        setTimeout(() => {
          showElegantAlert(alert.msg, alert.type, alert.sessionId);
        }, index * 200); // Espaciar alertas por 200ms para mejor visualización
      });
      
      // Si quedan alertas en la cola, procesarlas después
      if (alertQueue.length > 0) {
        setTimeout(() => {
          alertProcessing = false;
          processAlertQueue();
        }, MAX_ALERTS * 200 + 1000);
      } else {
        alertProcessing = false;
      }
    }
    
    // Función para agrupar alertas similares
    function groupSimilarAlerts() {
      const grouped = {};
      alertQueue.forEach(alert => {
        const key = alert.msg.replace(/\d+/g, 'X'); // Reemplazar números con X
        if (!grouped[key]) {
          grouped[key] = { count: 0, alert };
        }
        grouped[key].count++;
      });
      
      alertQueue = [];
      Object.values(grouped).forEach(group => {
        if (group.count > 1) {
          alertQueue.push({
            msg: group.alert.msg.replace('para', 'para ' + group.count + ' niños'),
            type: group.alert.type,
            sessionId: group.alert.sessionId
          });
        } else {
          alertQueue.push(group.alert);
        }
      });
    }
    // Sistema de timers optimizado
    let timerUpdateInterval = null;
    const TIMER_UPDATE_FREQUENCY = 2000; // Actualizar cada 2 segundos en lugar de cada segundo
    
    function startOptimizedTimers() {
      // Limpiar timers de sesiones que ya no existen
      const currentSessionIds = activeSessionsData.map(s => s.id);
      timerIntervals.forEach((interval, sessionId) => {
        if (!currentSessionIds.includes(sessionId)) {
          clearInterval(interval);
          timerIntervals.delete(sessionId);
        }
      });
      
      // Crear timers solo para sesiones nuevas
      activeSessionsData.forEach(s => {
        if (!timerIntervals.has(s.id)) {
          let startTime = s.start || s.startTime || Date.now();
          if (typeof startTime === 'string') {
            startTime = new Date(startTime).getTime();
          }
          updateTimer(s.id, startTime, s.duration);
          const interval = setInterval(() => updateTimer(s.id, startTime, s.duration), TIMER_UPDATE_FREQUENCY);
          timerIntervals.set(s.id, interval);
        }
      });
    }
    
    // Función para actualizar timers en lote
    function batchUpdateTimers() {
      const list = document.getElementById('activeSessions');
      if (!list) return;
      
      const timerElements = list.querySelectorAll('.timer');
      timerElements.forEach(timerElement => {
        const sessionId = parseInt(timerElement.closest('[data-session-id]')?.dataset.sessionId);
        if (sessionId && activeSessionsData.find(s => s.id === sessionId)) {
          const session = activeSessionsData.find(s => s.id === sessionId);
          if (session) {
            updateTimerElement(timerElement, session);
          }
        }
      });
    }
    // Polling optimizado - menos frecuente cuando hay muchas sesiones
    function getOptimalPollingInterval() {
      const sessionCount = activeSessionsData.length;
      if (sessionCount > 500) return 30000; // 30 segundos
      if (sessionCount > 100) return 15000; // 15 segundos
      return 10000; // 10 segundos por defecto
    }
    
    function startOptimizedPolling() {
      const interval = setInterval(async () => {
        try {
          await fetchActiveSessions();
          await fetchSessionHistory();
        } catch (error) {
          console.error('Error en polling optimizado:', error);
        }
      }, getOptimalPollingInterval());
      
      return interval;
    }

    // Estado global para controlar la aplicación
    const AppState = {
      isInitialized: false,
      isStartingSession: false,
      formValues: {
        selectedChildId: '',
        gameId: '',
        duration: 0
      }
    };

    // Función para capturar valores del formulario de forma segura
    function captureFormValues() {
      const selectedChildId = document.getElementById('selectedChildId')?.value || '';
      const gameId = document.getElementById('gameSelect')?.value || '';
      const durationInput = document.getElementById('durationInput')?.value || '';
      
      AppState.formValues = {
        selectedChildId,
        gameId,
        duration: parseInt(durationInput) || 0
      };
      
      return AppState.formValues;
    }

    // ============================================================================
    // API ADAPTER PATTERN - Senior Level Implementation
    // ============================================================================
    
    /**
     * Adapter para transformar datos del frontend al formato esperado por la API
     * Implementa el patrón Adapter para desacoplar la lógica de negocio
     */
    class SessionAPIAdapter {
      /**
       * Transforma los datos del formulario al formato de la API
       * @param {Object} formData - Datos del formulario
       * @returns {Object} - Datos en formato API
       */
      static transformToAPIFormat(formData) {
        return {
          child_id: formData.selectedChildId,
          game_id: formData.gameId,
          duration: parseInt(formData.duration, 10)
        };
      }
      
      /**
       * Valida los datos antes de enviarlos a la API
       * @param {Object} formData - Datos del formulario
       * @returns {Object} - Resultado de la validación
       */
      static validateFormData(formData) {
        const errors = [];
        
        if (!formData.selectedChildId || formData.selectedChildId.trim() === '') {
          errors.push('Por favor seleccione un niño');
        }
        
        if (!formData.gameId || formData.gameId.trim() === '') {
          errors.push('Por favor seleccione un juego');
        }
        
        const duration = parseInt(formData.duration, 10);
        if (isNaN(duration) || duration < 1 || duration > 180) {
          errors.push('El tiempo debe estar entre 1 y 180 minutos');
        }
        
        return {
          isValid: errors.length === 0,
          errors,
          validatedData: {
            selectedChildId: formData.selectedChildId,
            gameId: formData.gameId,
            duration
          }
        };
      }
    }
    
    /**
     * Servicio para manejo de sesiones con logging estructurado
     */
    class SessionService {
      /**
       * Inicia una nueva sesión con manejo robusto de errores
       * @param {Object} formData - Datos del formulario
       * @returns {Promise<Object>} - Resultado de la operación
       */
      static async startSession(formData) {
        const startTime = Date.now();
        
        try {
          // 1. Validación de datos
          const validation = SessionAPIAdapter.validateFormData(formData);
          if (!validation.isValid) {
            throw new Error(`Validation failed: ${validation.errors.join(', ')}`);
          }
          
          // 2. Verificación de existencia en caché
          const child = childrenCache.find(c => c.id == validation.validatedData.selectedChildId);
          const game = gamesCache.find(g => g.id == validation.validatedData.gameId);
          
          if (!child) {
            throw new Error('Child not found in cache');
          }
          
          if (!game) {
            throw new Error('Game not found in cache');
          }
          
          // 3. Transformación a formato API
          const apiData = SessionAPIAdapter.transformToAPIFormat(validation.validatedData);
          
          // 4. Logging estructurado
          console.group('🚀 Session Start Request');
          console.log('📊 Form Data:', formData);
          console.log('✅ Validation Result:', validation);
          console.log('🔄 API Data:', apiData);
          console.log('👶 Child:', { id: child.id, name: child.name });
          console.log('🎮 Game:', { id: game.id, name: game.name });
          console.groupEnd();
          
          // 5. Llamada a la API
          const response = await fetchWithRetry(api + '/sessions/start', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'X-Request-ID': `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            },
            body: JSON.stringify(apiData)
          });
          
          const responseTime = Date.now() - startTime;
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ 
              error: 'Unknown server error',
              code: 'UNKNOWN_ERROR'
            }));
            
            console.group('❌ Session Start Error');
            console.error('📊 Response Status:', response.status);
            console.error('📊 Response Headers:', Object.fromEntries(response.headers.entries()));
            console.error('📊 Error Data:', errorData);
            console.error('⏱️ Response Time:', `${responseTime}ms`);
            console.groupEnd();
            
            throw new Error(`API Error ${response.status}: ${errorData.error || 'Unknown error'}`);
          }
          
          const result = await response.json();
          
          console.group('✅ Session Start Success');
          console.log('📊 Result:', result);
          console.log('⏱️ Total Time:', `${responseTime}ms`);
          console.groupEnd();
          
          return {
            success: true,
            data: result,
            responseTime,
            child,
            game
          };
          
        } catch (error) {
          const responseTime = Date.now() - startTime;
          
          console.group('💥 Session Start Exception');
          console.error('📊 Error:', error);
          console.error('📊 Stack:', error.stack);
          console.error('⏱️ Time to Error:', `${responseTime}ms`);
          console.groupEnd();
          
          return {
            success: false,
            error: error.message,
            responseTime
          };
        }
      }
    }

    // ============================================================================
    // MAIN SESSION HANDLER - Clean Architecture Implementation
    // ============================================================================
    
    /**
     * Función principal para iniciar sesión - Arquitectura Limpia
     * Implementa el patrón Command con manejo de estado robusto
     */
    async function handleStartSession() {
      // Prevención de concurrencia
      if (AppState.isStartingSession) {
        showStatusMessage('⏳ Iniciando sesión, por favor espera...', 'warning');
        return;
      }

      AppState.isStartingSession = true;
      showLoading('startBtn', true);

      try {
        // 1. Captura de datos del formulario
        const formValues = captureFormValues();
        
        // 2. Procesamiento mediante el servicio
        const result = await SessionService.startSession(formValues);
        
        if (result.success) {
          // 3. Actualización del UI después del éxito
          await Promise.all([
            fetchActiveSessions(),
            fetchSessionHistory()
          ]);
          
          clearAllSessionAlerts();
          showStatusMessage(`✅ Sesión iniciada: ${result.child.name} - ${result.game.name}`, 'success');
        } else {
          // 4. Manejo de errores
          showStatusMessage(`❌ Error: ${result.error}`, 'error');
        }
        
      } catch (error) {
        console.error('💥 Unexpected error in handleStartSession:', error);
        showStatusMessage('❌ Error inesperado al iniciar sesión', 'error');
      } finally {
        // 5. Limpieza garantizada
        showLoading('startBtn', false);
        AppState.isStartingSession = false;
      }
    }

    // Inicialización de la aplicación
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        await initializeApp();
        AppState.isInitialized = true;
        
        // Configurar event listener del botón
        const startBtn = document.getElementById('startBtn');
        if (startBtn) {
          startBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleStartSession();
          });
        }
        
      } catch (error) {
        console.error('Failed to initialize app:', error);
        setTimeout(recoverFromErrors, 2000);
      }
    });

</script>
</body>
</html>