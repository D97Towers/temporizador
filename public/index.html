<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Temporizador de Juegos</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      color: #333;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      color: white;
      position: relative;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .sync-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }
    
    .sync-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: rotate(180deg);
    }
    
    .sync-btn:active {
      transform: rotate(360deg);
    }

    .header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(0,0,0,0.15);
    }

    .card h2 {
      color: #4a5568;
      margin-bottom: 20px;
      font-size: 1.3rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-row {
      display: flex;
      gap: 15px;
      align-items: end;
      flex-wrap: wrap;
    }

    .form-row .form-group {
      flex: 1;
      min-width: 120px;
    }

    .form-row .form-group:last-child {
      flex: 0 0 auto;
      min-width: 140px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #4a5568;
    }

    input, select, button {
      width: 100%;
      padding: 12px 15px;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      font-size: 14px;
      transition: all 0.3s ease;
      background: white;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: all 0.3s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    button:disabled {
      background: #cbd5e0;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-danger {
      background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
    }

    .btn-success {
      background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
    }

    .btn-warning {
      background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
    }

    .list {
      list-style: none;
      margin-top: 15px;
    }

    .list-item {
      background: #f7fafc;
      padding: 12px 15px;
      margin-bottom: 8px;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.3s ease;
    }

    .list-item:hover {
      background: #edf2f7;
      transform: translateX(5px);
    }

    .list-item.active {
      border-left-color: #38a169;
      background: #f0fff4;
    }

    .timer {
      font-weight: bold;
      color: #38a169;
      font-family: 'Courier New', monospace;
      font-size: 1.1rem;
      line-height: 1.3;
      text-align: center;
      min-width: 120px;
    }

    .timer.warning {
      color: #f6ad55;
    }

    .timer.danger {
      color: #e53e3e;
      animation: pulse 1s infinite;
    }

    .timer strong {
      display: block;
      font-size: 1.2rem;
      margin-bottom: 2px;
    }

    .timer small {
      font-size: 0.9rem;
      opacity: 0.8;
      font-weight: normal;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .status-message {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 20px;
      border-radius: 10px;
      color: white;
      font-weight: 600;
      z-index: 1000;
      transform: translateX(400px);
      transition: transform 0.3s ease;
    }

    .status-message.show {
      transform: translateX(0);
    }

    .status-message.success {
      background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
    }

    .status-message.error {
      background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
    }

    .status-message.warning {
      background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(5px);
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      animation: modalSlideIn 0.3s ease;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: scale(0.8) translateY(-50px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .modal h2 {
      color: #4a5568;
      margin-bottom: 20px;
      font-size: 1.5rem;
    }

    .modal p {
      font-size: 1.1rem;
      margin-bottom: 30px;
      color: #666;
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .modal-buttons button {
      flex: 1;
      max-width: 120px;
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .extend-time {
      background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
      margin-left: 5px;
      padding: 5px 10px;
      font-size: 12px;
    }

    /* Responsive Design */
    /* Sistema de alertas persistentes */
    .alert-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      max-width: 400px;
      pointer-events: none;
    }
    
    .persistent-alert {
      background: linear-gradient(135deg, #ff6b6b, #ee5a52);
      color: white;
      border-radius: 12px;
      padding: 0;
      margin-bottom: 10px;
      box-shadow: 0 8px 32px rgba(255, 107, 107, 0.3);
      transform: translateX(0);
      opacity: 1;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: auto;
      border: 2px solid rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(10px);
    }
    
    .alert-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
    }
    
    .alert-message {
      flex: 1;
      font-weight: 600;
      font-size: 14px;
      line-height: 1.4;
    }
    
    .alert-close {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      padding: 4px;
      margin-left: 12px;
      border-radius: 6px;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
    }
    
    .alert-close:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }
    
    .alert-close i {
      font-size: 12px;
    }
    
    /* Animación de entrada */
    .persistent-alert {
      animation: slideInRight 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      .header h1 {
        font-size: 2rem;
      }

      .grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .card {
        padding: 20px;
      }

      .form-row {
        flex-direction: column !important;
        gap: 10px;
        align-items: stretch !important;
      }

      .form-row .form-group {
        min-width: auto !important;
        max-width: none !important;
        flex: none !important;
        width: 100% !important;
      }

      .form-row .form-group:last-child {
        min-width: auto !important;
        max-width: none !important;
        flex: none !important;
        width: 100% !important;
      }

      input, select, button {
        width: 100% !important;
        max-width: none !important;
        font-size: 16px; /* Evita zoom en iOS */
      }
      
      /* Mejorar alertas en móviles */
      .alert-container {
        top: 10px;
        right: 10px;
        left: 10px;
        max-width: none;
      }
      
      .persistent-alert {
        margin-bottom: 8px;
      }
      
      .alert-content {
        padding: 12px 16px;
      }
      
      .alert-message {
        font-size: 13px;
      }
      
      /* Mejorar botones en móviles */
      .list-item .btn {
        padding: 8px 12px;
        font-size: 12px;
        margin: 2px;
      }

      .status-message {
        right: 10px;
        left: 10px;
        transform: translateY(-100px);
      }

      .status-message.show {
        transform: translateY(0);
      }
    }

    @media (max-width: 480px) {
      .header h1 {
        font-size: 1.8rem;
      }

      .card {
        padding: 15px;
      }

      .modal-content {
        padding: 30px 20px;
      }

      .form-row {
        flex-direction: column !important;
        gap: 8px;
      }

      .form-row .form-group {
        width: 100% !important;
        flex: none !important;
      }

      input, select, button {
        width: 100% !important;
        padding: 10px 12px;
        font-size: 14px;
      }
    }

    /* Regla específica para pantallas muy pequeñas */
    @media (max-width: 360px) {
      .form-row {
        flex-direction: column !important;
        gap: 5px;
      }

      .form-row .form-group {
        width: 100% !important;
        margin-bottom: 10px;
      }

      input, select, button {
        width: 100% !important;
        padding: 8px 10px;
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1><i class="fas fa-gamepad"></i> Temporizador de Juegos</h1>
      <p>Controla el tiempo de juego de los niños de forma divertida</p>
      <!-- Deployment trigger: v1.1 - All visual errors fixed -->
      <button class="sync-btn" onclick="forceSync()" title="Sincronizar datos">
        <i class="fas fa-sync-alt"></i>
      </button>
    </div>

    <div class="grid">
      <!-- Registrar Niño -->
      <div class="card">
        <h2><i class="fas fa-child"></i> Registrar Niño</h2>
        <div class="form-row">
          <div class="form-group">
            <input type="text" id="childName" placeholder="Nombre del niño" maxlength="50">
          </div>
          <div class="form-group">
            <button onclick="addChild()" id="addChildBtn">
              <i class="fas fa-plus"></i> Agregar Niño
            </button>
          </div>
        </div>
        <ul class="list" id="childrenList"></ul>
      </div>

      <!-- Registrar Juego -->
      <div class="card">
        <h2><i class="fas fa-dice"></i> Registrar Juego</h2>
        <div class="form-row">
          <div class="form-group">
            <input type="text" id="gameName" placeholder="Nombre del juego" maxlength="50">
          </div>
          <div class="form-group">
            <button onclick="addGame()" id="addGameBtn">
              <i class="fas fa-plus"></i> Agregar Juego
            </button>
          </div>
        </div>
        <ul class="list" id="gamesList"></ul>
      </div>

      <!-- Iniciar Sesión -->
      <div class="card">
        <h2><i class="fas fa-play-circle"></i> Iniciar Sesión de Juego</h2>
        <div class="form-group">
          <label><i class="fas fa-user"></i> Niño:</label>
          <select id="childSelect">
            <option value="">Seleccione un niño</option>
          </select>
        </div>
        <div class="form-group">
          <label><i class="fas fa-gamepad"></i> Juego:</label>
          <select id="gameSelect">
            <option value="">Seleccione un juego</option>
          </select>
        </div>
        <div class="form-group">
          <label><i class="fas fa-clock"></i> Tiempo (minutos):</label>
          <input type="number" id="durationInput" min="1" max="180" value="15">
        </div>
        <button onclick="startSession()" id="startBtn">
          <i class="fas fa-play"></i> Iniciar Sesión
        </button>
      </div>

      <!-- Sesiones Activas -->
      <div class="card">
        <h2><i class="fas fa-stopwatch"></i> Sesiones Activas</h2>
        <ul class="list" id="activeSessions">
          <li class="list-item">Cargando sesiones activas...</li>
        </ul>
      </div>

      <!-- Historial -->
      <div class="card">
        <h2><i class="fas fa-history"></i> Historial de Sesiones</h2>
        <ul class="list" id="sessionHistory"></ul>
      </div>
    </div>
  </div>

  <!-- Status Message -->
  <div id="statusMessage" class="status-message"></div>

  <!-- Modal -->
  <div id="customModal" class="modal">
    <div class="modal-content">
      <h2 id="modalTitle"><i class="fas fa-bell"></i> ¡Tiempo terminado!</h2>
      <p id="modalMsg"></p>
      <button onclick="closeModal()" class="btn-success">
        <i class="fas fa-check"></i> Entendido
      </button>
    </div>
  </div>

  <!-- Modal de Extensión de Tiempo -->
  <div id="extendModal" class="modal">
    <div class="modal-content">
      <h2><i class="fas fa-clock"></i> Extender Tiempo</h2>
      <p id="extendMsg"></p>
      <div class="form-group">
        <label>Tiempo adicional (minutos):</label>
        <input type="number" id="extendTimeInput" min="1" max="60" value="5">
      </div>
      <div class="modal-buttons">
        <button onclick="confirmExtendTime()" class="btn-success">
          <i class="fas fa-plus"></i> Extender
        </button>
        <button onclick="closeExtendModal()" class="btn-danger">
          <i class="fas fa-times"></i> Cancelar
        </button>
      </div>
    </div>
  </div>

  <script>
    const api = window.location.origin;

    // Estado de la aplicación - ROBUSTO
    let isLoading = false;
    let activeSessionsData = [];
    let childrenCache = [];
    let gamesCache = [];
    let timerIntervals = new Map();
    let currentExtendSession = null;
    let isInitialized = false;
    let isFirstLoad = true;

    // Utilidades mejoradas
    function showStatusMessage(text, type = 'success') {
      const msg = document.getElementById('statusMessage');
      msg.textContent = text;
      msg.className = `status-message ${type} show`;
      setTimeout(() => {
        msg.classList.remove('show');
      }, 4000);
    }

    function showLoading(buttonId, show = true) {
      const button = document.getElementById(buttonId);
      if (!button) return;
      
      if (show) {
        button.disabled = true;
        button.innerHTML = '<div class="loading"></div> Procesando...';
      } else {
        button.disabled = false;
        // Restaurar texto original basado en el botón
        if (buttonId === 'addChildBtn') {
          button.innerHTML = '<i class="fas fa-plus"></i> Agregar Niño';
        } else if (buttonId === 'addGameBtn') {
          button.innerHTML = '<i class="fas fa-plus"></i> Agregar Juego';
        } else if (buttonId === 'startBtn') {
          button.innerHTML = '<i class="fas fa-play"></i> Iniciar Sesión';
        }
      }
    }

    // Sistema de alertas mejorado
    function showCustomModal(msg) {
      // Crear alerta persistente en la esquina
      const alertContainer = document.getElementById('alertContainer') || createAlertContainer();
      
      const alertId = 'alert-' + Date.now();
      const alert = document.createElement('div');
      alert.id = alertId;
      alert.className = 'persistent-alert';
      alert.innerHTML = `
        <div class="alert-content">
          <span class="alert-message">${msg}</span>
          <button class="alert-close" onclick="closeAlert('${alertId}')">
            <i class="fas fa-times"></i>
          </button>
        </div>
      `;
      
      alertContainer.appendChild(alert);
      
      // Auto-remover después de 30 segundos si no se cierra manualmente
      setTimeout(() => {
        if (document.getElementById(alertId)) {
          closeAlert(alertId);
        }
      }, 30000);
    }
    
    function createAlertContainer() {
      const container = document.createElement('div');
      container.id = 'alertContainer';
      container.className = 'alert-container';
      document.body.appendChild(container);
      return container;
    }
    
    function closeAlert(alertId) {
      const alert = document.getElementById(alertId);
      if (alert) {
        alert.style.opacity = '0';
        alert.style.transform = 'translateX(100%)';
        setTimeout(() => {
          alert.remove();
        }, 300);
      }
    }

    function closeModal() {
      document.getElementById('customModal').classList.remove('show');
    }

    function showExtendModal(sessionId, childName) {
      currentExtendSession = sessionId;
      document.getElementById('extendMsg').textContent = `¿Cuánto tiempo adicional quiere darle a ${childName}?`;
      document.getElementById('extendTimeInput').value = 5;
      document.getElementById('extendModal').classList.add('show');
    }

    function closeExtendModal() {
      document.getElementById('extendModal').classList.remove('show');
      currentExtendSession = null;
    }

    // Validaciones ROBUSTAS
    function validateName(name, type) {
      if (!name || name.trim().length === 0) {
        showStatusMessage(`Por favor ingrese el ${type}`, 'error');
        return false;
      }
      if (name.trim().length < 2) {
        showStatusMessage(`El ${type} debe tener al menos 2 caracteres`, 'error');
        return false;
      }
      if (name.trim().length > 50) {
        showStatusMessage(`El ${type} no puede tener más de 50 caracteres`, 'error');
        return false;
      }
      return true;
    }

    function validateSession(childId, gameId, duration) {
      if (!childId) {
        showStatusMessage('Por favor seleccione un niño', 'error');
        return false;
      }
      if (!gameId) {
        showStatusMessage('Por favor seleccione un juego', 'error');
        return false;
      }
      if (isNaN(duration)) {
        showStatusMessage('El tiempo debe ser un número válido', 'error');
        return false;
      }
      if (duration < 1) {
        showStatusMessage('El tiempo mínimo es 1 minuto', 'error');
        return false;
      }
      if (duration > 180) {
        showStatusMessage('El tiempo máximo es 180 minutos', 'error');
        return false;
      }
      return true;
    }

    // Funciones de fetch ROBUSTAS con reintentos
    async function fetchWithRetry(url, options = {}, retries = 3) {
      for (let i = 0; i < retries; i++) {
        try {
          const res = await fetch(url, options);
          if (res.ok) {
            return res;
          }
          if (i === retries - 1) {
            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          }
        } catch (error) {
          if (i === retries - 1) {
            throw error;
          }
          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
      }
    }

    async function fetchChildren() {
      try {
        console.log('Fetching children from:', api + '/children');
        const res = await fetchWithRetry(api + '/children');
        console.log('Children response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const children = await res.json();
        console.log('Children data received:', children);
        
        childrenCache = children || [];
        renderChildrenList(childrenCache);
        updateChildSelect(childrenCache);
        console.log('Children loaded successfully:', childrenCache);
      } catch (error) {
        console.error('Error fetching children:', error);
        showStatusMessage('Error al cargar la lista de niños', 'error');
        childrenCache = [];
        renderChildrenList([]);
        updateChildSelect([]);
        throw error; // Re-throw para que initializeApp pueda manejarlo
      }
    }

    async function fetchGames() {
      try {
        console.log('Fetching games from:', api + '/games');
        const res = await fetchWithRetry(api + '/games');
        console.log('Games response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const games = await res.json();
        console.log('Games data received:', games);
        
        gamesCache = games || [];
        renderGamesList(gamesCache);
        updateGameSelect(gamesCache);
        console.log('Games loaded successfully:', gamesCache);
      } catch (error) {
        console.error('Error fetching games:', error);
        showStatusMessage('Error al cargar la lista de juegos', 'error');
        gamesCache = [];
        renderGamesList([]);
        updateGameSelect([]);
        throw error; // Re-throw para que initializeApp pueda manejarlo
      }
    }

    function renderChildrenList(children) {
      const list = document.getElementById('childrenList');
      if (!list) return;
      
      if (!children || children.length === 0) {
        list.innerHTML = '<li class="list-item">No hay niños registrados</li>';
        return;
      }
      list.innerHTML = children.map(child => 
        `<li class="list-item">
          <span><i class="fas fa-child"></i> ${child.name}</span>
          <button onclick="deleteChild(${child.id})" class="btn-danger" style="padding: 5px 10px; font-size: 12px;">
            <i class="fas fa-trash"></i>
          </button>
        </li>`
      ).join('');
    }

    function renderGamesList(games) {
      const list = document.getElementById('gamesList');
      if (!list) return;
      
      if (!games || games.length === 0) {
        list.innerHTML = '<li class="list-item">No hay juegos registrados</li>';
        return;
      }
      list.innerHTML = games.map(game => 
        `<li class="list-item">
          <span><i class="fas fa-dice"></i> ${game.name}</span>
          <button onclick="deleteGame(${game.id})" class="btn-danger" style="padding: 5px 10px; font-size: 12px;">
            <i class="fas fa-trash"></i>
          </button>
        </li>`
      ).join('');
    }

    function updateChildSelect(children) {
      const select = document.getElementById('childSelect');
      if (!select) return;
      
      select.innerHTML = '<option value="">Seleccione un niño</option>' +
        (children || []).map(child => `<option value="${child.id}">${child.name}</option>`).join('');
    }

    function updateGameSelect(games) {
      const select = document.getElementById('gameSelect');
      if (!select) return;
      
      select.innerHTML = '<option value="">Seleccione un juego</option>' +
        (games || []).map(game => `<option value="${game.id}">${game.name}</option>`).join('');
    }

    // Funciones de sesiones activas ROBUSTAS
    async function fetchActiveSessions() {
      try {
        console.log('Fetching active sessions from:', api + '/sessions/active');
        const res = await fetchWithRetry(api + '/sessions/active');
        console.log('Active sessions response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const newActiveSessionsData = await res.json() || [];
        console.log('Active sessions data received:', newActiveSessionsData);
        
        // Solo actualizar si hay cambios reales en los datos
        const hasChanges = JSON.stringify(newActiveSessionsData) !== JSON.stringify(activeSessionsData);
        
        if (hasChanges || isFirstLoad) {
          activeSessionsData = newActiveSessionsData;
          renderActiveSessions();
          console.log('Active sessions updated:', activeSessionsData.length, 'sessions');
          isFirstLoad = false;
        } else {
          // Solo actualizar timers sin recrear DOM
          updateExistingTimers();
        }
      } catch (error) {
        console.error('Error fetching active sessions:', error);
        
        // NO resetear las sesiones activas en caso de error
        // Solo mostrar un mensaje de error discreto
        console.warn('Failed to fetch active sessions, keeping current data');
        
        // Solo actualizar timers con datos existentes
        if (activeSessionsData.length > 0) {
          updateExistingTimers();
        }
        
        // No mostrar error al usuario para evitar confusión
        // showStatusMessage('Error al cargar sesiones activas', 'error');
        
        // No re-throw para evitar que se resetee todo
        // throw error;
      }
    }

    function renderActiveSessions() {
      const list = document.getElementById('activeSessions');
      if (!list) return;
      
      // Evitar parpadeo: solo actualizar si hay cambios reales
      const currentContent = list.innerHTML;
      const newContent = generateActiveSessionsHTML();
      
      if (currentContent !== newContent) {
        // Usar requestAnimationFrame con delay para suavizar la actualización
        requestAnimationFrame(() => {
          setTimeout(() => {
            list.innerHTML = newContent;
            startTimers();
            console.log('Active sessions rendered:', activeSessionsData.length, 'sessions');
          }, 100); // Pequeño delay para evitar parpadeos
        });
      } else {
        // Si no hay cambios en el contenido, solo actualizar timers
        updateExistingTimers();
      }
    }
    
    function generateActiveSessionsHTML() {
      if (!activeSessionsData || activeSessionsData.length === 0) {
        return '<li class="list-item">No hay sesiones activas</li>';
      }
      
      return activeSessionsData.map(s => {
        const child = childrenCache.find(c => c.id === s.childId);
        const game = gamesCache.find(g => g.id === s.gameId);
        
        // Usar nombres reales, si no se encuentran, mostrar "Desconocido"
        const childName = child ? child.name : 'Niño desconocido';
        const gameName = game ? game.name : 'Juego desconocido';
        
        return `<li class="list-item active" id="session-${s.id}">
          <div>
            <strong><i class="fas fa-child"></i> ${childName}</strong><br>
            <small><i class="fas fa-gamepad"></i> ${gameName}</small><br>
            <small><i class="fas fa-clock"></i> Duración: ${s.duration} min</small>
          </div>
          <div style="text-align: right;">
            <div class="timer" id="timer-${s.id}">Calculando...</div>
            <div style="margin-top: 5px;">
              <button class="btn-danger" onclick="endSession(${s.id})" style="padding: 5px 10px; font-size: 12px; margin-right: 5px;">
                <i class="fas fa-stop"></i> Finalizar
              </button>
              <button class="extend-time" onclick="showExtendModal(${s.id}, '${childName}')" style="padding: 5px 10px; font-size: 12px;">
                <i class="fas fa-plus"></i> +5min
              </button>
            </div>
          </div>
        </li>`;
      }).join('');
    }
    
    function updateExistingTimers() {
      // Solo actualizar timers existentes sin recrear el DOM
      activeSessionsData.forEach(s => {
        if (timerIntervals.has(s.id)) {
          updateTimer(s.id, s.start, s.duration);
        }
      });
    }

    function startTimers() {
      // Limpiar timers de sesiones que ya no existen
      const currentSessionIds = activeSessionsData.map(s => s.id);
      timerIntervals.forEach((interval, sessionId) => {
        if (!currentSessionIds.includes(sessionId)) {
          clearInterval(interval);
          timerIntervals.delete(sessionId);
        }
      });

      // Crear timers solo para sesiones nuevas
      activeSessionsData.forEach(s => {
        if (!timerIntervals.has(s.id)) {
          updateTimer(s.id, s.start, s.duration);
          const interval = setInterval(() => updateTimer(s.id, s.start, s.duration), 1000);
          timerIntervals.set(s.id, interval);
        }
      });
    }

    function updateTimer(sessionId, startTime, duration) {
      const timerSpan = document.getElementById(`timer-${sessionId}`);
      if (!timerSpan) return;
      
      const now = Date.now();
      const diff = Math.floor((now - startTime) / 1000);
      const total = duration * 60;
      const left = total - diff;
      
      const h = String(Math.floor(left / 3600)).padStart(2, '0');
      const m = String(Math.floor((left % 3600) / 60)).padStart(2, '0');
      const s = String(left % 60).padStart(2, '0');
      
      // Calcular tiempo transcurrido para mostrar también
      const elapsed = Math.floor(diff / 60);
      const elapsedSeconds = diff % 60;
      
      // Actualizar clases según el tiempo restante
      timerSpan.className = 'timer';
      if (left <= 0) {
        timerSpan.textContent = '⏰ ¡Tiempo terminado!';
        timerSpan.classList.add('danger');
        if (!timerSpan.classList.contains('alerted')) {
          timerSpan.classList.add('alerted');
          const session = activeSessionsData.find(s => s.id === sessionId);
          const child = childrenCache.find(c => c.id === session.childId);
          showCustomModal(`¡Se acabó el tiempo para ${child ? child.name : 'este niño'}!`);
          endSession(sessionId);
        }
      } else if (left <= 60) {
        timerSpan.innerHTML = `⚠️ <strong>Restante:</strong> ${m}:${s}<br><small>Transcurrido: ${elapsed}:${String(elapsedSeconds).padStart(2, '0')}</small>`;
        timerSpan.classList.add('warning');
        // Alerta cuando quedan 30 segundos
        if (left <= 30 && !timerSpan.classList.contains('alerted-30')) {
          timerSpan.classList.add('alerted-30');
          const session = activeSessionsData.find(s => s.id === sessionId);
          const child = childrenCache.find(c => c.id === session.childId);
          showStatusMessage(`¡Atención! A ${child ? child.name : 'este niño'} le quedan solo ${left} segundos`, 'warning');
        }
      } else {
        timerSpan.innerHTML = `⏱️ <strong>Restante:</strong> ${h}:${m}:${s}<br><small>Transcurrido: ${elapsed}:${String(elapsedSeconds).padStart(2, '0')}</small>`;
      }
    }

    async function fetchSessionHistory() {
      try {
        console.log('Fetching session history from:', api + '/sessions');
        const res = await fetchWithRetry(api + '/sessions');
        console.log('Session history response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const sessions = await res.json() || [];
        console.log('Session history data received:', sessions);
        
        renderSessionHistory(sessions);
        console.log('Session history loaded successfully:', sessions);
      } catch (error) {
        console.error('Error fetching session history:', error);
        showStatusMessage('Error al cargar historial de sesiones', 'error');
        renderSessionHistory([]);
        throw error; // Re-throw para que initializeApp pueda manejarlo
      }
    }

    function renderSessionHistory(sessions) {
      const list = document.getElementById('sessionHistory');
      if (!list) return;
      
      if (!sessions || sessions.length === 0) {
        list.innerHTML = '<li class="list-item">No hay sesiones registradas</li>';
        return;
      }
      
      // Asegurar que tenemos datos de niños y juegos antes de renderizar
      if (childrenCache.length === 0 || gamesCache.length === 0) {
        console.log('Missing cache data, refreshing...');
        fetchChildren().then(() => fetchGames()).then(() => {
          // Re-renderizar con datos actualizados
          renderSessionHistory(sessions);
        });
        return;
      }
      
      list.innerHTML = sessions.map(s => {
        const child = childrenCache.find(c => c.id === s.childId);
        const game = gamesCache.find(g => g.id === s.gameId);
        
        // Usar nombres reales, si no se encuentran, mostrar "Desconocido"
        const childName = child ? child.name : 'Niño desconocido';
        const gameName = game ? game.name : 'Juego desconocido';
        
        const startTime = new Date(s.start).toLocaleString('es-ES', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });
        
        let endTime, duration, statusClass, statusText;
        
        if (s.end) {
          // Sesión finalizada
          endTime = new Date(s.end).toLocaleString('es-ES', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          });
          duration = Math.round((s.end - s.start) / 60000);
          statusClass = '';
          statusText = `${duration} min`;
        } else {
          // Sesión en curso
          const currentTime = Date.now();
          const elapsedMinutes = Math.round((currentTime - s.start) / 60000);
          const totalMinutes = s.duration || 15; // Usar duración programada o 15 por defecto
          const remainingMinutes = Math.max(0, totalMinutes - elapsedMinutes);
          
          endTime = 'En curso';
          statusClass = 'active';
          statusText = `${elapsedMinutes}/${totalMinutes} min`;
        }
        
        return `<li class="list-item ${statusClass}">
          <div>
            <strong><i class="fas fa-child"></i> ${childName}</strong><br>
            <small><i class="fas fa-gamepad"></i> ${gameName}</small><br>
            <small><i class="fas fa-clock"></i> ${statusText}</small>
          </div>
          <div style="text-align: right; font-size: 0.9em; color: #666;">
            <div><i class="fas fa-play"></i> ${startTime}</div>
            <div><i class="fas fa-stop"></i> ${endTime}</div>
          </div>
        </li>`;
      }).join('');
    }

    // Funciones principales ROBUSTAS
    async function addChild() {
      const name = document.getElementById('childName').value.trim();
      if (!validateName(name, 'nombre del niño')) return;
      
      showLoading('addChildBtn', true);
      try {
        const res = await fetchWithRetry(api + '/children', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al agregar niño');
        }
        
        document.getElementById('childName').value = '';
        // Actualizar todos los datos después de agregar niño
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        showStatusMessage('Niño agregado exitosamente', 'success');
      } catch (error) {
        console.error('Error adding child:', error);
        showStatusMessage(`Error al agregar niño: ${error.message}`, 'error');
      } finally {
        showLoading('addChildBtn', false);
      }
    }

    async function addGame() {
      const name = document.getElementById('gameName').value.trim();
      if (!validateName(name, 'nombre del juego')) return;
      
      showLoading('addGameBtn', true);
      try {
        const res = await fetchWithRetry(api + '/games', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al agregar juego');
        }
        
        document.getElementById('gameName').value = '';
        // Actualizar todos los datos después de agregar juego
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        showStatusMessage('Juego agregado exitosamente', 'success');
      } catch (error) {
        console.error('Error adding game:', error);
        showStatusMessage(`Error al agregar juego: ${error.message}`, 'error');
      } finally {
        showLoading('addGameBtn', false);
      }
    }

    async function startSession() {
      const childId = document.getElementById('childSelect').value;
      const gameId = document.getElementById('gameSelect').value;
      const durationInput = document.getElementById('durationInput').value;
      
      // Validar que el input no esté vacío y parsear correctamente
      if (!durationInput || durationInput.trim() === '') {
        showStatusMessage('Por favor ingrese un tiempo válido', 'error');
        return;
      }
      
      const duration = parseInt(durationInput.trim());
      
      console.log('Starting session:', { childId, gameId, duration, originalInput: durationInput });
      
      if (!validateSession(childId, gameId, duration)) return;
      
      // Verificar que el niño y juego existen en el caché
      const child = childrenCache.find(c => c.id == childId);
      const game = gamesCache.find(g => g.id == gameId);
      
      if (!child) {
        showStatusMessage('Error: Niño no encontrado en la lista', 'error');
        await fetchChildren(); // Recargar datos
        return;
      }
      
      if (!game) {
        showStatusMessage('Error: Juego no encontrado en la lista', 'error');
        await fetchGames(); // Recargar datos
        return;
      }
      
      showLoading('startBtn', true);
      try {
        const requestBody = { 
          childId: Number(childId), 
          gameId: Number(gameId), 
          duration: Number(duration) 
        };
        
        console.log('Request body:', requestBody);
        
        const res = await fetchWithRetry(api + '/sessions/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });
        
        console.log('Response status:', res.status);
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al iniciar sesión');
        }
        
        const result = await res.json();
        console.log('Session started:', result);
        
        // Actualizar datos inmediatamente después de iniciar sesión
        await Promise.all([
          fetchActiveSessions(),
          fetchSessionHistory(),
          fetchChildren(), // Asegurar datos actualizados
          fetchGames()
        ]);
        showStatusMessage('Sesión iniciada exitosamente', 'success');
      } catch (error) {
        console.error('Error starting session:', error);
        showStatusMessage(`Error al iniciar sesión: ${error.message}`, 'error');
      } finally {
        showLoading('startBtn', false);
      }
    }

    async function endSession(sessionId) {
      try {
        const res = await fetchWithRetry(api + '/sessions/end', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al finalizar sesión');
        }
        
        // Limpiar timer
        if (timerIntervals.has(sessionId)) {
          clearInterval(timerIntervals.get(sessionId));
          timerIntervals.delete(sessionId);
        }
        
        // Actualizar datos inmediatamente después de finalizar sesión
        await Promise.all([
          fetchActiveSessions(),
          fetchSessionHistory(),
          fetchChildren(), // Asegurar datos actualizados
          fetchGames()
        ]);
        showStatusMessage('Sesión finalizada', 'success');
      } catch (error) {
        console.error('Error ending session:', error);
        showStatusMessage(`Error al finalizar sesión: ${error.message}`, 'error');
      }
    }

    // Función para extender tiempo ROBUSTA
    async function confirmExtendTime() {
      if (!currentExtendSession) {
        showStatusMessage('No hay sesión seleccionada para extender', 'error');
        return;
      }
      
      const additionalTime = parseInt(document.getElementById('extendTimeInput').value);
      if (isNaN(additionalTime) || additionalTime < 1 || additionalTime > 60) {
        showStatusMessage('El tiempo adicional debe estar entre 1 y 60 minutos', 'error');
        return;
      }
      
      // Verificar que la sesión aún existe
      const session = activeSessionsData.find(s => s.id === currentExtendSession);
      if (!session) {
        showStatusMessage('La sesión ya no está activa', 'error');
        closeExtendModal();
        return;
      }
      
      try {
        console.log('Extending session:', currentExtendSession, 'by', additionalTime, 'minutes');
        
        const res = await fetchWithRetry(api + '/sessions/extend', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            sessionId: currentExtendSession, 
            additionalTime: additionalTime 
          })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al extender tiempo');
        }
        
        const result = await res.json();
        console.log('Time extended successfully:', result);
        
        closeExtendModal();
        
        // Actualizar datos inmediatamente
        await Promise.all([
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        
        showStatusMessage(`Tiempo extendido ${additionalTime} minutos correctamente`, 'success');
      } catch (error) {
        console.error('Error extending time:', error);
        showStatusMessage(`Error al extender tiempo: ${error.message}`, 'error');
      }
    }

    // Funciones de eliminación ROBUSTAS
    async function deleteChild(childId) {
      if (!confirm('¿Está seguro de que desea eliminar este niño?')) return;
      
      try {
        const res = await fetchWithRetry(`${api}/children/${childId}`, {
          method: 'DELETE'
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al eliminar niño');
        }
        
        // Actualizar todos los datos después de eliminar niño
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        showStatusMessage('Niño eliminado', 'success');
      } catch (error) {
        console.error('Error deleting child:', error);
        showStatusMessage(`Error al eliminar niño: ${error.message}`, 'error');
      }
    }

    async function deleteGame(gameId) {
      if (!confirm('¿Está seguro de que desea eliminar este juego?')) return;
      
      try {
        const res = await fetchWithRetry(`${api}/games/${gameId}`, {
          method: 'DELETE'
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al eliminar juego');
        }
        
        // Actualizar todos los datos después de eliminar juego
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        showStatusMessage('Juego eliminado', 'success');
      } catch (error) {
        console.error('Error deleting game:', error);
        showStatusMessage(`Error al eliminar juego: ${error.message}`, 'error');
      }
    }

    // Inicialización ROBUSTA
    async function initializeApp() {
      if (isInitialized) return;
      
      try {
        console.log('Initializing app...');
        
        // Cargar datos secuencialmente para mejor debugging
        try {
          console.log('Loading children...');
          await fetchChildren();
        } catch (error) {
          console.error('Failed to load children, continuing...', error);
        }
        
        try {
          console.log('Loading games...');
          await fetchGames();
        } catch (error) {
          console.error('Failed to load games, continuing...', error);
        }
        
        // Cargar sesiones activas PRIMERO para evitar parpadeo
        try {
          console.log('Loading active sessions...');
          await fetchActiveSessions();
        } catch (error) {
          console.error('Failed to load active sessions, continuing...', error);
        }
        
        try {
          console.log('Loading session history...');
          await fetchSessionHistory();
        } catch (error) {
          console.error('Failed to load session history, continuing...', error);
        }
        
        // Configurar intervalos de actualización
        // Actualizar sesiones activas cada 10 segundos (mucho menos frecuente para evitar parpadeo)
        setInterval(fetchActiveSessions, 10000);
        
        // Actualizar historial cada 20 segundos
        setInterval(fetchSessionHistory, 20000);
        
        // Actualizar niños y juegos cada 60 segundos (menos frecuente)
        setInterval(() => {
          fetchChildren();
          fetchGames();
        }, 60000);
        
        // Limpiar timers al cerrar la página
        window.addEventListener('beforeunload', () => {
          timerIntervals.forEach(interval => clearInterval(interval));
        });
        
        isInitialized = true;
        showStatusMessage('Aplicación cargada correctamente', 'success');
        console.log('App initialized successfully');
      } catch (error) {
        console.error('Critical error initializing app:', error);
        showStatusMessage('Error crítico al cargar la aplicación', 'error');
      }
    }

    // Función de recuperación automática
    async function recoverFromErrors() {
      console.log('Attempting to recover from errors...');
      try {
        await initializeApp();
      } catch (error) {
        console.error('Recovery failed:', error);
        setTimeout(recoverFromErrors, 5000); // Reintentar en 5 segundos
      }
    }
    
    // Función para forzar sincronización completa
    async function forceSync() {
      console.log('Forcing complete sync...');
      try {
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        console.log('Complete sync successful');
      } catch (error) {
        console.error('Force sync failed:', error);
      }
    }
    
    // Sincronización automática cuando la página vuelve a ser visible
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        console.log('Page became visible, forcing sync...');
        forceSync();
      }
    });
    
    // Sincronización cuando se enfoca la ventana
    window.addEventListener('focus', () => {
      console.log('Window focused, forcing sync...');
      forceSync();
    });

    // Inicializar cuando se carga la página
    document.addEventListener('DOMContentLoaded', () => {
      initializeApp().catch(() => {
        console.log('Initial initialization failed, starting recovery...');
        setTimeout(recoverFromErrors, 2000);
      });
    });
  </script>
</body>
</html>