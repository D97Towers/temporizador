<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Temporizador de Juegos</title>
  <!-- Deployment trigger: v1.9 - FONT AWESOME UPDATE + FAVICON: Updated to 6.4.0 and added favicon -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>⏱️</text></svg>">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      color: #333;
      box-sizing: border-box;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 10px;
      box-sizing: border-box;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      color: white;
      position: relative;
      padding-left: 80px;
      padding-right: 200px; /* Más espacio para el botón de voz */
      min-height: 120px; /* Altura mínima para evitar superposición */
    }


    /* Estilos para sidebar con footer separado */
    .sidebar {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .nav-buttons {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .sidebar-footer {
      margin-top: auto;
      padding-top: 20px;
    }

    /* Desktop sidebar layout */
    .desktop-nav-container {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 80px);
    }

    .desktop-nav {
      flex: 1;
    }

    .desktop-sidebar-footer {
      margin-top: auto;
      padding-top: 20px;
    }

    /* Estilos para botones de logout en sidebar */
    .logout-btn-sidebar {
      background: transparent !important;
      border: none !important;
      color: white !important;
      margin-top: 0 !important;
      border-radius: 8px !important;
    }

    .logout-btn-sidebar:hover {
      background: rgba(255, 255, 255, 0.1) !important;
      border: none !important;
    }

    .logout-btn-desktop {
      background: transparent !important;
      border: none !important;
      color: white !important;
      margin-top: 0 !important;
      border-radius: 8px !important;
    }

    .logout-btn-desktop:hover {
      background: rgba(255, 255, 255, 0.1) !important;
      border: none !important;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    /* Navegación principal */
         .main-nav {
           display: flex;
           justify-content: flex-start;
           gap: 10px;
           margin-top: 20px;
           flex-wrap: wrap;
           margin-left: 20px;
         }

         /* Desktop Sidebar */
         .desktop-sidebar {
           display: none;
         }

         .main-content {
           width: 100%;
         }

         /* Desktop - mostrar sidebar y ocultar menú móvil */
         @media (min-width: 769px) {
           .desktop-sidebar {
             display: flex;
             flex-direction: column;
             position: fixed;
             left: 0;
             top: 0;
             width: 250px;
             height: 100vh;
             background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
             z-index: 100;
             box-shadow: 2px 0 10px rgba(0,0,0,0.3);
           }

           .sidebar-header {
             padding: 30px 20px 20px;
             border-bottom: 1px solid rgba(255,255,255,0.1);
           }

           .sidebar-header h2 {
      color: white;
             font-size: 1.5rem;
             font-weight: 600;
             text-align: center;
             margin: 0;
           }

           .desktop-nav {
             padding: 20px 0;
             flex: 1;
           }

           .desktop-nav-btn {
             display: flex;
             align-items: center;
             gap: 12px;
             width: 100%;
             padding: 15px 20px;
             background: none;
             border: none;
             color: rgba(255,255,255,0.9);
             font-size: 14px;
             font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
             text-align: left;
             border-left: 3px solid transparent;
           }

           .desktop-nav-btn:hover {
             background: rgba(255,255,255,0.15);
             color: white;
             transform: translateX(5px);
           }

           .desktop-nav-btn.active {
             background: rgba(255,255,255,0.2);
             color: white;
             border-left-color: white;
             font-weight: 600;
           }

           .desktop-nav-btn i {
             font-size: 16px;
             width: 20px;
           }

           .main-content {
             margin-left: 250px;
             width: calc(100% - 250px);
           }
           
           .mobile-menu-toggle {
             display: none !important;
           }
           
        /* Ocultar botón X en móvil */
        .close-button {
             display: none !important;
           }
           
           .header {
             padding-left: 20px !important;
             text-align: center !important;
           }
         }

         /* Menú lateral para móviles */
         .mobile-menu-toggle {
           display: none;
           background: transparent !important;
      color: white;
           border: none !important;
           padding: 8px;
      border-radius: 0;
      cursor: pointer;
      width: auto;
      height: auto;
           transition: all 0.3s ease;
           box-shadow: none !important;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
         .hamburger-lines {
           display: flex;
           flex-direction: column;
           gap: 3px;
           width: 18px;
         }

         .hamburger-lines span {
           width: 100%;
           height: 2px;
           background-color: white;
           border-radius: 1px;
           transition: all 0.3s ease;
         }

         .mobile-menu-toggle:hover {
           background: rgba(255, 255, 255, 0.1) !important;
           opacity: 0.8;
         }

         /* Asegurar que el botón no se vea afectado por otros estilos */
         .mobile-menu-toggle * {
           text-align: center !important;
           position: static !important;
         }

         /* Sobrescribir estilos globales de botones */
         .mobile-menu-toggle {
           width: auto !important;
           max-width: none !important;
           min-width: auto !important;
           flex: none !important;
           box-sizing: border-box !important;
         }

         .sidebar {
           position: fixed;
           top: 0;
           left: -300px;
           width: 280px;
           height: 100vh;
           background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
           padding: 80px 20px 20px;
           z-index: 1000;
           transition: left 0.3s ease;
           box-shadow: 2px 0 10px rgba(0,0,0,0.3);
         }

         .sidebar.open {
           left: 0;
         }

         .sidebar .nav-btn {
           width: 100%;
           margin-bottom: 10px;
           justify-content: flex-start;
           min-width: auto;
         }

         .sidebar-overlay {
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background: rgba(0, 0, 0, 0.5);
           z-index: 999;
           opacity: 0;
           visibility: hidden;
           transition: all 0.3s ease;
         }

         .sidebar-overlay.active {
           opacity: 1;
           visibility: visible;
         }

         /* Sistema de búsqueda de niños */
         .child-search-container {
           position: relative;
         }

         .child-search-results {
           position: absolute;
           top: 100%;
           left: 0;
           right: 0;
           background: white;
           border: 1px solid #ddd;
           border-radius: 8px;
           max-height: 200px;
           overflow-y: auto;
      z-index: 100;
           display: none;
           box-shadow: 0 4px 12px rgba(0,0,0,0.15);
         }

         .child-search-results.show {
           display: block;
         }

         .child-search-item {
           padding: 12px 15px;
           cursor: pointer;
           border-bottom: 1px solid #f0f0f0;
           display: flex;
           align-items: center;
           gap: 10px;
           transition: background-color 0.2s ease;
         }

         .child-search-item:hover {
           background-color: #f8f9fa;
         }

         .child-search-item:last-child {
           border-bottom: none;
         }

         .child-search-item .child-avatar {
           width: 30px;
           height: 30px;
           border-radius: 50%;
           background: linear-gradient(135deg, #667eea, #764ba2);
           color: white;
      display: flex;
      align-items: center;
      justify-content: center;
           font-weight: bold;
           font-size: 14px;
         }

         .child-search-item .child-info {
           flex: 1;
         }

         .child-search-item .child-name {
           font-weight: 600;
           color: #333;
           margin-bottom: 2px;
         }

         .child-search-item .child-parents {
           font-size: 12px;
           color: #666;
         }

         .child-search-item .child-stats {
           font-size: 11px;
           color: #999;
           text-align: right;
         }

         .no-results {
           padding: 15px;
           text-align: center;
           color: #666;
           font-style: italic;
         }

    .nav-btn {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      padding: 12px 20px;
      border-radius: 25px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      min-width: 140px;
      justify-content: center;
    }

    .nav-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
      transform: translateY(-2px);
    }

    .nav-btn.active {
      background: rgba(255, 255, 255, 0.9);
      color: #667eea;
      border-color: white;
    }

    .shortcut-key {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 10px;
      font-weight: bold;
      margin-left: 8px;
      opacity: 0.8;
    }

    /* Secciones */
    .section {
      display: none;
    }

    .section.active {
      display: block;
    }

    /* Dashboard de estadísticas */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      transition: transform 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-5px);
    }

    .stat-number {
      font-size: 2.5rem;
      font-weight: bold;
      color: #667eea;
      margin-bottom: 10px;
    }

    .stat-label {
      color: #666;
      font-size: 1rem;
      margin-bottom: 5px;
    }

    .stat-description {
      color: #999;
      font-size: 0.9rem;
    }

    .chart-container {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }

    .chart-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: #333;
      margin-bottom: 15px;
      text-align: center;
    }

    .ranking-list {
      list-style: none;
      padding: 0;
    }

    .ranking-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      margin-bottom: 8px;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #667eea;
    }

    .ranking-item:nth-child(1) {
      border-left-color: #ffd700;
      background: linear-gradient(135deg, #fff9c4, #f8f9fa);
    }

    .ranking-item:nth-child(2) {
      border-left-color: #c0c0c0;
      background: linear-gradient(135deg, #f0f0f0, #f8f9fa);
    }

    .ranking-item:nth-child(3) {
      border-left-color: #cd7f32;
      background: linear-gradient(135deg, #ffe4b5, #f8f9fa);
    }

    .ranking-position {
      font-weight: bold;
      color: #667eea;
      font-size: 1.2rem;
      min-width: 30px;
    }

    .ranking-name {
      flex: 1;
      margin: 0 15px;
      font-weight: 500;
    }

    .ranking-time {
      color: #666;
      font-weight: 600;
    }
    
    /* Sync button removed for better UX - data syncs automatically */

    .header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    /* Control de notificaciones de voz */
    .voice-control {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
      z-index: 10;
      max-width: 160px; /* Limitar ancho del botón */
    }

    .voice-toggle-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 8px 14px;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      font-weight: 500;
      backdrop-filter: blur(10px);
      min-width: 120px;
      max-width: 140px; /* Reducir ancho máximo */
      justify-content: center;
      white-space: nowrap;
      overflow: hidden; /* Evitar desbordamiento de texto */
    }

    .voice-toggle-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
    }

    .voice-toggle-btn.muted {
      background: rgba(255, 0, 0, 0.2);
      border-color: rgba(255, 0, 0, 0.4);
    }

    .voice-toggle-btn.muted i {
      color: #ff6b6b;
    }

    /* Responsive para botón de voz - iPad */
    @media (max-width: 1024px) and (min-width: 769px) {
      .header {
        padding-right: 200px; /* Mucho más espacio para iPad */
      }
      
      .voice-control {
        position: absolute;
        top: 20px;
        right: 20px;
        justify-content: center;
        z-index: 10;
        max-width: 100px; /* Reducir más el tamaño del botón */
      }
      
      .voice-toggle-btn {
        min-width: 80px;
        max-width: 100px;
        padding: 6px 8px;
        font-size: 10px; /* Texto más pequeño */
      }
      
      /* En iPad vertical, ocultar texto y mostrar solo icono */
      @media (max-height: 1024px) and (orientation: portrait) {
        .voice-toggle-btn span {
          display: none; /* Ocultar texto en iPad vertical */
        }
        
        .voice-toggle-btn {
          min-width: 50px;
          max-width: 50px;
          padding: 8px 6px;
        }
        
        .voice-control {
          max-width: 50px;
        }
      }
    }

    /* Responsive para botón de voz - Tablet */
    @media (max-width: 768px) {
      .header {
        padding-right: 120px; /* Reducir espacio para tablets */
      }
      
      .voice-control {
        position: absolute;
        top: 20px;
        right: 20px;
        justify-content: center;
        z-index: 10;
        max-width: 100px; /* Más compacto en tablets */
      }
      
      .voice-toggle-btn {
        min-width: 80px;
        max-width: 100px;
        padding: 6px 10px;
        font-size: 11px;
      }
      
      /* FIX CRÍTICO: AJUSTAR history-toggle en tablet */
      .history-toggle {
        position: relative !important;
        z-index: 1 !important;
        margin: 10px 0;
      }
    }

    /* iPhone y móviles pequeños */
    @media (max-width: 480px) {
      .header {
        padding-right: 70px; /* Reducir espacio para móviles */
        min-height: 100px; /* Reducir altura mínima en móviles */
      }
      
      .voice-control {
        position: absolute;
        top: 15px; /* Mover más arriba */
        right: 15px; /* Mover más a la derecha */
        justify-content: center;
        z-index: 10;
        max-width: 50px; /* Botón más compacto en móviles */
      }
      
      .voice-toggle-btn {
        min-width: 50px;
        max-width: 50px;
        padding: 8px 6px;
        font-size: 10px;
        gap: 2px;
        border-radius: 20px; /* Más redondo */
      }
      
      .voice-toggle-btn span {
        display: none; /* Ocultar texto en móviles */
      }
      
      .voice-toggle-btn i {
        font-size: 14px; /* Icono más pequeño */
      }
    }

    /* iPhone Plus y móviles medianos */
    @media (max-width: 414px) {
      .header {
        padding-right: 60px; /* Aún menos espacio */
      }
      
      .voice-control {
        top: 10px;
        right: 10px;
        max-width: 45px;
      }
      
      .voice-toggle-btn {
        min-width: 45px;
        max-width: 45px;
        padding: 6px 4px;
      }
    }
      
      /* FIX CRÍTICO: AJUSTAR history-toggle en móvil */
      .history-toggle {
        position: relative !important;
        z-index: 1 !important;
        margin: 10px 0;
        font-size: 12px;
        padding: 10px 12px;
      }





    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(0,0,0,0.15);
    }

    .card h2 {
      color: #4a5568;
      margin-bottom: 20px;
      font-size: 1.3rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-row {
      display: flex;
      gap: 15px;
      align-items: end;
      flex-wrap: wrap;
    }

    .form-row .form-group {
      flex: 1;
      min-width: 120px;
    }

    .form-row .form-group:last-child {
      flex: 0 0 auto;
      min-width: 140px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #4a5568;
    }

    input, select, button {
      width: 100%;
      padding: 12px 15px;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      font-size: 14px;
      transition: all 0.3s ease;
      background: white;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: all 0.3s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    button:disabled {
      background: #cbd5e0;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-danger {
      background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
    }

    .btn-success {
      background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
    }

    .btn-warning {
      background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
    }

    .list {
      list-style: none;
      margin-top: 15px;
    }

    .list-item {
      background: #f7fafc;
      padding: 12px 15px;
      margin-bottom: 8px;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.3s ease;
      overflow: hidden;
      word-wrap: break-word;
      position: relative;
    }

    .list-item:hover {
      background: #edf2f7;
      transform: translateX(5px);
    }

    .list-item.active {
      border-left-color: #38a169;
      background: #f0fff4;
    }

    .session-info {
      flex: 1;
      min-width: 0;
      margin-right: 10px;
    }

    .session-controls {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      min-width: 0;
      flex-shrink: 0;
    }

    .button-group {
      display: flex;
      gap: 3px;
      margin-top: 5px;
      flex-wrap: nowrap;
    }
    
    /* Estilos para avatares y identificadores únicos */
    .child-info {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
    }
    
    .child-avatar {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 50%;
      font-weight: bold;
      font-size: 14px;
      flex-shrink: 0;
    }
    
    .child-avatar-small {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 50%;
      font-weight: bold;
      font-size: 10px;
      margin-right: 5px;
    }
    
    .child-details {
      flex: 1;
      min-width: 0;
    }
    
    .original-name {
      display: block;
      color: #666;
      font-size: 11px;
      margin-top: 2px;
      font-style: italic;
    }
    
    /* Estilos para formulario mejorado de niños */
    .child-form {
      margin-bottom: 20px;
    }
    
    .child-form label {
      display: block;
      margin-bottom: 5px;
      font-weight: 600;
      color: #333;
      font-size: 14px;
    }
    
    .child-form input {
      width: 100%;
      padding: 10px;
      border: 2px solid #e1e5e9;
      border-radius: 8px;
      font-size: 14px;
      transition: all 0.3s ease;
      box-sizing: border-box;
    }
    
    .child-form input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    .child-form input[required] {
      border-color: #667eea;
    }
    
    .child-form .form-row {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    .child-form .form-row .form-group {
      flex: 1;
    }
    
    .child-form {
      margin-bottom: 20px;
    }

    .child-form .form-row {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
    }

    .child-form .form-group {
      flex: 1;
      min-width: 0;
    }

    .child-form label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      color: #333;
      font-size: 14px;
    }

    .child-form input {
      width: 100%;
      padding: 10px;
      border: 2px solid #e1e5e9;
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.3s ease;
      box-sizing: border-box;
    }

    .child-form input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .child-form small {
      display: block;
      color: #666;
      font-size: 12px;
      margin-top: 5px;
      font-style: italic;
    }

    /* Safari iPhone specific fixes */
    @supports (-webkit-touch-callout: none) {
      .btn-small, .btn-edit {
        -webkit-appearance: none !important;
        appearance: none !important;
        -webkit-tap-highlight-color: transparent !important;
        touch-action: manipulation !important;
      }
      
      .list-item {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }
    }

    /* Responsive design for mobile */
    @media (max-width: 768px) {
      .child-form .form-row {
        flex-direction: column;
        gap: 10px;
      }
      
      .child-form .form-group {
        flex: none;
      }

      .child-info {
        flex-direction: column;
        align-items: flex-start !important;
        gap: 8px;
      }

      .child-details {
        width: 100% !important;
      }

      .list-item {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }

      .btn-small {
        align-self: flex-end;
        margin-top: 8px;
        padding: 14px 18px !important;
        font-size: 16px !important;
        min-width: 48px !important;
        min-height: 48px !important;
        touch-action: manipulation !important;
        -webkit-tap-highlight-color: transparent !important;
      }

      .btn-edit {
        padding: 14px 18px !important;
        font-size: 16px !important;
        min-width: 48px !important;
        min-height: 48px !important;
        touch-action: manipulation !important;
        -webkit-tap-highlight-color: transparent !important;
      }

      .delete-button-container {
        min-width: 120px;
        height: 48px;
        gap: 8px;
      }

      .button-group-small {
        gap: 8px;
      }

      .list-item {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      .child-info {
        margin-right: 0 !important;
      }

      .container {
        padding: 10px;
      }

      .card {
        margin-bottom: 15px;
      }

      h2 {
        font-size: 18px;
      }
    }

    /* Tablet responsive */
    @media (max-width: 1024px) and (min-width: 769px) {
      .grid {
        grid-template-columns: 1fr;
        gap: 20px;
      }
      
      .child-form .form-row {
        gap: 12px;
      }
    }
    
    /* Estilos para elementos de niños mejorados */
    .child-item {
      border-left: 4px solid #667eea;
      background: #f8f9ff;
      transition: all 0.3s ease;
    }

    .child-item:hover {
      background: #e8f2ff;
    }

    .child-name {
      font-size: 16px;
      font-weight: 600;
      color: #333;
      margin-bottom: 4px;
    }

    .nickname-text {
      color: #666;
      font-weight: 400;
      font-style: italic;
    }

    .child-time {
      color: #666;
      font-size: 14px;
    }

    .child-parents {
      color: #555;
      font-size: 12px;
      font-style: italic;
      margin: 2px 0;
      background: rgba(102, 126, 234, 0.05);
      padding: 2px 6px;
      border-radius: 4px;
      border-left: 2px solid #667eea;
    }

    .btn-small {
      padding: 12px 16px !important;
      font-size: 14px !important;
      min-width: 44px !important;
      min-height: 44px !important;
      border-radius: 8px !important;
      opacity: 0.9;
      transition: all 0.2s ease !important;
      width: auto !important;
      height: auto !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      touch-action: manipulation !important;
      -webkit-tap-highlight-color: transparent !important;
    }

    .btn-small:hover {
      opacity: 1;
      transform: none;
      background: #e53e3e !important;
    }

    .btn-small i {
      font-size: 14px !important;
    }

    .btn-edit {
      padding: 12px 16px !important;
      font-size: 14px !important;
      min-width: 44px !important;
      min-height: 44px !important;
      border-radius: 8px !important;
      opacity: 0.9;
      transition: all 0.2s ease !important;
      width: auto !important;
      height: auto !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
      color: white !important;
      border: none !important;
      margin-right: 8px !important;
      touch-action: manipulation !important;
      -webkit-tap-highlight-color: transparent !important;
    }

    .btn-edit:hover {
      opacity: 1;
      transform: none;
      background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%) !important;
    }

    .btn-edit i {
      font-size: 14px !important;
    }

    .delete-button-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      min-width: 60px;
      height: 32px;
    }

    .button-group-small {
      display: flex;
      gap: 5px;
      align-items: center;
    }

    .parents-info {
      color: #555;
      font-size: 11px;
      font-style: italic;
      background: rgba(102, 126, 234, 0.05);
      padding: 2px 6px;
      border-radius: 4px;
      border-left: 2px solid #667eea;
      margin: 2px 0;
      display: inline-block;
    }

    .history-parents {
      color: #555;
      font-size: 11px;
      font-style: italic;
      background: rgba(102, 126, 234, 0.05);
      padding: 2px 6px;
      border-radius: 4px;
      border-left: 2px solid #667eea;
      margin: 2px 0;
      display: block;
    }

    /* Historial compacto y responsive */
    .history-item {
      background: white;
      margin-bottom: 8px;
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 12px;
      align-items: center;
      transition: all 0.2s ease;
      border-left: 4px solid transparent;
    }

    .history-item:hover {
      transform: translateX(2px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }

    .history-item.active {
      border-left-color: #4CAF50;
      background: linear-gradient(135deg, #f8fff8, #ffffff);
    }

    .history-item.completed {
      border-left-color: #2196F3;
      opacity: 0.8;
    }

    .history-item.expired {
      border-left-color: #f44336;
      background: linear-gradient(135deg, #fff5f5, #ffffff);
    }

    .history-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      color: white;
    }

    .history-icon.active {
      background: linear-gradient(135deg, #4CAF50, #45a049);
    }

    .history-icon.completed {
      background: linear-gradient(135deg, #2196F3, #1976D2);
    }

    .history-icon.expired {
      background: linear-gradient(135deg, #f44336, #d32f2f);
    }

    .history-content {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .history-title {
      font-weight: 600;
      color: #333;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .history-subtitle {
      font-size: 12px;
      color: #666;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .history-meta {
      text-align: right;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 80px;
    }

    .history-duration {
      font-size: 12px;
      font-weight: 600;
      padding: 2px 6px;
      border-radius: 4px;
      color: white;
    }

    .history-duration.active {
      background: #4CAF50;
    }

    .history-duration.completed {
      background: #2196F3;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .history-duration.expired {
      background: #f44336;
    }

    .history-time {
      font-size: 11px;
      color: #999;
    }

    /* Botón para expandir/colapsar historial - COLORIMETRÍA CORREGIDA */
    .history-toggle {
      width: 100%;
      padding: 12px 16px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: all 0.3s ease;
      margin: 15px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      position: relative !important;
      z-index: 1 !important;
    }

    /* AJUSTAR history-toggle en móvil y tablet */
    @media (max-width: 1024px) {
      .history-toggle {
        position: relative !important;
        z-index: 1 !important;
        margin: 10px 0;
      }
    }


    .history-toggle:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    .history-toggle.expanded {
      background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
    }


    .history-hidden {
      display: none;
    }

    .history-summary {
      background: #f8f9fa;
      border-radius: 6px;
      padding: 8px 12px;
      margin: 8px 0;
      font-size: 12px;
      color: #666;
      text-align: center;
      border: 1px solid #e9ecef;
    }

    /* Responsive design para historial */
    @media (max-width: 768px) {
      .history-item {
        grid-template-columns: auto 1fr;
        gap: 8px;
      }

      .history-meta {
        grid-column: 1 / -1;
        text-align: left;
        flex-direction: row;
        justify-content: space-between;
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #eee;
      }

      .history-content {
        grid-column: 2;
      }
    }

    @media (max-width: 480px) {
      .history-item {
        padding: 10px;
        margin-bottom: 6px;
      }

      .history-icon {
        width: 32px;
        height: 32px;
        font-size: 14px;
      }

      .history-title {
        font-size: 13px;
      }

      .history-subtitle {
        font-size: 11px;
      }

    }

    .timer {
      font-weight: bold;
      color: #38a169;
      font-family: 'Courier New', monospace;
      font-size: 1.1rem;
      line-height: 1.3;
      text-align: center;
      min-width: 120px;
    }

    .timer.warning {
      color: #f6ad55;
    }

    .timer.danger {
      color: #e53e3e;
      animation: pulse 1s infinite;
    }

    .timer strong {
      display: block;
      font-size: 1.2rem;
      margin-bottom: 2px;
    }

    .timer small {
      font-size: 0.9rem;
      opacity: 0.8;
      font-weight: normal;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .status-message {
      position: fixed;
      top: 120px;
      right: 20px;
      padding: 12px 16px;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      font-size: 14px;
      line-height: 1.4;
      z-index: 1010;
      max-width: 350px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transform: translateX(400px);
      transition: transform 0.3s ease;
      display: flex;
      align-items: flex-start;
      gap: 8px;
      max-width: 380px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      word-wrap: break-word;
      hyphens: auto;
    }

    .status-text {
      flex: 1;
      word-wrap: break-word;
    }

    .status-close {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      opacity: 0.8;
      transition: opacity 0.2s ease;
      flex-shrink: 0;
    }

    .status-close:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.1);
    }

    .status-message.show {
      transform: translateX(0);
    }

    .status-message.success {
      background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
    }

    .status-message.error {
      background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
    }

    .status-message.warning {
      background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(5px);
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      animation: modalSlideIn 0.3s ease;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: scale(0.8) translateY(-50px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .modal h2 {
      color: #4a5568;
      margin-bottom: 20px;
      font-size: 1.5rem;
    }

    .modal p {
      font-size: 1.1rem;
      margin-bottom: 30px;
      color: #666;
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .modal-buttons button {
      flex: 1;
      max-width: 120px;
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .extend-time {
      background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
      margin-left: 5px;
      padding: 5px 10px;
      font-size: 12px;
    }

    /* Responsive Design para navegación */
    @media (max-width: 768px) {
      .stats-grid {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }
      
      .stat-card {
        padding: 15px;
      }
      
      .stat-number {
        font-size: 2rem;
      }
      
      .chart-container {
        padding: 15px;
      }
    }

    @media (max-width: 480px) {
      .nav-btn {
        padding: 8px 12px;
        font-size: 12px;
      }
      
      .stats-grid {
        grid-template-columns: 1fr;
      }
      
      .ranking-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      
      .ranking-meta {
        display: flex;
        justify-content: space-between;
        width: 100%;
      }
    }

    /* Sistema de alertas mejorado */
    .alert-container {
      position: fixed;
      top: 80px;
      right: 20px;
      z-index: 10000;
      max-width: 380px;
      max-height: 60vh;
      overflow-y: auto;
      pointer-events: none;
    }
    
    .alert-container::-webkit-scrollbar {
      width: 4px;
    }
    
    .alert-container::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .alert-container::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
    }
    
    .persistent-alert {
      background: linear-gradient(135deg, #ff4757, #ff3742);
      color: white;
      border-radius: 8px;
      padding: 0;
      margin-bottom: 8px;
      box-shadow: 0 4px 20px rgba(255, 71, 87, 0.25);
      transform: translateX(0);
      opacity: 1;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: auto;
      border: none;
      backdrop-filter: blur(8px);
      overflow: hidden;
    }
    
    .persistent-alert:hover {
      transform: translateX(-4px);
      box-shadow: 0 6px 25px rgba(255, 71, 87, 0.35);
    }
    
    .alert-content {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      padding: 10px 14px;
      gap: 10px;
    }
    
    .alert-message {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
      line-height: 1.3;
      word-wrap: break-word;
      white-space: pre-line; /* Permitir saltos de línea */
      overflow-wrap: break-word;
      hyphens: auto;
    }
    
    .alert-close {
      background: rgba(255, 255, 255, 0.15);
      border: none;
      color: white;
      cursor: pointer;
      padding: 6px;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      flex-shrink: 0;
    }
    
    .alert-close:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: scale(1.1);
    }
    
    .alert-close i {
      font-size: 11px;
    }
    
    /* Animación de entrada mejorada */
    .persistent-alert {
      animation: slideInRight 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    /* Agrupación de alertas similares */
    .alert-group {
      background: linear-gradient(135deg, #ff6b6b, #ff5252);
      border-radius: 8px;
      margin-bottom: 8px;
      overflow: hidden;
    }
    
    .alert-group-header {
      background: rgba(255, 255, 255, 0.1);
      padding: 8px 16px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .alert-group-content {
      padding: 8px 16px;
    }
    
    .alert-group-item {
      font-size: 12px;
      margin-bottom: 4px;
      opacity: 0.9;
    }
    
    .alert-group-item:last-child {
      margin-bottom: 0;
    }
    
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* Optimizaciones específicas para desktop */
    @media (min-width: 769px) {
      .status-message {
        max-width: 400px;
        font-size: 14px;
        padding: 12px 18px;
      }
      
      .alert-container {
        max-width: 400px;
      }
      
      .alert-content {
        padding: 12px 16px;
      }
      
      .alert-message {
        font-size: 14px;
        line-height: 1.4;
        white-space: pre-line; /* Permitir saltos de línea */
      }
      
      /* Ocultar botón X en desktop también */
      .alert-close {
        display: none !important;
      }
      
      .status-close {
        display: none !important;
      }
    }

    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      
      .mobile-menu-toggle {
        display: block !important;
        position: fixed !important;
        top: 20px !important;
        left: 20px !important;
        z-index: 1001 !important;
        transform: none !important;
        transition: none !important;
      }
      
      /* Asegurar que el botón hamburguesa se mantenga fijo */
      .mobile-menu-toggle:hover {
        background: rgba(255, 255, 255, 0.2) !important;
        border-color: rgba(255, 255, 255, 0.5) !important;
      }
      
      .main-nav {
        display: none !important;
      }
      
      .header {
        padding-left: 20px !important;
        text-align: center !important;
      }
      
      .container {
        padding-left: 10px;
      }
      
      .header {
        padding-left: 20px !important;
        padding-right: 20px !important;
        text-align: center !important;
      }


      .header h1 {
        font-size: 1.5rem;
        margin-left: 0;
      }
      
      .header p {
        font-size: 0.9rem;
        margin-left: 0;
      }

      .grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .card {
        padding: 20px;
      }

      .form-row {
        flex-direction: column !important;
        gap: 10px;
        align-items: stretch !important;
      }

      .form-row .form-group {
        min-width: auto !important;
        max-width: none !important;
        flex: none !important;
        width: 100% !important;
      }

      .form-row .form-group:last-child {
        min-width: auto !important;
        max-width: none !important;
        flex: none !important;
        width: 100% !important;
      }

      input, select, button {
        width: 100% !important;
        max-width: none !important;
        font-size: 16px; /* Evita zoom en iOS */
      }
      
      /* Mejorar alertas en móviles */
      .alert-container {
        top: 70px;
        right: 10px;
        left: 10px;
        max-width: none;
        max-height: 50vh;
      }
      
      /* Ocultar botón X en alertas móviles */
      .alert-close {
        display: none !important;
      }
      
      /* Ocultar botón X en status message móvil */
      .status-close {
        display: none !important;
      }
      
      
      .persistent-alert {
        margin-bottom: 6px;
        border-radius: 6px;
      }
      
      .alert-content {
        padding: 10px 14px;
        gap: 10px;
      }
      
      .alert-message {
        font-size: 12px;
        line-height: 1.3;
        white-space: pre-line; /* Permitir saltos de línea */
      }
      
      .alert-close {
        width: 20px;
        height: 20px;
        padding: 4px;
      }
      
      .alert-close i {
        font-size: 10px;
      }
      
      /* Mejorar botones en móviles */
      .list-item .btn {
        padding: 8px 12px;
        font-size: 12px;
        margin: 2px;
      }

      .status-message {
        top: 100px;
        right: 10px;
        left: 10px;
        transform: translateY(-100px);
        max-width: none;
      }

      .status-message.show {
        transform: translateY(0);
      }
    }

    @media (max-width: 480px) {
      .header h1 {
        font-size: 1.8rem;
      }
      
      /* Sync button responsive rules removed */

      .card {
        padding: 15px;
      }

      .modal-content {
        padding: 30px 20px;
      }

      .form-row {
        flex-direction: column !important;
        gap: 8px;
      }

      .form-row .form-group {
        width: 100% !important;
        flex: none !important;
      }

      input, select, button {
        width: 100% !important;
        padding: 10px 12px;
        font-size: 14px;
      }
    }

    /* Reglas responsive para sesiones activas */
    @media (max-width: 768px) {
      .list-item.active {
        flex-direction: column;
        align-items: stretch;
      }
      
      .session-controls {
        align-items: center;
        margin-top: 10px;
      }
      
      .button-group {
        justify-content: center;
        width: 100%;
      }
    }

    @media (max-width: 480px) {
      .button-group button {
        padding: 6px 10px !important;
        font-size: 12px !important;
      }
    }

    /* Regla específica para pantallas muy pequeñas */
    @media (max-width: 360px) {
      .form-row {
        flex-direction: column !important;
        gap: 5px;
      }

      .form-row .form-group {
        width: 100% !important;
        margin-bottom: 10px;
      }

      input, select, button {
        width: 100% !important;
        padding: 8px 10px;
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
    <!-- Menú móvil - Posicionado fuera del flujo normal -->
    <div style="position: fixed; top: 20px; left: 20px; z-index: 1001;">
      <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">
        <div class="hamburger-lines">
          <span></span>
          <span></span>
          <span></span>
        </div>
      </button>
    </div>
    
    <div class="sidebar-overlay" onclick="closeMobileMenu()"></div>
    
    <div class="sidebar" id="sidebar">
      <div class="nav-buttons">
      <button onclick="showSection('dashboard')" class="nav-btn" id="nav-dashboard">
        <i class="fas fa-chart-bar"></i> Dashboard <span class="shortcut-key">1</span>
      </button>
      <button onclick="showSection('sessions')" class="nav-btn" id="nav-sessions">
        <i class="fas fa-play-circle"></i> Sesiones <span class="shortcut-key">2</span>
      </button>
      <button onclick="showSection('children')" class="nav-btn" id="nav-children">
        <i class="fas fa-child"></i> Niños <span class="shortcut-key">3</span>
      </button>
      <button onclick="showSection('games')" class="nav-btn" id="nav-games">
        <i class="fas fa-gamepad"></i> Juegos <span class="shortcut-key">4</span>
      </button>
      </div>
      <div class="sidebar-footer">
        <button onclick="logout()" class="nav-btn logout-btn-sidebar" title="Cerrar sesión">
          <i class="fas fa-sign-out-alt"></i> Cerrar Sesión
        </button>
      </div>
    </div>

  <!-- Desktop Sidebar -->
  <div class="desktop-sidebar">
    <div class="sidebar-header">
      <h2><i class="fas fa-gamepad"></i> Temporizador</h2>
    </div>
    <div class="desktop-nav-container">
    <nav class="desktop-nav">
      <button onclick="showSection('dashboard')" class="desktop-nav-btn" id="nav-dashboard">
        <i class="fas fa-chart-bar"></i> Dashboard
      </button>
      <button onclick="showSection('sessions')" class="desktop-nav-btn" id="nav-sessions">
        <i class="fas fa-play-circle"></i> Sesiones
      </button>
      <button onclick="showSection('children')" class="desktop-nav-btn" id="nav-children">
        <i class="fas fa-child"></i> Niños
      </button>
      <button onclick="showSection('games')" class="desktop-nav-btn" id="nav-games">
        <i class="fas fa-gamepad"></i> Juegos
      </button>
    </nav>
      <div class="desktop-sidebar-footer">
        <button onclick="logout()" class="desktop-nav-btn logout-btn-desktop" title="Cerrar sesión">
          <i class="fas fa-sign-out-alt"></i> Cerrar Sesión
        </button>
      </div>
    </div>
  </div>

  <div class="main-content">
    <div class="header">
      <h1><i class="fas fa-gamepad"></i> Temporizador de Juegos</h1>
      <p>Controla el tiempo de juego de los niños de forma divertida</p>
      
      <!-- Control de notificaciones de voz -->
      <div class="voice-control">
        <button id="voiceToggle" onclick="toggleVoiceNotifications()" class="voice-toggle-btn" title="Activar/Desactivar notificaciones de voz">
          <i class="fas fa-volume-up"></i>
          <span id="voiceStatus">Voz Activada</span>
        </button>
      </div>
    </div>

    <!-- Dashboard Section -->
    <div id="dashboard-section" class="section">
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-number" id="totalChildren">0</div>
          <div class="stat-label">Niños Registrados</div>
          <div class="stat-description">Total de niños en el sistema</div>
          </div>
        <div class="stat-card">
          <div class="stat-number" id="totalGames">0</div>
          <div class="stat-label">Juegos Disponibles</div>
          <div class="stat-description">Juegos registrados</div>
          </div>
        <div class="stat-card">
          <div class="stat-number" id="activeSessionsCount">0</div>
          <div class="stat-label">Sesiones Activas</div>
          <div class="stat-description">Jugando ahora</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="totalTimePlayed">0</div>
          <div class="stat-label">Tiempo Total (min)</div>
          <div class="stat-description">Tiempo jugado acumulado</div>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">🏆 Ranking de Tiempo Jugado</div>
        <ul class="ranking-list" id="childrenRanking">
          <li class="ranking-item">No hay datos disponibles</li>
        </ul>
          </div>

      <div class="chart-container">
        <div class="chart-title">🎮 Juegos Más Populares</div>
        <ul class="ranking-list" id="gamesRanking">
          <li class="ranking-item">No hay datos disponibles</li>
        </ul>
          </div>
      </div>

    <!-- Sessions Section -->
    <div id="sessions-section" class="section">
      <div class="grid">
      <!-- Iniciar Sesión -->
      <div class="card">
        <h2><i class="fas fa-play-circle"></i> Iniciar Sesión de Juego</h2>
        <div class="form-group">
          <label><i class="fas fa-user"></i> Niño:</label>
                     <div class="child-search-container">
                       <input type="text" id="childSearchInput" placeholder="Buscar niño por nombre..." autocomplete="off">
                       <div class="child-search-results" id="childSearchResults"></div>
                       <input type="hidden" id="selectedChildId" value="">
                     </div>
        </div>
        <div class="form-group">
          <label><i class="fas fa-gamepad"></i> Juego:</label>
          <select id="gameSelect">
            <option value="">Seleccione un juego</option>
          </select>
        </div>
        <div class="form-group">
          <label><i class="fas fa-clock"></i> Tiempo (minutos):</label>
          <input type="number" id="durationInput" min="1" max="180" value="15">
        </div>
        <button id="startBtn" type="button">
          <i class="fas fa-play"></i> Iniciar Sesión
        </button>
      </div>

      <!-- Sesiones Activas -->
      <div class="card">
        <h2><i class="fas fa-stopwatch"></i> Sesiones Activas</h2>
        <ul class="list" id="activeSessions">
          <li class="list-item">Cargando sesiones activas...</li>
        </ul>
      </div>

      <!-- Historial -->
      <div class="card">
        <h2><i class="fas fa-history"></i> Historial de Sesiones</h2>
        <ul class="list" id="sessionHistory"></ul>
      </div>
    </div>
  </div>

    <!-- Children Section -->
    <div id="children-section" class="section">
      <div class="grid">
        <!-- Registrar Niño -->
        <div class="card">
          <h2><i class="fas fa-child"></i> Registrar Niño</h2>
            <div class="child-form">
              <div class="form-row">
                <div class="form-group">
                  <label for="childName">Nombre del niño</label>
                  <input type="text" id="childName" placeholder="Ej: Juan" maxlength="30" required>
                </div>
                <div class="form-group">
                  <label for="childNickname">Apodo (opcional)</label>
                  <input type="text" id="childNickname" placeholder="Ej: Juanito" maxlength="20">
                </div>
              </div>
              <div class="form-row">
                <div class="form-group">
                  <label for="fatherName">Nombre del padre (opcional)</label>
                  <input type="text" id="fatherName" placeholder="Ej: Carlos" maxlength="30">
                </div>
                <div class="form-group">
                  <label for="motherName">Nombre de la madre (opcional)</label>
                  <input type="text" id="motherName" placeholder="Ej: María" maxlength="30">
                </div>
              </div>
              <button onclick="addChild()" id="addChildBtn" class="btn-primary">
                <i class="fas fa-plus"></i> AGREGAR NIÑO
              </button>
            </div>
          <ul class="list" id="childrenList"></ul>
        </div>
      </div>
    </div>

    <!-- Games Section -->
    <div id="games-section" class="section">
      <div class="grid">
        <!-- Registrar Juego -->
        <div class="card">
          <h2><i class="fas fa-dice"></i> Registrar Juego</h2>
          <div class="form-row">
            <div class="form-group">
              <input type="text" id="gameName" placeholder="Nombre del juego" maxlength="50">
            </div>
            <div class="form-group">
              <button onclick="addGame()" id="addGameBtn">
                <i class="fas fa-plus"></i> Agregar Juego
              </button>
            </div>
          </div>
          <ul class="list" id="gamesList"></ul>
        </div>
      </div>
    </div>
  </div>
  </div> <!-- Cerrar main-content -->

  <!-- Status Message -->
  <div id="statusMessage" class="status-message">
    <span class="status-text"></span>
    <button class="status-close" onclick="hideStatusMessage()" title="Cerrar">
      <i class="fas fa-times"></i>
    </button>
  </div>

  <!-- Modal -->
  <div id="customModal" class="modal">
    <div class="modal-content">
      <h2 id="modalTitle"><i class="fas fa-bell"></i> ¡Tiempo terminado!</h2>
      <p id="modalMsg"></p>
      <button onclick="closeModal()" class="btn-success">
        <i class="fas fa-check"></i> Entendido
      </button>
    </div>
  </div>

  <!-- Modal de Extensión de Tiempo -->
  <div id="extendModal" class="modal">
    <div class="modal-content">
      <h2><i class="fas fa-clock"></i> Extender Tiempo</h2>
      <p id="extendMsg"></p>
      <div class="form-group">
        <label>Tiempo adicional (minutos):</label>
        <input type="number" id="extendTimeInput" min="1" max="60" value="5">
      </div>
      <div class="modal-buttons">
        <button onclick="confirmExtendTime()" class="btn-success">
          <i class="fas fa-plus"></i> Extender
        </button>
        <button onclick="closeExtendModal()" class="btn-danger">
          <i class="fas fa-times"></i> Cancelar
        </button>
      </div>
    </div>
  </div>

  <!-- Modal de Edición de Niño -->
  <div id="editChildModal" class="modal">
    <div class="modal-content">
      <h2><i class="fas fa-edit"></i> Editar Información del Niño</h2>
      <div class="form-group">
        <label for="editChildName">Nombre del niño:</label>
        <input type="text" id="editChildName" placeholder="Ej: Juan" maxlength="30" required>
      </div>
      <div class="form-group">
        <label for="editChildNickname">Apodo (opcional):</label>
        <input type="text" id="editChildNickname" placeholder="Ej: Juanito" maxlength="20">
      </div>
      <div class="form-group">
        <label for="editFatherName">Nombre del padre (opcional):</label>
        <input type="text" id="editFatherName" placeholder="Ej: Carlos" maxlength="30">
      </div>
      <div class="form-group">
        <label for="editMotherName">Nombre de la madre (opcional):</label>
        <input type="text" id="editMotherName" placeholder="Ej: María" maxlength="30">
      </div>
      <div class="modal-buttons">
        <button onclick="confirmEditChild()" class="btn-success">
          <i class="fas fa-save"></i> Guardar Cambios
        </button>
        <button onclick="closeEditChildModal()" class="btn-danger">
          <i class="fas fa-times"></i> Cancelar
        </button>
      </div>
    </div>
  </div>

  <script>
    // Configuración de API - detectar entorno
    const api = window.location.origin;
    console.log('API URL:', api);
    console.log('Environment:', window.location.hostname);

    // Variables para el dashboard
    let dashboardStats = null;
    
    // Variables para notificaciones
    let notificationPermission = null;
    
    // Variables para atajos de teclado
    let keyboardShortcuts = {
      '1': () => showSection('dashboard'),
      '2': () => showSection('sessions'),
      '3': () => showSection('children'),
      '4': () => showSection('games'),
      'Escape': () => closeModal() || closeExtendModal() || closeEditChildModal(),
      'Delete': () => dismissAllAlerts() // Ctrl+Delete para cerrar todas las alertas
    };

    // Funciones de notificaciones push
    async function requestNotificationPermission() {
      if (!('Notification' in window)) {
        console.log('Este navegador no soporta notificaciones');
        return false;
      }
      
      if (Notification.permission === 'granted') {
        return true;
      }
      
      if (Notification.permission === 'denied') {
        console.log('Notificaciones denegadas por el usuario');
        return false;
      }
      
      const permission = await Notification.requestPermission();
      notificationPermission = permission === 'granted';
      return notificationPermission;
    }

    function showBrowserNotification(title, message, icon = null) {
      if (notificationPermission && 'Notification' in window) {
        const notification = new Notification(title, {
          body: message,
          icon: icon || '/favicon.ico',
          tag: 'temporizador-juegos',
          requireInteraction: true
        });
        
        // Auto-cerrar después de 10 segundos
        setTimeout(() => {
          notification.close();
        }, 10000);
        
        // Cerrar al hacer click
        notification.onclick = () => {
          window.focus();
          notification.close();
        };
      }
    }

    // Funciones de navegación
    function showSection(sectionName) {
      // Ocultar todas las secciones
      document.querySelectorAll('.section').forEach(section => {
        section.classList.remove('active');
      });
      
      // Desactivar todos los botones de navegación
      document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Mostrar la sección seleccionada
      const section = document.getElementById(sectionName + '-section');
      if (section) {
        section.classList.add('active');
      }
      
      // Activar el botón correspondiente (tanto desktop como móvil)
      const desktopNavBtn = document.getElementById('nav-' + sectionName);
      const mobileNavBtn = document.querySelector('.sidebar .nav-btn[id="nav-' + sectionName + '"]');
      
      // Desactivar todos los botones primero
      document.querySelectorAll('.desktop-nav-btn, .nav-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Activar el botón correspondiente
      if (desktopNavBtn) {
        desktopNavBtn.classList.add('active');
      }
      if (mobileNavBtn) {
        mobileNavBtn.classList.add('active');
      }
      
      // Actualizar dashboard si es necesario
      if (sectionName === 'dashboard') {
        updateDashboard();
      }
      
      // Cerrar menú móvil al navegar
      closeMobileMenu();
      
      // Limpiar alertas persistentes al cambiar de sección
      clearAllPersistentAlerts();
      
      // Guardar sección activa en localStorage
      localStorage.setItem('activeSection', sectionName);
    }

    // Funciones del menú móvil
    function toggleMobileMenu() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.querySelector('.sidebar-overlay');
      
      sidebar.classList.toggle('open');
      overlay.classList.toggle('active');
    }

    function closeMobileMenu() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.querySelector('.sidebar-overlay');
      
      sidebar.classList.remove('open');
      overlay.classList.remove('active');
    }

    // Sistema de búsqueda de niños
    function initializeChildSearch() {
      const searchInput = document.getElementById('childSearchInput');
      const searchResults = document.getElementById('childSearchResults');
      const selectedChildId = document.getElementById('selectedChildId');

      if (!searchInput) return;

      let searchTimeout;

      searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim().toLowerCase();

        if (query.length < 2) {
          hideSearchResults();
          return;
        }

        searchTimeout = setTimeout(() => {
          searchChildren(query);
        }, 300);
      });

      searchInput.addEventListener('focus', () => {
        if (searchInput.value.trim().length >= 2) {
          searchChildren(searchInput.value.trim().toLowerCase());
        }
      });

      // Cerrar resultados al hacer clic fuera
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.child-search-container')) {
          hideSearchResults();
        }
      });
    }

    function searchChildren(query) {
      const results = childrenCache.filter(child => {
        const name = (child.displayName || child.name).toLowerCase();
        const fatherName = ((child.father_name || child.fatherName) || '').toLowerCase();
        const motherName = ((child.mother_name || child.motherName) || '').toLowerCase();
        
        return name.includes(query) || 
               fatherName.includes(query) || 
               motherName.includes(query);
      });

      displaySearchResults(results);
    }

    function displaySearchResults(results) {
      const searchResults = document.getElementById('childSearchResults');
      const searchInput = document.getElementById('childSearchInput');

      if (!searchResults || !searchInput) return;

      if (results.length === 0) {
        searchResults.innerHTML = '<div class="no-results">No se encontraron niños</div>';
      } else {
        searchResults.innerHTML = results.map(child => {
          const displayName = child.displayName || child.name;
          const avatar = child.avatar || child.name.charAt(0).toUpperCase();
          
          let parentsInfo = '';
          const fatherName = child.father_name || child.fatherName;
          const motherName = child.mother_name || child.motherName;
          
          if (fatherName && motherName) {
            parentsInfo = `${fatherName} & ${motherName}`;
          } else if (fatherName) {
            parentsInfo = `Papá: ${fatherName}`;
          } else if (motherName) {
            parentsInfo = `Mamá: ${motherName}`;
          }

          return `
            <div class="child-search-item" onclick="selectChild(${child.id}, '${displayName.replace(/'/g, "\\'")}')">
              <div class="child-avatar">${avatar}</div>
              <div class="child-info">
                <div class="child-name">${displayName}</div>
                ${parentsInfo ? `<div class="child-parents">${parentsInfo}</div>` : ''}
              </div>
              <div class="child-stats">${child.totalTimePlayed} min</div>
            </div>
          `;
        }).join('');
      }

      searchResults.classList.add('show');
    }

    function selectChild(childId, childName) {
      const searchInput = document.getElementById('childSearchInput');
      const selectedChildId = document.getElementById('selectedChildId');
      const searchResults = document.getElementById('childSearchResults');

      if (searchInput) {
        searchInput.value = childName;
      }
      if (selectedChildId) {
        selectedChildId.value = childId;
      }

      hideSearchResults();
    }

    function hideSearchResults() {
      const searchResults = document.getElementById('childSearchResults');
      if (searchResults) {
        searchResults.classList.remove('show');
      }
    }

    // Funciones del dashboard
    async function fetchDashboardStats() {
      try {
        const res = await fetchWithRetry(api + '/admin/status');
        if (res.ok) {
          dashboardStats = await res.json();
          return dashboardStats;
        }
      } catch (error) {
        console.error('Error fetching dashboard stats:', error);
      }
      return null;
    }

    function updateDashboard() {
      // Actualizar dashboard con datos del caché local
      renderDashboard();
    }

    function renderDashboard() {
      // Usar datos del caché local para mostrar información real
      const totalChildren = childrenCache.length;
      const totalGames = gamesCache.length;
      const activeSessions = activeSessionsData.length;
      
      // Calcular tiempo total jugado desde el caché - CON DEBUGGING
      let totalTimePlayed = 0;
      console.group('📊 Dashboard Stats Calculation');
      console.log('📊 Children Cache:', childrenCache);
      
      childrenCache.forEach((child, index) => {
        const childTime = child.totalTimePlayed || 0;
        totalTimePlayed += childTime;
        console.log(`👶 Child ${index + 1}:`, {
          name: child.name,
          totalTimePlayed: childTime,
          hasTimeData: !!child.totalTimePlayed
        });
      });
      
      console.log('📊 Total Time Played:', totalTimePlayed);
      console.groupEnd();

      // Actualizar estadísticas principales
      document.getElementById('totalChildren').textContent = totalChildren;
      document.getElementById('totalGames').textContent = totalGames;
      document.getElementById('activeSessionsCount').textContent = activeSessions;
      document.getElementById('totalTimePlayed').textContent = totalTimePlayed;

      // Actualizar ranking de niños basado en tiempo jugado - VERSIÓN MEJORADA
      const childrenRanking = document.getElementById('childrenRanking');
      const sortedChildren = [...childrenCache].sort((a, b) => (b.totalTimePlayed || 0) - (a.totalTimePlayed || 0));
      
      if (sortedChildren.length > 0) {
        childrenRanking.innerHTML = sortedChildren.slice(0, 5).map((child, index) => {
        // Información de padres para diferenciación en el ranking
        let parentsInfo = getParentsInfo(child, 'html');
          
          return `
          <li class="ranking-item">
            <div class="ranking-position">${index + 1}°</div>
              <div class="ranking-name">
                ${child.displayName || child.name}${parentsInfo}
              </div>
            <div class="ranking-time">${child.totalTimePlayed || 0} min</div>
          </li>
          `;
        }).join('');
      } else {
        childrenRanking.innerHTML = '<li class="ranking-item">No hay datos disponibles</li>';
      }

      // Actualizar ranking de juegos (por ahora mostrar todos los juegos)
      const gamesRanking = document.getElementById('gamesRanking');
      if (gamesCache.length > 0) {
        gamesRanking.innerHTML = gamesCache.slice(0, 5).map((game, index) => `
          <li class="ranking-item">
            <div class="ranking-position">${index + 1}°</div>
            <div class="ranking-name">${game.name}</div>
            <div class="ranking-time">-</div>
          </li>
        `).join('');
      } else {
        gamesRanking.innerHTML = '<li class="ranking-item">No hay datos disponibles</li>';
      }
    }

    // Estado de la aplicación - ROBUSTO
    let isLoading = false;
    let activeSessionsData = [];
    let childrenCache = [];
    let gamesCache = [];
    let timerIntervals = new Map();
    let currentExtendSession = null;
    let currentEditChild = null; // Para almacenar el ID del niño que se está editando
    // FUNCIONES DE COMPATIBILIDAD CRÍTICAS - DEBEN ESTAR PRIMERO
    function showStatusMessage(text, type = 'success', sessionId = null, options = {}) {
      console.log(`🔔 showStatusMessage (compatibilidad): ${text} [${type}]`);
      
      // Usar showSmartAlert como función principal
      if (typeof showSmartAlert === 'function') {
        showSmartAlert(text, type, sessionId, options);
      } else {
        // Fallback básico si showSmartAlert no está disponible
        console.warn('⚠️ showSmartAlert no disponible, usando fallback básico');
        
        // Crear elemento de alerta básico
        let msg = document.getElementById('statusMessage');
        if (!msg) {
          msg = document.createElement('div');
          msg.id = 'statusMessage';
          msg.className = 'status-message';
          msg.innerHTML = `
            <span class="status-text"></span>
            <button class="status-close" onclick="hideStatusMessage()" title="Cerrar">
              <i class="fas fa-times"></i>
            </button>
          `;
          document.body.appendChild(msg);
        }
        
        // Mostrar mensaje
        const textSpan = msg.querySelector('.status-text');
        if (textSpan) {
          textSpan.textContent = text;
        }
        
        // Aplicar estilos según tipo
        msg.className = `status-message ${type}`;
        msg.style.display = 'block';
        
        // Auto-ocultar después de 5 segundos
        setTimeout(() => {
          if (msg) {
            msg.style.display = 'none';
          }
        }, 5000);
      }
    }
    

    // Variables globales críticas para el sistema de voz
    let voiceNotificationsEnabled = true; // Control de notificaciones de voz
    let browserNotificationsEnabled = false; // Control de notificaciones del navegador
    let voicePermissionsGranted = true; // Estado de permisos de voz - SIEMPRE TRUE
    let voiceSystemActivated = true; // Estado de activación del sistema de voz - SIEMPRE TRUE
    
    // Sistema de cola de voz para evitar interrupciones
    let voiceQueue = []; // Cola de mensajes de voz pendientes
    let isVoicePlaying = false; // Estado de reproducción actual
    let voiceQueueProcessing = false; // Estado de procesamiento de cola
    
    // Sistema de alertas inteligente para evitar redundancias
    let alertPreferences = {
      showVisualAlerts: true,        // Mostrar alertas visuales
      showVoiceAlerts: true,         // Mostrar alertas de voz
      showBrowserNotifications: true, // Mostrar notificaciones del navegador
      showConfigAlerts: true,        // Mostrar alertas de configuración
      showStatusAlerts: true,        // Mostrar alertas de estado (inicio/fin sesión)
      showErrorAlerts: true,         // Mostrar alertas de error
      showSuccessAlerts: true,       // Mostrar alertas de éxito
      show30SecondAlerts: true      // Mostrar alertas de 30 segundos
    };
    
    // Sistema de alertas adaptativo para evitar contaminación de audio
    let adaptiveAlertSystem = {
      maxConcurrentAlerts: 3,        // Máximo de alertas simultáneas
      alertReductionThreshold: 5,    // Reducir alertas si hay 5+ niños
      singleAlertMode: false,        // Modo de una sola alerta para muchos niños
      audioContaminationPrevention: true // Prevenir contaminación de audio
    };
    
    // Sistema de alertas de tiempo pendientes
    let pendingTimeAlerts = new Map(); // Almacenar alertas de tiempo pendientes
    
    // Variables para control de audio en iOS/Bluetooth
    let audioContextForBluetooth = null;
    let isAudioContextPrepared = false;
    let musicAppDetected = false;
    let lastAudioRouteCheck = 0;
    
    // Asegurar que las variables estén disponibles globalmente
    window.voiceNotificationsEnabled = voiceNotificationsEnabled;
    window.browserNotificationsEnabled = browserNotificationsEnabled;
    window.voicePermissionsGranted = voicePermissionsGranted;
    window.voiceSystemActivated = voiceSystemActivated;

    // FUNCIÓN HELPER PARA EVITAR DUPLICACIÓN DE CÓDIGO
    function getParentsInfo(child, format = 'simple') {
      if (!child) return '';
      
      const fatherName = child.fatherName || child.father_name;
      const motherName = child.motherName || child.mother_name;
      
      if (!fatherName && !motherName) return '';
      
      let parentsInfo = '';
      
      if (format === 'html') {
        // Formato HTML para listas y rankings
        if (fatherName && motherName) {
          parentsInfo = `<br><small class="parents-info"><i class="fas fa-users"></i> ${fatherName} & ${motherName}</small>`;
        } else if (fatherName) {
          parentsInfo = `<br><small class="parents-info"><i class="fas fa-users"></i> Papá: ${fatherName}</small>`;
        } else if (motherName) {
          parentsInfo = `<br><small class="parents-info"><i class="fas fa-users"></i> Mamá: ${motherName}</small>`;
        }
      } else if (format === 'history') {
        // Formato para historial
        if (fatherName && motherName) {
          parentsInfo = `<div class="history-parents"><i class="fas fa-users"></i> ${fatherName} & ${motherName}</div>`;
        } else if (fatherName) {
          parentsInfo = `<div class="history-parents"><i class="fas fa-users"></i> Papá: ${fatherName}</div>`;
        } else if (motherName) {
          parentsInfo = `<div class="history-parents"><i class="fas fa-users"></i> Mamá: ${motherName}</div>`;
        }
      } else {
        // Formato simple (default)
        if (fatherName && motherName) {
          parentsInfo = ` (${fatherName} & ${motherName})`;
        } else if (fatherName) {
          parentsInfo = ` (Papá: ${fatherName})`;
        } else if (motherName) {
          parentsInfo = ` (Mamá: ${motherName})`;
        }
      }
      
      return parentsInfo;
    }

    // ========================================
    // SISTEMA DE AUDIO PARA iOS/BLUETOOTH
    // ========================================

    // Función para preparar AudioContext para Bluetooth (iOS)
    function prepareAudioContextForBluetooth() {
      if (isAudioContextPrepared) {
        console.log('🎵 Audio Context ya está preparado');
        return audioContextForBluetooth;
      }

      try {
        // Crear AudioContext
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) {
          console.log('⚠️ AudioContext no disponible');
          return null;
        }

        audioContextForBluetooth = new AudioContext();
        
        // Crear un tono silencioso para "reservar" el dispositivo de audio
        const oscillator = audioContextForBluetooth.createOscillator();
        const gainNode = audioContextForBluetooth.createGain();
        
        // Configurar como silencioso
        gainNode.gain.value = 0.001; // Casi inaudible
        oscillator.frequency.value = 20000; // Frecuencia muy alta (casi inaudible)
        
        // Conectar
        oscillator.connect(gainNode);
        gainNode.connect(audioContextForBluetooth.destination);
        
        // Reproducir brevemente
        oscillator.start(audioContextForBluetooth.currentTime);
        oscillator.stop(audioContextForBluetooth.currentTime + 0.01);
        
        isAudioContextPrepared = true;
        console.log('✅ Audio Context preparado para Bluetooth');
        
        return audioContextForBluetooth;
      } catch (error) {
        console.log('⚠️ Error preparando Audio Context:', error.message);
        return null;
      }
    }

    // Función para detectar si hay música reproduciéndose
    async function detectMusicAppPlaying() {
      try {
        // Intentar detectar si hay audio de otras aplicaciones
        if ('mediaSession' in navigator && navigator.mediaSession.playbackState) {
          const playbackState = navigator.mediaSession.playbackState;
          musicAppDetected = (playbackState === 'playing');
          console.log(`🎵 Estado de reproducción de música: ${playbackState}`);
          return musicAppDetected;
        }
        
        // Fallback: detectar por Audio Context
        if (audioContextForBluetooth) {
          const state = audioContextForBluetooth.state;
          if (state === 'suspended') {
            musicAppDetected = true;
            console.log('🎵 Audio Context suspendido - posible música reproduciéndose');
            return true;
          }
        }
        
        return false;
      } catch (error) {
        console.log('⚠️ Error detectando música:', error.message);
        return false;
      }
    }

    // Función para intentar tomar control del dispositivo de audio
    async function takeAudioDeviceControl() {
      try {
        // Preparar Audio Context si no está listo
        if (!audioContextForBluetooth || audioContextForBluetooth.state === 'closed') {
          prepareAudioContextForBluetooth();
        }

        // Intentar reanudar Audio Context
        if (audioContextForBluetooth && audioContextForBluetooth.state === 'suspended') {
          await audioContextForBluetooth.resume();
          console.log('🔊 Audio Context reanudado');
        }

        // Reproducir un tono breve para "activar" el dispositivo Bluetooth
        if (audioContextForBluetooth && audioContextForBluetooth.state === 'running') {
          const oscillator = audioContextForBluetooth.createOscillator();
          const gainNode = audioContextForBluetooth.createGain();
          
          // Tono audible pero breve para "despertar" Bluetooth
          oscillator.frequency.value = 800;
          gainNode.gain.value = 0.3;
          gainNode.gain.exponentialRampToValueAtTime(
            0.01, 
            audioContextForBluetooth.currentTime + 0.1
          );
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContextForBluetooth.destination);
          
          oscillator.start(audioContextForBluetooth.currentTime);
          oscillator.stop(audioContextForBluetooth.currentTime + 0.1);
          
          console.log('🔊 Señal de audio enviada para activar Bluetooth');
        }

        return true;
      } catch (error) {
        console.log('⚠️ Error tomando control de audio:', error.message);
        return false;
      }
    }

    // Función para verificar y mostrar alerta si hay conflicto de audio
    async function checkAudioConflict() {
      const now = Date.now();
      
      // Limitar verificaciones (no más de una cada 2 segundos)
      if (now - lastAudioRouteCheck < 2000) {
        return false;
      }
      
      lastAudioRouteCheck = now;
      
      // Detectar si hay música
      const hasMusicPlaying = await detectMusicAppPlaying();
      
      if (hasMusicPlaying) {
        console.log('⚠️ Música detectada - El audio de la app podría no salir por Bluetooth');
        
        // Mostrar alerta visual discreta (sin interrumpir)
        showSmartAlert(
          '🎵 Música detectada: El audio podría salir por las bocinas del dispositivo en lugar del bafle Bluetooth',
          'info',
          null,
          { 
            voiceOnly: false,
            timeout: 5000,
            position: 'bottom'
          }
        );
        
        return true;
      }
      
      return false;
    }

    // ========================================
    // FIN SISTEMA DE AUDIO PARA iOS/BLUETOOTH
    // ========================================

    // Función para detectar género por nombre - FUNCIÓN SIMPLE Y ESTABLE
    function detectGenderByName(name) {
      if (!name || typeof name !== 'string') {
        return 'unknown';
      }
      
      const normalizedName = name.toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '');
      
      const femaleNames = [
        'sofia', 'maria', 'ana', 'lucia', 'carla', 'laura', 'isabella', 'valentina',
        'camila', 'natalia', 'andrea', 'paula', 'fernanda', 'alejandra', 'diana'
      ];
      
      const maleNames = [
        'david', 'mathias', 'cristian', 'ramon', 'santiago', 'carlos', 'juan', 'pedro',
        'miguel', 'antonio', 'jose', 'manuel', 'francisco', 'alejandro', 'daniel'
      ];
      
      if (femaleNames.includes(normalizedName)) {
        return 'female';
      }
      if (maleNames.includes(normalizedName)) {
        return 'male';
      }
      
      return 'unknown';
    }

    // Función para detectar el navegador
    function detectBrowser() {
      const userAgent = navigator.userAgent.toLowerCase();
      if (userAgent.includes('safari') && !userAgent.includes('chrome')) {
        return 'safari';
      } else if (userAgent.includes('firefox')) {
        return 'firefox';
      } else if (userAgent.includes('chrome')) {
        return 'chrome';
      } else if (userAgent.includes('edge')) {
        return 'edge';
      }
      return 'unknown';
    }

    // Función helper para seleccionar voz femenina en español (optimizada por navegador)
    function getFemaleSpanishVoice() {
      const browser = detectBrowser();
      console.log('🌐 Navegador detectado:', browser);
      
      // Intentar cargar voces si no están disponibles
      let voices = window.speechSynthesis.getVoices();
      
      // Si no hay voces cargadas, intentar forzar la carga
      if (voices.length === 0) {
        console.log('🔄 Forzando carga de voces...');
        // En algunos navegadores necesitamos hacer esto
        window.speechSynthesis.getVoices();
        voices = window.speechSynthesis.getVoices();
      }
      
      const spanishVoices = voices.filter(voice => voice.lang.startsWith('es'));
      
      console.log('🎙️ Todas las voces en español:', spanishVoices.map(v => ({ name: v.name, lang: v.lang, localService: v.localService })));
      
      // Lista de nombres masculinos a excluir (ampliada para Chrome)
      const maleNames = ['eddy', 'carlos', 'juan', 'diego', 'male', 'men', 'man', 'masculino', 'antonio', 'miguel', 'pedro', 'jose', 'manuel', 'rafael', 'daniel', 'andres', 'roberto', 'fernando', 'eduardo', 'alejandro', 'sergio', 'pablo', 'mario', 'ricardo', 'alberto', 'enrique', 'ramon', 'javier', 'gabriel', 'luis', 'felipe', 'sebastian', 'adrian', 'david', 'paulina', 'paul', 'pablo', 'peter', 'patrick', 'philip', 'phillip'];
      
      // Función para verificar si una voz es masculina
      const isMaleVoice = (voiceName) => {
        return maleNames.some(maleName => voiceName.toLowerCase().includes(maleName));
      };
      
      // Función ULTRA ESTRICTA para seleccionar solo voces humanas reales
      const isQualityVoice = (voice) => {
        const voiceName = voice.name.toLowerCase();
        const lang = voice.lang.toLowerCase();
        
        // CRITERIOS ULTRA ESTRICTOS PARA SONIDO HUMANO:
        const hasSpanishAccent = lang.includes('es-es') || lang.includes('es-mx') || lang.startsWith('es');
        const isLocal = voice.localService;
        
        // EVITAR TODAS las voces robóticas/artificiales
        const notRobotic = !['robot', 'artificial', 'neural', 'tts', 'synthetic', 'digital', 'machine', 'auto', 'generated', 'system', 'speak', 'voice', 'speech', 'sapi', 'espeak', 'festival', 'mary', 'enhanced', 'premium', 'cloud'].some(flag => voiceName.includes(flag));
        
        // SOLO nombres que suenen 100% humanos
        const isHuman = ['maria', 'monica', 'lucia', 'sofia', 'carmen', 'ana', 'laura', 'isabel', 'teresa', 'paula', 'claudia', 'natalia', 'veronica', 'patricia', 'cristina', 'rosa', 'elena'].some(name => voiceName.includes(name));
        
        // ADICIONAL: preferir voces con nombres reales de personas
        const hasRealPersonName = voiceName.match(/\b(maria|monica|lucia|sofia|carmen|ana|laura|isabel|teresa|paula|claudia|natalia|veronica|patricia|cristina|rosa|elena)\b/);
        
        return hasSpanishAccent && isLocal && notRobotic && isHuman && hasRealPersonName;
      };
      
      // SELECCIÓN ULTRA ESTRICTA: solo voces que suenen 100% humanas
      let selectedVoice = spanishVoices.find(voice => {
        const voiceName = voice.name.toLowerCase();
        const isNotMale = !isMaleVoice(voiceName);
        const isQuality = isQualityVoice(voice);
        
        // ADICIONAL: Verificar que NO sea Paulina (es-MX) que suena masculina en Chrome
        const isNotPaulinaMX = !(voiceName.includes('paulina') && voice.lang.includes('es-MX'));
        
        return isNotMale && isQuality && isNotPaulinaMX;
      });
      
      // FALLBACK 1: voces con nombres reales pero menos estricto
      if (!selectedVoice) {
        selectedVoice = spanishVoices.find(voice => {
          const voiceName = voice.name.toLowerCase();
          const isNotMale = !isMaleVoice(voiceName);
          const isRealName = ['maria', 'monica', 'lucia', 'sofia', 'carmen', 'ana', 'laura', 'isabel', 'teresa', 'paula', 'claudia'].some(name => voiceName.includes(name));
          const isNotPaulinaMX = !(voiceName.includes('paulina') && voice.lang.includes('es-MX'));
          return isNotMale && isRealName && isNotPaulinaMX;
        });
      }
      
      // FALLBACK 2: cualquier voz femenina que no sea claramente robótica
      if (!selectedVoice) {
        selectedVoice = spanishVoices.find(voice => {
          const voiceName = voice.name.toLowerCase();
          const isNotMale = !isMaleVoice(voiceName);
          const notObviouslyRobotic = !['robot', 'artificial', 'neural', 'tts', 'synthetic', 'digital', 'machine', 'auto', 'generated'].some(flag => voiceName.includes(flag));
          const isNotPaulinaMX = !(voiceName.includes('paulina') && voice.lang.includes('es-MX'));
          return isNotMale && notObviouslyRobotic && isNotPaulinaMX;
        });
      }
      
      // Último recurso: usar primera voz disponible que NO sea claramente masculina
      if (!selectedVoice && spanishVoices.length > 0) {
        selectedVoice = spanishVoices.find(voice => {
          const voiceName = voice.name.toLowerCase();
          const isNotMale = !isMaleVoice(voiceName);
          const isNotPaulinaMX = !(voiceName.includes('paulina') && voice.lang.includes('es-MX'));
          return isNotMale && isNotPaulinaMX;
        }) || spanishVoices[0];
      }
      
      // Verificar una vez más que la voz seleccionada no sea masculina o Paulina (es-MX)
      if (selectedVoice && (isMaleVoice(selectedVoice.name) || (selectedVoice.name.toLowerCase().includes('paulina') && selectedVoice.lang.includes('es-MX')))) {
        console.warn('⚠️ Voz seleccionada es masculina o Paulina (es-MX), buscando alternativa...');
        selectedVoice = spanishVoices.find(voice => {
          const voiceName = voice.name.toLowerCase();
          const isNotMale = !isMaleVoice(voiceName);
          const isNotPaulinaMX = !(voiceName.includes('paulina') && voice.lang.includes('es-MX'));
          return isNotMale && isNotPaulinaMX && voice !== selectedVoice;
        });
      }
      
      // MEJORA ADICIONAL: Ajustar configuración de voz según navegador
      if (selectedVoice && browser !== 'safari') {
        // Para navegadores no-Safari, aplicar ajustes adicionales de calidad
        console.log(`🔧 Aplicando optimizaciones de pronunciación para ${browser}`);
        
        // Asegurar que la voz tenga la mejor configuración posible
        if (selectedVoice.lang && !selectedVoice.lang.includes('es-ES')) {
          console.log(`🌍 Ajustando idioma de voz de ${selectedVoice.lang} a es-ES`);
        }
      }
      
      console.log('👩 Voz femenina seleccionada:', selectedVoice ? `${selectedVoice.name} (${selectedVoice.lang})` : 'ninguna');
      return selectedVoice;
    }

    // Sistema de voz híbrido para sonido humano en TODOS los navegadores
    function getVoiceParameters() {
      const browser = detectBrowser();
      
      // Configuración UNIVERSAL para sonido humano en todos los navegadores
      const universalConfig = {
        rate: 0.75,      // Velocidad óptima para sonido humano
        pitch: 1.15,     // Pitch óptimo para sonido humano
        volume: 0.9,     // Volumen óptimo
        lang: 'es-ES'    // Idioma español
      };
      
      // Ajustes específicos por navegador para maximizar sonido humano
      const browserAdjustments = {
        safari: { rate: 0.9, pitch: 1.1, volume: 0.8 },      // Safari ya excelente
        firefox: { rate: 0.65, pitch: 1.25, volume: 0.95 },   // Firefox - más lento y pitch más alto
        chrome: { rate: 0.8, pitch: 1.2, volume: 0.85 },      // Chrome - velocidad media, pitch alto
        edge: { rate: 0.8, pitch: 1.2, volume: 0.85 },         // Edge - igual que Chrome
        default: { rate: 0.75, pitch: 1.15, volume: 0.9 }   // Fallback universal
      };
      
      const params = { ...universalConfig, ...browserAdjustments[browser] || browserAdjustments.default };
      
      // POST-PROCESAMIENTO UNIVERSAL para sonido humano máximo
      if (browser === 'firefox') {
        // Firefox - parámetros optimizados para sonido más natural
        params.rate = Math.max(params.rate * 0.9, 0.55); // Más lento para sonar más humano
        params.pitch = Math.min(params.pitch * 1.05, 1.35); // Pitch moderadamente más alto
        params.volume = Math.min(params.volume * 1.05, 1.0); // Volumen ligeramente más alto
      } else if (browser === 'chrome' || browser === 'edge') {
        // Chrome/Edge - parámetros optimizados para mejor pronunciación
        params.rate = Math.max(params.rate * 0.95, 0.7); // Ligeramente más lento para claridad
        params.pitch = Math.min(params.pitch * 1.08, 1.3); // Pitch ligeramente más alto para naturalidad
        params.volume = Math.min(params.volume * 1.02, 1.0); // Volumen ligeramente más alto
      }
      
      return params;
    }

    // Función de prueba COMPLETA para evaluar calidad de voz en todos los navegadores
    function testAllBrowsersVoiceQuality() {
      const browser = detectBrowser();
      console.log(`🧪 INICIANDO PRUEBA DE CALIDAD DE VOZ PARA ${browser.toUpperCase()}`);
      
      const testPhrases = [
        "Hola, soy una prueba de voz natural",
        "El tiempo de juego ha terminado",
        "María, tu sesión ha finalizado",
        "David Carlos, es hora de terminar"
      ];
      
      let currentPhrase = 0;
      
      function testNextPhrase() {
        if (currentPhrase >= testPhrases.length) {
          console.log(`✅ PRUEBA COMPLETADA PARA ${browser.toUpperCase()}`);
          console.log(`📊 EVALUACIÓN REQUERIDA:`);
          console.log(`   - ¿La voz suena natural y humana?`);
          console.log(`   - ¿El acento español es correcto?`);
          console.log(`   - ¿La velocidad es apropiada?`);
          console.log(`   - ¿Comparado con Safari, ¿qué tal?`);
          return;
        }
        
        const phrase = testPhrases[currentPhrase];
        console.log(`🎤 Prueba ${currentPhrase + 1}/${testPhrases.length}: "${phrase}"`);
        
        // Obtener parámetros actuales
        const voiceParams = getVoiceParameters();
        console.log(`⚙️ Parámetros actuales:`, voiceParams);
        
        // Obtener voz seleccionada
        const selectedVoice = getFemaleSpanishVoice();
        console.log(`🎭 Voz seleccionada:`, selectedVoice ? `${selectedVoice.name} (${selectedVoice.lang})` : 'ninguna');
        
        const utterance = new SpeechSynthesisUtterance(phrase);
        utterance.lang = voiceParams.lang;
        utterance.rate = voiceParams.rate;
        utterance.pitch = voiceParams.pitch;
        utterance.volume = voiceParams.volume;
        
        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }
        
        utterance.onend = () => {
          setTimeout(() => {
            currentPhrase++;
            testNextPhrase();
          }, 2000);
        };
        
        utterance.onerror = (event) => {
          console.error(`❌ Error en síntesis de voz:`, event);
          currentPhrase++;
          setTimeout(() => testNextPhrase(), 1000);
        };
        
        addToGlobalVoiceQueue(utterance.text || 'Test message', {
          volume: utterance.volume,
          rate: utterance.rate,
          pitch: utterance.pitch,
          lang: utterance.lang
        });
      }
      
      testNextPhrase();
    }
    
    // Función para probar diferentes configuraciones y encontrar la óptima
    function testVoiceConfigurations() {
      const browser = detectBrowser();
      console.log(`🔬 PRUEBA DE CONFIGURACIONES PARA ${browser.toUpperCase()}`);
      
      const configurations = [
        { rate: 0.3, pitch: 1.5, name: 'EXTREMO lento + pitch muy alto' },
        { rate: 0.4, pitch: 1.4, name: 'MUY lento + pitch alto (actual Firefox)' },
        { rate: 0.5, pitch: 1.3, name: 'Muy lento + pitch alto (actual Chrome)' },
        { rate: 0.6, pitch: 1.2, name: 'Lento + pitch medio-alto' },
        { rate: 0.7, pitch: 1.1, name: 'Medio-lento + pitch medio' }
      ];
      
      let currentConfig = 0;
      
      function testNextConfig() {
        if (currentConfig >= configurations.length) {
          console.log(`🎯 PRUEBA DE CONFIGURACIONES COMPLETADA`);
          console.log(`📝 SELECCIONA LA CONFIGURACIÓN QUE SUENA MÁS HUMANA:`);
          configurations.forEach((config, index) => {
            console.log(`   ${index + 1}. ${config.name} (rate: ${config.rate}, pitch: ${config.pitch})`);
          });
          return;
        }
        
        const config = configurations[currentConfig];
        console.log(`🎛️ Probando configuración ${currentConfig + 1}: ${config.name}`);
        console.log(`   Rate: ${config.rate}, Pitch: ${config.pitch}`);
        
        const utterance = new SpeechSynthesisUtterance(`Prueba ${currentConfig + 1}: ${config.name}`);
        utterance.lang = 'es-ES';
        utterance.rate = config.rate;
        utterance.pitch = config.pitch;
        utterance.volume = 0.8;
        
        const selectedVoice = getFemaleSpanishVoice();
        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }
        
        utterance.onend = () => {
          setTimeout(() => {
            currentConfig++;
            testNextConfig();
          }, 3000);
        };
        
        addToGlobalVoiceQueue(utterance.text || 'Test message', {
          volume: utterance.volume,
          rate: utterance.rate,
          pitch: utterance.pitch,
          lang: utterance.lang
        });
      }
      
      testNextConfig();
    }
    
    // Función de prueba EXTREMA para encontrar la configuración más humana
    function testExtremeVoiceConfigurations() {
      const browser = detectBrowser();
      console.log(`🔥 PRUEBA EXTREMA DE CONFIGURACIONES PARA ${browser.toUpperCase()}`);
      
      const extremeConfigurations = [
        { rate: 0.2, pitch: 1.6, name: 'ULTRA lento + pitch máximo' },
        { rate: 0.3, pitch: 1.5, name: 'EXTREMO lento + pitch muy alto' },
        { rate: 0.4, pitch: 1.4, name: 'MUY lento + pitch alto' },
        { rate: 0.5, pitch: 1.3, name: 'Lento + pitch alto' },
        { rate: 0.6, pitch: 1.2, name: 'Medio-lento + pitch medio-alto' }
      ];
      
      let currentConfig = 0;
      
      function testNextConfig() {
        if (currentConfig >= extremeConfigurations.length) {
          console.log(`🎯 PRUEBA EXTREMA COMPLETADA`);
          console.log(`📝 SELECCIONA LA CONFIGURACIÓN MÁS HUMANA:`);
          extremeConfigurations.forEach((config, index) => {
            console.log(`   ${index + 1}. ${config.name} (rate: ${config.rate}, pitch: ${config.pitch})`);
          });
          return;
        }
        
        const config = extremeConfigurations[currentConfig];
        console.log(`🔥 Probando configuración EXTREMA ${currentConfig + 1}: ${config.name}`);
        console.log(`   Rate: ${config.rate}, Pitch: ${config.pitch}`);
        
        const utterance = new SpeechSynthesisUtterance(`Prueba extrema ${currentConfig + 1}: ${config.name}`);
        utterance.lang = 'es-ES';
        utterance.rate = config.rate;
        utterance.pitch = config.pitch;
        utterance.volume = 0.9;
        
        const selectedVoice = getFemaleSpanishVoice();
        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }
        
        utterance.onend = () => {
          setTimeout(() => {
            currentConfig++;
            testNextConfig();
          }, 4000);
        };
        
        addToGlobalVoiceQueue(utterance.text || 'Test message', {
          volume: utterance.volume,
          rate: utterance.rate,
          pitch: utterance.pitch,
          lang: utterance.lang
        });
      }
      
      testNextConfig();
    }
    
    // Función de prueba ULTRA EXTREMA específica para Firefox
    function testFirefoxUltraExtreme() {
      if (detectBrowser() !== 'firefox') {
        console.log('⚠️ Esta función es específica para Firefox');
        return;
      }
      
      console.log(`🔥 PRUEBA ULTRA EXTREMA PARA FIREFOX`);
      
      const firefoxUltraConfigurations = [
        { rate: 0.1, pitch: 1.8, name: 'ULTRA lento + pitch máximo' },
        { rate: 0.2, pitch: 1.7, name: 'EXTREMO lento + pitch muy alto' },
        { rate: 0.3, pitch: 1.6, name: 'MUY lento + pitch alto (actual)' },
        { rate: 0.4, pitch: 1.5, name: 'Lento + pitch alto' },
        { rate: 0.5, pitch: 1.4, name: 'Medio-lento + pitch alto' }
      ];
      
      let currentConfig = 0;
      
      function testNextConfig() {
        if (currentConfig >= firefoxUltraConfigurations.length) {
          console.log(`🎯 PRUEBA ULTRA EXTREMA DE FIREFOX COMPLETADA`);
          console.log(`📝 SELECCIONA LA CONFIGURACIÓN MÁS HUMANA PARA FIREFOX:`);
          firefoxUltraConfigurations.forEach((config, index) => {
            console.log(`   ${index + 1}. ${config.name} (rate: ${config.rate}, pitch: ${config.pitch})`);
          });
          return;
        }
        
        const config = firefoxUltraConfigurations[currentConfig];
        console.log(`🔥 Firefox Ultra Extremo ${currentConfig + 1}: ${config.name}`);
        console.log(`   Rate: ${config.rate}, Pitch: ${config.pitch}`);
        
        const utterance = new SpeechSynthesisUtterance(`Firefox ultra ${currentConfig + 1}: ${config.name}`);
        utterance.lang = 'es-ES';
        utterance.rate = config.rate;
        utterance.pitch = config.pitch;
        utterance.volume = 0.95;
        
        const selectedVoice = getFemaleSpanishVoice();
        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }
        
        utterance.onend = () => {
          setTimeout(() => {
            currentConfig++;
            testNextConfig();
          }, 5000);
        };
        
        addToGlobalVoiceQueue(utterance.text || 'Test message', {
          volume: utterance.volume,
          rate: utterance.rate,
          pitch: utterance.pitch,
          lang: utterance.lang
        });
      }
      
      testNextConfig();
    }
    
    // Sistema de voz híbrido para sonido humano universal
    function getHybridVoiceSystem() {
      const browser = detectBrowser();
      
      // Estrategia 1: Parámetros optimizados por navegador
      const optimizedParams = getVoiceParameters();
      
      // Estrategia 2: Selección de voz inteligente
      const selectedVoice = getFemaleSpanishVoice();
      
      // Estrategia 3: Configuración híbrida universal
      const hybridConfig = {
        // Parámetros base universales
        rate: optimizedParams.rate,
        pitch: optimizedParams.pitch,
        volume: optimizedParams.volume,
        lang: 'es-ES',
        voice: selectedVoice,
        
        // Configuración adicional para sonido humano
        emphasis: 'strong',        // Énfasis fuerte para sonido humano
        pause: 0.1,              // Pausa entre palabras
        breath: true,            // Simular respiración
        natural: true            // Modo natural
      };
      
      return hybridConfig;
    }
    
    // Sistema de cola de voz para evitar interrupciones
    function addToVoiceQueue(message, options = {}) {
      console.log(`📝 Agregando a cola de voz: "${message}"`);
      
      // VERIFICACIÓN CRÍTICA: NUNCA agregar mensajes de error a la cola de voz
      const errorPhrases = [
        'Por favor seleccione un niño',
        'Por favor seleccione un juego',
        'El tiempo debe ser',
        'El tiempo mínimo',
        'El tiempo máximo',
        'Error al',
        'debe ser un número válido',
        'Validation failed'
      ];
      
      const isErrorMessage = errorPhrases.some(phrase => message.includes(phrase));
      if (isErrorMessage) {
        console.log(`🔇 BLOQUEADO: Mensaje de error detectado, no se agregará a la cola de voz: "${message}"`);
        return;
      }
      
      // Validar que no se agreguen mensajes duplicados muy seguidos
      const now = Date.now();
      const lastMessage = voiceQueue[voiceQueue.length - 1];
      if (lastMessage && lastMessage.message === message && (now - lastMessage.timestamp) < 2000) {
        console.log(`⚠️ Mensaje duplicado detectado, saltando: "${message}"`);
        return;
      }
      
      // Agregar mensaje a la cola
      voiceQueue.push({
        message: message,
        options: options,
        timestamp: now,
        id: Math.random().toString(36).substr(2, 9) // ID único para tracking
      });
      
      console.log(`📊 Cola actual: ${voiceQueue.length} mensajes pendientes`);
      
      // Procesar cola si no está en proceso
      if (!voiceQueueProcessing) {
        processVoiceQueue();
      }
    }
    
    function processVoiceQueue() {
      if (voiceQueueProcessing || voiceQueue.length === 0) {
        return;
      }
      
      voiceQueueProcessing = true;
      console.log(`🔄 Procesando cola de voz (${voiceQueue.length} mensajes pendientes)`);
      
      function playNextInQueue() {
        if (voiceQueue.length === 0) {
          voiceQueueProcessing = false;
          isVoicePlaying = false;
          console.log(`✅ Cola de voz completada`);
          return;
        }
        
        const voiceItem = voiceQueue.shift();
        console.log(`🎤 Reproduciendo: "${voiceItem.message}" (ID: ${voiceItem.id})`);
        
        // VERIFICACIÓN CRÍTICA: Bloquear mensajes de error en playNextInQueue
        const errorPhrases = [
          'Validation failed',
          'Por favor seleccione un niño',
          'Por favor seleccione un juego',
          'El tiempo debe ser',
          'El tiempo mínimo',
          'El tiempo máximo',
          'Error al',
          'debe ser un número válido',
          'Test message'
        ];
        
        const isErrorMessage = errorPhrases.some(phrase => voiceItem.message.includes(phrase));
        if (isErrorMessage) {
          console.log(`🔇 BLOQUEADO EN playNextInQueue: Mensaje de error detectado: "${voiceItem.message}"`);
          // Continuar con el siguiente mensaje sin reproducir este
          playNextInQueue();
          return;
        }
        
        isVoicePlaying = true;
        
        // NO cancelar speechSynthesis aquí - respetar mensaje en curso
        const utterance = createHybridUtterance(voiceItem.message, voiceItem.options.alertCount || 1);
        
        utterance.onstart = () => {
          console.log(`🔊 Audio iniciado: "${voiceItem.message}" (ID: ${voiceItem.id})`);
        };
        
        utterance.onend = () => {
          console.log(`✅ Mensaje completado: "${voiceItem.message}" (ID: ${voiceItem.id})`);
          isVoicePlaying = false;
          
          // Pausa entre mensajes para evitar solapamiento
          const pauseTime = 800; // 800ms entre mensajes
          console.log(`⏸️ Pausa de ${pauseTime}ms antes del siguiente mensaje...`);
          setTimeout(playNextInQueue, pauseTime);
        };
        
        utterance.onerror = (e) => {
          console.error(`❌ Error en mensaje: "${voiceItem.message}" (ID: ${voiceItem.id})`, e);
          console.log(`🔍 Tipo de error: ${e.error}, CharIndex: ${e.charIndex}`);
          
          isVoicePlaying = false;
          
          // Si es error de interrupción, esperar más tiempo
          const delay = e.error === 'interrupted' ? 2000 : 500;
          console.log(`⏳ Error ${e.error}, esperando ${delay}ms antes de continuar...`);
          
          setTimeout(playNextInQueue, delay);
        };
        
        // Reproducir sin cancelar audio previo
        addToGlobalVoiceQueue(utterance.text || 'Test message', {
          volume: utterance.volume,
          rate: utterance.rate,
          pitch: utterance.pitch,
          lang: utterance.lang
        });
      }
      
      playNextInQueue();
    }
    
    // Función de voz híbrida mejorada con sistema de cola
    function speakWithHybridVoice(message, options = {}) {
      console.log(`🎤 SISTEMA DE VOZ HÍBRIDA CON COLA ACTIVADO`);
      console.log(`📊 Mensaje: "${message}"`);
      console.log(`📊 Estado actual: isVoicePlaying=${isVoicePlaying}, queueLength=${voiceQueue.length}`);
      
      // Agregar a cola en lugar de reproducir inmediatamente
      addToVoiceQueue(message, options);
      
      return {
        message: message,
        queued: true,
        queuePosition: voiceQueue.length
      };
    }
    
    // Función de evaluación del sistema híbrido
    function evaluateHybridVoiceSystem() {
      const browser = detectBrowser();
      console.log(`🔍 EVALUACIÓN DEL SISTEMA DE VOZ HÍBRIDA PARA ${browser.toUpperCase()}`);
      
      const hybridConfig = getHybridVoiceSystem();
      
      console.log(`📊 CONFIGURACIÓN HÍBRIDA:`);
      console.log(`   Rate: ${hybridConfig.rate}`);
      console.log(`   Pitch: ${hybridConfig.pitch}`);
      console.log(`   Volume: ${hybridConfig.volume}`);
      console.log(`   Voice: ${hybridConfig.voice ? hybridConfig.voice.name : 'Sistema'}`);
      console.log(`   Lang: ${hybridConfig.lang}`);
      
      console.log(`🎯 ESTRATEGIAS ACTIVAS:`);
      console.log(`   1. Parámetros optimizados por navegador`);
      console.log(`   2. Selección inteligente de voz`);
      console.log(`   3. Configuración híbrida universal`);
      console.log(`   4. Modulación específica por navegador`);
      
      console.log(`💡 PRUEBA EL SISTEMA HÍBRIDO:`);
      console.log(`   speakWithHybridVoice("Prueba del sistema híbrido")`);
    }
    
    // Función de prueba exhaustiva del sistema híbrido en producción
    function testHybridSystemExhaustive() {
      console.log(`🔥 PRUEBA EXHAUSTIVA DEL SISTEMA HÍBRIDO EN PRODUCCIÓN`);
      console.log(`📅 Fecha: ${new Date().toLocaleString()}`);
      
      const browser = detectBrowser();
      console.log(`🌐 Navegador detectado: ${browser}`);
      
      // Test 1: Verificar funciones híbridas
      console.log(`\n🧪 TEST 1: VERIFICACIÓN DE FUNCIONES HÍBRIDAS`);
      try {
        const hybridConfig = getHybridVoiceSystem();
        console.log(`✅ getHybridVoiceSystem(): OK`);
        console.log(`   Configuración:`, hybridConfig);
        
        if (typeof speakWithHybridVoice === 'function') {
          console.log(`✅ speakWithHybridVoice(): OK`);
        } else {
          console.error(`❌ speakWithHybridVoice(): NO DISPONIBLE`);
        }
        
        if (typeof evaluateHybridVoiceSystem === 'function') {
          console.log(`✅ evaluateHybridVoiceSystem(): OK`);
        } else {
          console.error(`❌ evaluateHybridVoiceSystem(): NO DISPONIBLE`);
        }
      } catch (error) {
        console.error(`❌ ERROR en funciones híbridas:`, error);
      }
      
      // Test 2: Verificar integración con funciones existentes
      console.log(`\n🧪 TEST 2: INTEGRACIÓN CON FUNCIONES EXISTENTES`);
      try {
        if (typeof speakChildName === 'function') {
          console.log(`✅ speakChildName(): DISPONIBLE`);
        } else {
          console.error(`❌ speakChildName(): NO DISPONIBLE`);
        }
        
        if (typeof speakWithRepetition === 'function') {
          console.log(`✅ speakWithRepetition(): DISPONIBLE`);
        } else {
          console.error(`❌ speakWithRepetition(): NO DISPONIBLE`);
        }
        
        if (typeof speakAlertWithRepetitionFixed === 'function') {
          console.log(`✅ speakAlertWithRepetitionFixed(): DISPONIBLE`);
        } else {
          console.error(`❌ speakAlertWithRepetitionFixed(): NO DISPONIBLE`);
        }
      } catch (error) {
        console.error(`❌ ERROR en integración:`, error);
      }
      
      // Test 3: Verificar sistema de voz
      console.log(`\n🧪 TEST 3: SISTEMA DE VOZ`);
      try {
        if ('speechSynthesis' in window) {
          console.log(`✅ Speech Synthesis: DISPONIBLE`);
          console.log(`   Voces disponibles: ${speechSynthesis.getVoices().length}`);
          
          const spanishVoices = speechSynthesis.getVoices().filter(v => v.lang.startsWith('es'));
          console.log(`   Voces en español: ${spanishVoices.length}`);
          
          if (spanishVoices.length > 0) {
            console.log(`   Primera voz ES: ${spanishVoices[0].name} (${spanishVoices[0].lang})`);
          }
        } else {
          console.error(`❌ Speech Synthesis: NO DISPONIBLE`);
        }
      } catch (error) {
        console.error(`❌ ERROR en sistema de voz:`, error);
      }
      
      // Test 4: Verificar variables globales
      console.log(`\n🧪 TEST 4: VARIABLES GLOBALES`);
      try {
        console.log(`   voiceNotificationsEnabled: ${voiceNotificationsEnabled}`);
        console.log(`   voiceSystemActivated: ${voiceSystemActivated}`);
        console.log(`   browserNotificationsEnabled: ${browserNotificationsEnabled}`);
        console.log(`   voicePermissionsGranted: ${voicePermissionsGranted}`);
      } catch (error) {
        console.error(`❌ ERROR en variables globales:`, error);
      }
      
      // Test 5: Prueba de voz híbrida
      console.log(`\n🧪 TEST 5: PRUEBA DE VOZ HÍBRIDA`);
      try {
        console.log(`🎤 Iniciando prueba de voz híbrida...`);
        speakWithHybridVoice("Prueba del sistema híbrido en producción");
        console.log(`✅ Prueba de voz híbrida iniciada`);
      } catch (error) {
        console.error(`❌ ERROR en prueba de voz:`, error);
      }
      
      console.log(`\n🎯 RESUMEN DE PRUEBA EXHAUSTIVA:`);
      console.log(`   Sistema híbrido: ${typeof getHybridVoiceSystem === 'function' ? 'OK' : 'ERROR'}`);
      console.log(`   Voz híbrida: ${typeof speakWithHybridVoice === 'function' ? 'OK' : 'ERROR'}`);
      console.log(`   Integración: ${typeof speakChildName === 'function' ? 'OK' : 'ERROR'}`);
      console.log(`   Speech Synthesis: ${'speechSynthesis' in window ? 'OK' : 'ERROR'}`);
      
      return {
        hybridSystem: typeof getHybridVoiceSystem === 'function',
        hybridVoice: typeof speakWithHybridVoice === 'function',
        integration: typeof speakChildName === 'function',
        speechSynthesis: 'speechSynthesis' in window,
        browser: browser
      };
    }
    
    // Función de prueba crítica para producción
    function testProductionCritical() {
      console.log(`🚨 PRUEBA CRÍTICA DE PRODUCCIÓN - SISTEMA HÍBRIDO`);
      console.log(`⏰ ${new Date().toLocaleString()}`);
      
      const results = {
        critical: true,
        timestamp: new Date().toISOString(),
        tests: {}
      };
      
      // Test crítico 1: Verificar que todas las funciones existen
      console.log(`\n🔍 TEST CRÍTICO 1: EXISTENCIA DE FUNCIONES`);
      const criticalFunctions = [
        'getHybridVoiceSystem',
        'speakWithHybridVoice', 
        'createHybridUtterance',
        'speakChildName',
        'speakWithRepetition',
        'speakAlertWithRepetitionFixed'
      ];
      
      criticalFunctions.forEach(funcName => {
        const exists = typeof window[funcName] === 'function';
        results.tests[funcName] = exists;
        console.log(`${exists ? '✅' : '❌'} ${funcName}: ${exists ? 'OK' : 'ERROR'}`);
      });
      
      // Test crítico 2: Verificar configuración híbrida
      console.log(`\n🔍 TEST CRÍTICO 2: CONFIGURACIÓN HÍBRIDA`);
      try {
        const config = getHybridVoiceSystem();
        const hasRequiredProps = config.rate && config.pitch && config.volume && config.lang;
        results.tests.hybridConfig = hasRequiredProps;
        console.log(`${hasRequiredProps ? '✅' : '❌'} Configuración híbrida: ${hasRequiredProps ? 'OK' : 'ERROR'}`);
        console.log(`   Rate: ${config.rate}, Pitch: ${config.pitch}, Volume: ${config.volume}, Lang: ${config.lang}`);
      } catch (error) {
        results.tests.hybridConfig = false;
        console.error(`❌ ERROR en configuración híbrida:`, error);
      }
      
      // Test crítico 3: Verificar Speech Synthesis
      console.log(`\n🔍 TEST CRÍTICO 3: SPEECH SYNTHESIS`);
      const hasSpeechSynthesis = 'speechSynthesis' in window;
      results.tests.speechSynthesis = hasSpeechSynthesis;
      console.log(`${hasSpeechSynthesis ? '✅' : '❌'} Speech Synthesis: ${hasSpeechSynthesis ? 'OK' : 'ERROR'}`);
      
      if (hasSpeechSynthesis) {
        const voices = speechSynthesis.getVoices();
        const spanishVoices = voices.filter(v => v.lang.startsWith('es'));
        console.log(`   Voces totales: ${voices.length}`);
        console.log(`   Voces en español: ${spanishVoices.length}`);
      }
      
      // Test crítico 4: Verificar variables globales críticas
      console.log(`\n🔍 TEST CRÍTICO 4: VARIABLES GLOBALES`);
      const globalVars = [
        'voiceNotificationsEnabled',
        'voiceSystemActivated', 
        'browserNotificationsEnabled'
      ];
      
      globalVars.forEach(varName => {
        const exists = typeof window[varName] !== 'undefined';
        results.tests[varName] = exists;
        console.log(`${exists ? '✅' : '❌'} ${varName}: ${exists ? 'OK' : 'ERROR'}`);
      });
      
      // Test crítico 5: Prueba de voz real
      console.log(`\n🔍 TEST CRÍTICO 5: PRUEBA DE VOZ REAL`);
      try {
        console.log(`🎤 Ejecutando prueba de voz híbrida...`);
        speakWithHybridVoice("Prueba crítica del sistema híbrido en producción");
        results.tests.voiceTest = true;
        console.log(`✅ Prueba de voz ejecutada`);
      } catch (error) {
        results.tests.voiceTest = false;
        console.error(`❌ ERROR en prueba de voz:`, error);
      }
      
      // Resumen crítico
      const allTestsPassed = Object.values(results.tests).every(test => test === true);
      results.allTestsPassed = allTestsPassed;
      
      console.log(`\n🚨 RESUMEN CRÍTICO:`);
      console.log(`   Estado general: ${allTestsPassed ? '✅ SISTEMA OK' : '❌ ERRORES DETECTADOS'}`);
      console.log(`   Tests pasados: ${Object.values(results.tests).filter(t => t).length}/${Object.keys(results.tests).length}`);
      
      if (!allTestsPassed) {
        console.error(`🚨 ERRORES CRÍTICOS DETECTADOS EN PRODUCCIÓN:`);
        Object.entries(results.tests).forEach(([test, passed]) => {
          if (!passed) {
            console.error(`   ❌ ${test}: FALLO`);
          }
        });
      }
      
      return results;
    }
    
    // Funciones auxiliares para sistema de alertas inteligente
    function showVoiceAlert(text, type, options) {
      console.log('🔊 showVoiceAlert llamado con:', { text, type, options });
      
      // VERIFICACIÓN CRÍTICA: NUNCA reproducir voz para errores
      if (type === 'error' || type === 'danger') {
        console.log('🔇 BLOQUEADO: showVoiceAlert cancelado porque el tipo es error/danger');
        return;
      }
      
      // VERIFICACIÓN CRÍTICA: NUNCA reproducir voz si voiceOnly es explícitamente false
      if (options.voiceOnly === false) {
        console.log('🔇 BLOQUEADO: showVoiceAlert cancelado porque voiceOnly es false');
        return;
      }
      
      if (options.consolidated && options.pendingAlerts) {
        // Para alertas consolidadas, usar el sistema de repetición
        console.log('🔊 Usando speakAlertWithRepetitionFixed para alertas consolidadas');
        speakAlertWithRepetitionFixed(options.pendingAlerts, options.alertCount);
      } else {
        // Para alertas simples, usar voz híbrida
        console.log('🔊 Usando speakWithHybridVoice para alerta simple:', text);
        speakWithHybridVoice(text);
      }
    }
    
    function getNotificationTitle(type) {
      switch (type) {
        case 'warning': return '⏰ Tiempo de Juego Terminado';
        case 'error': return '❌ Error';
        case 'success': return '✅ Éxito';
        case 'info': return 'ℹ️ Información';
        default: return '🔔 Notificación';
      }
    }
    
    // Función para configurar preferencias de alertas
    function configureAlertPreferences(preferences) {
      alertPreferences = { ...alertPreferences, ...preferences };
      console.log('🔧 Preferencias de alertas actualizadas:', alertPreferences);
    }
    
    // Función de prueba del sistema de cola de voz
    function testVoiceQueue() {
      console.log(`🧪 PRUEBA DEL SISTEMA DE COLA DE VOZ`);
      console.log(`📊 Estado inicial: isVoicePlaying=${isVoicePlaying}, queueLength=${voiceQueue.length}`);
      
      // Limpiar cola existente
      voiceQueue = [];
      isVoicePlaying = false;
      voiceQueueProcessing = false;
      
      // Simular escenario de múltiples niños terminando tiempo
      console.log(`🎯 Simulando escenario: Niño A termina tiempo`);
      speakWithHybridVoice("Niño A terminó su tiempo de juego");
      
      setTimeout(() => {
        console.log(`🎯 Simulando escenario: Niño B termina tiempo (debería ir a cola)`);
        speakWithHybridVoice("Niño B terminó su tiempo de juego");
      }, 2000);
      
      setTimeout(() => {
        console.log(`🎯 Simulando escenario: Niño C termina tiempo (debería ir a cola)`);
        speakWithHybridVoice("Niño C terminó su tiempo de juego");
      }, 4000);
      
      console.log(`📝 Prueba iniciada - observa que NO hay interrupciones`);
      console.log(`📊 Estado final: isVoicePlaying=${isVoicePlaying}, queueLength=${voiceQueue.length}`);
    }
    
    // Función de prueba del sistema de alertas inteligente
    function testSmartAlerts() {
      console.log(`🧪 PRUEBA DEL SISTEMA DE ALERTAS INTELIGENTE`);
      console.log(`📊 Preferencias actuales:`, alertPreferences);
      
      // Probar diferentes tipos de alertas
      console.log(`\n🎯 Probando alertas con preferencias actuales:`);
      
      showSmartAlert("Esta es una alerta de éxito", 'success');
      showSmartAlert("Esta es una alerta de información", 'info');
      showSmartAlert("Esta es una alerta de advertencia", 'warning');
      showSmartAlert("Esta es una alerta de error", 'error');
      
      console.log(`\n🔧 Cambiando preferencias para mostrar todas las alertas:`);
      configureAlertPreferences({
        showSuccessAlerts: true,
        showStatusAlerts: true,
        showConfigAlerts: true
      });
      
      console.log(`\n🎯 Probando alertas con todas habilitadas:`);
      showSmartAlert("Ahora deberías ver esta alerta de éxito", 'success');
      showSmartAlert("Y esta alerta de información", 'info');
    }
    
    // Función de prueba del sistema adaptativo de alertas
    function testAdaptiveAlertSystem() {
      console.log(`🧪 PRUEBA DEL SISTEMA ADAPTATIVO DE ALERTAS`);
      console.log(`📊 Sistema adaptativo actual:`, adaptiveAlertSystem);
      
      // Probar diferentes escenarios de cantidad de niños
      console.log(`\n🎯 Probando escenarios de contaminación de audio:`);
      
      // Escenario 1: 1 niño
      console.log(`\n📝 ESCENARIO 1: 1 niño terminando tiempo`);
      speakWithRepetition("Niño A terminó su tiempo de juego", 1);
      
      setTimeout(() => {
        // Escenario 2: 3 niños
        console.log(`\n📝 ESCENARIO 2: 3 niños terminando tiempo`);
        speakWithRepetition("Niños A, B, C terminaron su tiempo de juego", 3);
      }, 5000);
      
      setTimeout(() => {
        // Escenario 3: 5 niños
        console.log(`\n📝 ESCENARIO 3: 5 niños terminando tiempo`);
        speakWithRepetition("5 niños terminaron su tiempo de juego", 5);
      }, 10000);
      
      setTimeout(() => {
        // Escenario 4: 8 niños (contaminación de audio)
        console.log(`\n📝 ESCENARIO 4: 8 niños terminando tiempo (modo consolidado)`);
        speakWithRepetition("8 niños terminaron su tiempo de juego", 8);
      }, 15000);
      
      console.log(`📝 Prueba adaptativa iniciada - observa la reducción de repeticiones`);
    }
    
    // Función para configurar el sistema adaptativo
    function configureAdaptiveSystem(settings) {
      adaptiveAlertSystem = { ...adaptiveAlertSystem, ...settings };
      console.log('🔧 Sistema adaptativo actualizado:', adaptiveAlertSystem);
    }
    

    // Función de diagnóstico para problemas de inicio de sesión
    function diagnoseSessionStart() {
      console.log('🔍 DIAGNÓSTICO DE INICIO DE SESIÓN');
      console.log('=====================================');
      
      // Verificar estado de la aplicación
      console.log('📊 Estado de la aplicación:');
      console.log('- AppState:', AppState);
      console.log('- isStartingSession:', AppState?.isStartingSession);
      
      // Verificar datos de niños
      console.log('👶 Datos de niños:');
      console.log('- childrenCache.length:', childrenCache.length);
      console.log('- childrenCache:', childrenCache);
      
      // Verificar datos de juegos
      console.log('🎮 Datos de juegos:');
      console.log('- gamesCache.length:', gamesCache.length);
      console.log('- gamesCache:', gamesCache);
      
      // Verificar elementos del formulario
      console.log('📝 Elementos del formulario:');
      const selectedChildId = document.getElementById('selectedChildId');
      const gameSelect = document.getElementById('gameSelect');
      const durationInput = document.getElementById('durationInput');
      
      console.log('- selectedChildId:', selectedChildId?.value || 'NO ENCONTRADO');
      console.log('- gameSelect:', gameSelect?.value || 'NO ENCONTRADO');
      console.log('- durationInput:', durationInput?.value || 'NO ENCONTRADO');
      
      // Verificar opciones disponibles
      if (selectedChildId) {
        console.log('- Opciones de niños disponibles:', selectedChildId.options.length);
        for (let i = 0; i < selectedChildId.options.length; i++) {
          console.log(`  ${i}: ${selectedChildId.options[i].value} - ${selectedChildId.options[i].text}`);
        }
      }
      
      if (gameSelect) {
        console.log('- Opciones de juegos disponibles:', gameSelect.options.length);
        for (let i = 0; i < gameSelect.options.length; i++) {
          console.log(`  ${i}: ${gameSelect.options[i].value} - ${gameSelect.options[i].text}`);
        }
      }
      
      // Verificar conectividad
      console.log('🌐 Conectividad:');
      console.log('- API URL:', api);
      console.log('- fetchWithRetry disponible:', typeof fetchWithRetry);
      
      // Verificar errores en consola
      console.log('❌ Errores recientes:');
      console.log('- Revisar consola para errores de red o JavaScript');
      
      console.log('=====================================');
      console.log('🔍 DIAGNÓSTICO COMPLETADO');
      
      return {
        appState: AppState,
        childrenCount: childrenCache.length,
        gamesCount: gamesCache.length,
        selectedChild: selectedChildId?.value,
        selectedGame: gameSelect?.value,
        duration: durationInput?.value
      };
    }
    
    // Hacer funciones disponibles globalmente para pruebas
    window.testAllBrowsersVoiceQuality = testAllBrowsersVoiceQuality;
    window.testVoiceConfigurations = testVoiceConfigurations;
    window.testExtremeVoiceConfigurations = testExtremeVoiceConfigurations;
    window.testFirefoxUltraExtreme = testFirefoxUltraExtreme;
    window.evaluateHybridVoiceSystem = evaluateHybridVoiceSystem;
    window.speakWithHybridVoice = speakWithHybridVoice;
    window.testHybridSystemExhaustive = testHybridSystemExhaustive;
    window.testProductionCritical = testProductionCritical;
    window.testVoiceQueue = testVoiceQueue;
    window.testSmartAlerts = testSmartAlerts;
    window.configureAlertPreferences = configureAlertPreferences;
    window.testAdaptiveAlertSystem = testAdaptiveAlertSystem;
    window.configureAdaptiveSystem = configureAdaptiveSystem;
    window.diagnoseSessionStart = diagnoseSessionStart;


    // ============================================================================
    // FUNCIONES DE SEGURIDAD CRÍTICAS PARA PRODUCCIÓN
    // ============================================================================
    
    // Sanitización HTML para prevenir XSS
    function sanitizeHTML(str) {
      if (typeof str !== 'string') return '';
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
    
    // Validación robusta de entrada
    function validateInput(input, type, min = null, max = null) {
      if (typeof input !== 'string') return null;
      
      const trimmed = input.trim();
      if (trimmed.length === 0) return null;
      
      switch (type) {
        case 'name':
          // Solo letras, espacios, números y caracteres básicos
          if (!/^[a-zA-ZáéíóúÁÉÍÓÚñÑ\s\d\-\.]+$/.test(trimmed)) return null;
          if (trimmed.length < 1 || trimmed.length > 50) return null;
          break;
        case 'number':
          const num = parseInt(trimmed);
          if (isNaN(num)) return null;
          if (min !== null && num < min) return null;
          if (max !== null && num > max) return null;
          return num;
        case 'id':
          const id = parseInt(trimmed);
          if (isNaN(id) || id <= 0) return null;
          return id;
        default:
          return trimmed;
      }
      
      return trimmed;
    }
    
    // Validación específica para duración
    function validateDuration(input) {
      const duration = validateInput(input, 'number', 1, 1440); // 1 min a 24 horas
      if (duration === null) {
        throw new Error('Duración inválida. Debe ser un número entre 1 y 1440 minutos.');
      }
      return duration;
    }
    
    // Validación específica para IDs
    function validateId(input, fieldName) {
      const id = validateInput(input, 'id');
      if (id === null) {
        throw new Error(`${fieldName} inválido. Debe ser un número positivo.`);
      }
      return id;
    }
    
    // Validación específica para nombres
    function validateName(input, fieldName) {
      const name = validateInput(input, 'name');
      if (name === null) {
        throw new Error(`${fieldName} inválido. Solo se permiten letras, números y espacios.`);
      }
      return name;
    }
    
    // Circuit Breaker para APIs
    class CircuitBreaker {
      constructor(threshold = 5, timeout = 60000) {
        this.failures = 0;
        this.threshold = threshold;
        this.timeout = timeout;
        this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
        this.nextAttempt = Date.now();
      }
      
      async execute(fn) {
        if (this.state === 'OPEN') {
          if (Date.now() < this.nextAttempt) {
            throw new Error('Circuit breaker is OPEN. Servicio temporalmente no disponible.');
          }
          this.state = 'HALF_OPEN';
        }
        
        try {
          const result = await fn();
          this.onSuccess();
          return result;
        } catch (error) {
          this.onFailure();
          throw error;
        }
      }
      
      onSuccess() {
        this.failures = 0;
        this.state = 'CLOSED';
      }
      
      onFailure() {
        this.failures++;
        if (this.failures >= this.threshold) {
          this.state = 'OPEN';
          this.nextAttempt = Date.now() + this.timeout;
        }
      }
    }
    
    // Circuit breakers por endpoint
    const circuitBreakers = {
      children: new CircuitBreaker(3, 30000),
      games: new CircuitBreaker(3, 30000),
      sessions: new CircuitBreaker(3, 30000)
    };
    
    // Rate Limiting para operaciones del usuario
    class RateLimiter {
      constructor(maxRequests = 10, windowMs = 60000) {
        this.maxRequests = maxRequests;
        this.windowMs = windowMs;
        this.requests = [];
      }
      
      canMakeRequest() {
        const now = Date.now();
        // Limpiar requests antiguos
        this.requests = this.requests.filter(time => now - time < this.windowMs);
        
        if (this.requests.length >= this.maxRequests) {
          return false;
        }
        
        this.requests.push(now);
        return true;
      }
      
      getTimeUntilReset() {
        if (this.requests.length === 0) return 0;
        const oldestRequest = Math.min(...this.requests);
        return Math.max(0, this.windowMs - (Date.now() - oldestRequest));
      }
    }
    
    const rateLimiter = new RateLimiter(15, 60000); // 15 requests por minuto
    
    // Función para verificar rate limit antes de operaciones
    function checkRateLimit(operation) {
      if (!rateLimiter.canMakeRequest()) {
        const timeLeft = Math.ceil(rateLimiter.getTimeUntilReset() / 1000);
        throw new Error(`Demasiadas solicitudes. Espere ${timeLeft} segundos antes de intentar nuevamente.`);
      }
    }
    let isInitialized = false;
    let isFirstLoad = true;
    let alertedSessions = new Set(); // Para evitar alertas duplicadas
    // Sistema de alertas individuales - sin consolidación
    
    // SISTEMA DE COLA DE VOZ PARA EVITAR INTERRUPCIONES
    // (Variables ya declaradas anteriormente)
    
    // SISTEMA ADAPTATIVO DE ALERTAS
    // (Variable ya declarada anteriormente con más funcionalidades)

    // Sistema de alertas inteligente para evitar redundancias
    function showSmartAlert(text, type = 'success', sessionId = null, options = {}) {
      console.log(`🔔 showSmartAlert LLAMADA: "${text}" [${type}] sessionId: ${sessionId}`, options);
      
      // VERIFICACIÓN SUPREMA: BLOQUEAR ABSOLUTAMENTE CUALQUIER MENSAJE DE ERROR DE VOZ
      const errorPhrases = [
        'Validation failed',
        'Por favor seleccione un niño',
        'Por favor seleccione un juego',
        'El tiempo debe ser',
        'El tiempo mínimo',
        'El tiempo máximo',
        'Error al',
        'debe ser un número válido'
      ];
      
      const containsErrorPhrase = errorPhrases.some(phrase => text.includes(phrase));
      if (containsErrorPhrase) {
        console.log(`🔇 BLOQUEADO EN SHOWSMARTALERT: Mensaje contiene frase de error: "${text}"`);
        type = 'error'; // Forzar tipo error
        options = { ...options, voiceOnly: false }; // Forzar sin voz
      }
      
      // REGLA CRÍTICA: ERRORES NUNCA TIENEN VOZ - SIN EXCEPCIONES
      if (type === 'error' || type === 'danger') {
        console.log('🔇 TIPO ERROR DETECTADO - VOZ COMPLETAMENTE DESACTIVADA');
        options = { ...options, voiceOnly: false };
      }
      
      // VERIFICACIÓN CRÍTICA TEMPRANA: Si voiceOnly es false, desactivar voz inmediatamente
      if (options.voiceOnly === false) {
        console.log('🔇 VERIFICACIÓN TEMPRANA - VOZ DESACTIVADA por voiceOnly: false');
        // Asegurar que la opción esté correctamente configurada
        options = { ...options, voiceOnly: false };
      }
      
      // Verificar preferencias de alertas
      if (!shouldShowAlert(type, options)) {
        console.log(`🔇 Alerta suprimida por preferencias: ${text}`);
        return;
      }
      console.log(`✅ Alerta aprobada por preferencias: ${text}`);
      
      // SISTEMA INTELIGENTE DE CONSOLIDACIÓN DE ALERTAS
      if (type === 'warning' && text.includes('quedan solo') && text.includes('segundos')) {
        handleTimeAlert(text, sessionId, options);
        return;
      }
      
      // Determinar qué tipo de alerta mostrar
      const alertTypes = determineAlertTypes(type, options);
      
      // Mostrar alerta visual si está habilitada
      if (alertTypes.visual) {
        showVisualAlert(text, type, sessionId);
      }
      
      // Mostrar alerta de voz si está habilitada
      // VERIFICACIÓN ADICIONAL: Si voiceOnly es false O es un error, nunca activar la voz
      if (alertTypes.voice && voiceNotificationsEnabled && options.voiceOnly !== false && type !== 'error' && type !== 'danger') {
        showVoiceAlert(text, type, options);
      } else if (options.voiceOnly === false || type === 'error' || type === 'danger') {
        console.log('🔇 VOZ DESACTIVADA EXPLÍCITAMENTE - Razón:', type === 'error' || type === 'danger' ? 'TIPO ERROR' : 'voiceOnly: false');
      }
      
      // Mostrar notificación del navegador si está habilitada
      if (alertTypes.browser && browserNotificationsEnabled) {
        showBrowserNotification(getNotificationTitle(type), text);
      }
    }
    
    // SISTEMA INTELIGENTE DE CONSOLIDACIÓN DE ALERTAS DE TIEMPO
    function handleTimeAlert(text, sessionId, options) {
      console.log(`🧠 SISTEMA INTELIGENTE: Procesando alerta de tiempo: "${text}"`);
      
      // Extraer información del niño de la alerta
      const childName = extractChildNameFromAlert(text);
      const timeLeft = extractTimeFromAlert(text);
      
      if (!childName) {
        console.log(`⚠️ No se pudo extraer nombre del niño de: "${text}"`);
        showVisualAlert(text, 'warning', sessionId);
        return;
      }
      
      // Agregar a alertas pendientes
      pendingTimeAlerts.set(childName, {
        text: text,
        sessionId: sessionId,
        timeLeft: timeLeft,
        timestamp: Date.now()
      });
      
      console.log(`📊 Procesando alerta individual para: ${childName}`);
      
      // MOSTRAR ALERTA VISUAL INMEDIATAMENTE (SIN DEBOUNCING)
      showVisualAlert(text, 'warning', sessionId);
      
      // NO LLAMAR showConsolidatedTimeAlert aquí - solo se debe llamar cuando realmente termina el tiempo
      // timeAlertTimeout = setTimeout(() => {
      //   showConsolidatedTimeAlert();
      // }, 2000); // Esperar 2 segundos para consolidar
    }
    
    // Extraer nombre del niño de la alerta - FUNCIÓN CORREGIDA PARA PADRES
    function extractChildNameFromAlert(text) {
      if (!text || typeof text !== 'string') {
        console.log(`⚠️ extractChildNameFromAlert: texto inválido`);
        return null;
      }
      
      // Regex corregida que maneja formato con información de padres
      // Patrón: "A mathias (harrison & ximena) le quedan" → extraer "mathias"
      const match = text.match(/A\s+([a-zA-ZáéíóúÁÉÍÓÚñÑüÜ\s]+?)\s*\([^)]*\)\s+le\s+quedan/);
      if (match) {
        const name = match[1].trim();
        console.log(`✅ extractChildNameFromAlert: nombre extraído: "${name}"`);
        return name;
      }
      
      // Fallback: patrón original sin información de padres
      const fallbackMatch = text.match(/A\s+([a-zA-ZáéíóúÁÉÍÓÚñÑüÜ\s]+?)\s+le\s+quedan/);
      if (fallbackMatch) {
        const name = fallbackMatch[1].trim();
        console.log(`✅ extractChildNameFromAlert: nombre extraído (fallback): "${name}"`);
        return name;
      }
      
      console.log(`❌ extractChildNameFromAlert: no se pudo extraer nombre de: "${text}"`);
      return null;
    }
    
    // Extraer tiempo restante de la alerta
    function extractTimeFromAlert(text) {
      const match = text.match(/(\d+)\s+segundos/);
      return match ? parseInt(match[1]) : 0;
    }
    
    // Mostrar alerta consolidada de tiempo - FUNCIÓN UNIFICADA
    function showConsolidatedTimeAlert(childName, parentsInfo) {
      console.log(`🧠 CONSOLIDANDO ALERTA DE TIEMPO: ${childName}`);
      
      // Crear clave única usando nombre + padres para evitar duplicados
      const uniqueKey = `${childName}|${parentsInfo || 'sin_padres'}`;
      
      // Ya no necesitamos agregar a pendingTimeAlerts - procesamos inmediatamente
      
      // MEJORA PARA iOS/BLUETOOTH: Verificar conflictos de audio antes de hablar
      checkAudioConflict().catch(err => {
        console.log('⚠️ Error verificando conflicto de audio:', err.message);
      });
      
      // PROCESAR INMEDIATAMENTE LA ALERTA INDIVIDUAL
      console.log(`🔊 PROCESANDO ALERTA INDIVIDUAL PARA: ${childName}`);
      
      // Crear alerta individual para esta sesión específica
      const individualAlert = {
        name: childName,
        parents: parentsInfo
      };
      
      console.log(`📊 ALERTA INDIVIDUAL:`, individualAlert);
      
      // Activar notificaciones de voz SIEMPRE
      console.log(`🔊 ACTIVANDO NOTIFICACIÓN DE VOZ INDIVIDUAL`);
      speakAlertWithRepetitionFixed([individualAlert], 1);
    }
    
    // FUNCIÓN PARA REPRODUCIR MENSAJE DE VOZ DIRECTAMENTE - URGENTE
    async function playVoiceMessage(message, options = {}) {
      console.log(`🔊 playVoiceMessage: "${message}"`);
      
      return new Promise((resolve) => {
        // FORZAR ACTIVACIÓN DE AUDIO - URGENTE
        console.log(`🚨 FORZANDO ACTIVACIÓN DE AUDIO URGENTE`);
        
        // NO cancelar aquí - respetar cola secuencial
        // speechSynthesis.cancel();
        
        // Esperar un momento para asegurar cancelación
        setTimeout(() => {
          // Crear utterance con configuración URGENTE
          const utterance = new SpeechSynthesisUtterance(message);
          
          // CONFIGURACIÓN NATURAL Y INTELIGENTE
          utterance.volume = 0.9; // Volumen alto pero no máximo
          utterance.rate = 0.8;   // Velocidad natural y clara
          utterance.pitch = 1.1;  // Pitch ligeramente más alto para claridad
          utterance.lang = 'es-ES';
          
          // AGREGAR PAUSAS NATURALES AL MENSAJE
          const messageWithPauses = message
            .replace(/\./g, '. ')  // Pausa después de puntos
            .replace(/,/g, ', ')    // Pausa después de comas
            .replace(/:/g, ': ');   // Pausa después de dos puntos
          
          utterance.text = messageWithPauses;
          
          // Configurar voz con fallback URGENTE
          const voice = getFemaleSpanishVoice();
          if (voice) {
            utterance.voice = voice;
            console.log(`🔊 Voz seleccionada: ${voice.name} (${voice.lang})`);
          } else {
            // FALLBACK URGENTE - usar cualquier voz disponible
            const voices = speechSynthesis.getVoices();
            if (voices.length > 0) {
              utterance.voice = voices[0];
              console.log(`🚨 FALLBACK URGENTE: Usando voz ${voices[0].name}`);
            }
          }
          
          // Eventos con diagnóstico URGENTE
          utterance.onstart = () => {
            console.log(`🔊 AUDIO INICIADO: "${message}"`);
            console.log(`🚨 VERIFICAR VOLUMEN DEL NAVEGADOR Y SISTEMA`);
          };
          
          utterance.onend = () => {
            console.log(`🔊 AUDIO TERMINADO: "${message}"`);
            console.log(`🚨 SI NO SE ESCUCHA: Verificar volumen del navegador`);
            resolve();
          };
          
          utterance.onerror = (event) => {
            console.error(`❌ ERROR DE AUDIO URGENTE:`, event.error);
            console.log(`🚨 DIAGNÓSTICO URGENTE:`, {
              error: event.error,
              message: message,
              voicesAvailable: speechSynthesis.getVoices().length,
              voiceSystemActivated: voiceSystemActivated,
              browserMuted: document.muted || false
            });
            resolve();
          };
          
          // FORZAR REPRODUCCIÓN URGENTE
          console.log(`🚨 INICIANDO REPRODUCCIÓN URGENTE: "${message}"`);
          console.log(`🚨 INSTRUCCIONES URGENTES:`);
          console.log(`   1. Verificar que el volumen del navegador esté activado`);
          console.log(`   2. Verificar que el volumen del sistema esté activado`);
          console.log(`   3. Verificar que la pestaña no esté silenciada`);
          
          addToGlobalVoiceQueue(utterance.text || 'Test message', {
          volume: utterance.volume,
          rate: utterance.rate,
          pitch: utterance.pitch,
          lang: utterance.lang
        });
          
          // TIMEOUT URGENTE - forzar resolución si no hay respuesta
          setTimeout(() => {
            console.log(`🚨 TIMEOUT URGENTE: Forzando resolución`);
            resolve();
          }, 10000); // 10 segundos timeout
          
        }, 100); // Pequeño delay para asegurar cancelación
      });
    }
    
    // FUNCIÓN DE PRUEBA URGENTE DE AUDIO
    function testAudioUrgent() {
      console.log(`🚨 PRUEBA URGENTE DE AUDIO`);
      console.log(`🚨 INSTRUCCIONES URGENTES:`);
      console.log(`   1. Hacer clic en la pestaña del navegador`);
      console.log(`   2. Verificar que no esté silenciada (icono de altavoz)`);
      console.log(`   3. Verificar volumen del sistema`);
      console.log(`   4. Hacer clic en "VOZ ACTIVADA" para probar`);
      
      // Probar audio inmediatamente
      const testMessage = "PRUEBA URGENTE DE AUDIO - Si escuchas esto, el sistema funciona";
      playVoiceMessage(testMessage);
    }
    
    // Hacer función global para pruebas urgentes
    window.testAudioUrgent = testAudioUrgent;
    
    // PRUEBA DE ESTRÉS COMPLETA - TODOS LOS ESCENARIOS
    function runStressTest() {
      console.log(`🚨 INICIANDO PRUEBA DE ESTRÉS COMPLETA`);
      console.log(`🚨 PROBANDO TODOS LOS ESCENARIOS DE VOZ`);
      
      // ESCENARIO 1: Un niño
      console.log(`\n📝 ESCENARIO 1: Un niño`);
      const scenario1 = [{
        text: "¡Atención! A sofia le quedan solo 5 segundos",
        sessionId: 1,
        timeLeft: 5,
        timestamp: Date.now()
      }];
      speakAlertWithRepetitionFixed(scenario1, 1);
      
      setTimeout(() => {
        // ESCENARIO 2: Dos niños
        console.log(`\n📝 ESCENARIO 2: Dos niños`);
        const scenario2 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 3, timestamp: Date.now() }
        ];
        speakAlertWithRepetitionFixed(scenario2, 2);
      }, 3000);
      
      setTimeout(() => {
        // ESCENARIO 3: Tres niños
        console.log(`\n📝 ESCENARIO 3: Tres niños`);
        const scenario3 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 3, timestamp: Date.now() },
          { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 2, timestamp: Date.now() }
        ];
        speakAlertWithRepetitionFixed(scenario3, 3);
      }, 6000);
      
      setTimeout(() => {
        // ESCENARIO 4: Cinco niños
        console.log(`\n📝 ESCENARIO 4: Cinco niños`);
        const scenario4 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 3, timestamp: Date.now() },
          { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 2, timestamp: Date.now() },
          { text: "¡Atención! A cristian le quedan solo 1 segundo", sessionId: 4, timeLeft: 1, timestamp: Date.now() },
          { text: "¡Atención! A ramon le quedan solo 1 segundo", sessionId: 5, timeLeft: 1, timestamp: Date.now() }
        ];
        speakAlertWithRepetitionFixed(scenario4, 5);
      }, 9000);
      
      setTimeout(() => {
        // ESCENARIO 5: Seis niños (consolidado)
        console.log(`\n📝 ESCENARIO 5: Seis niños (consolidado)`);
        const scenario5 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 3, timestamp: Date.now() },
          { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 2, timestamp: Date.now() },
          { text: "¡Atención! A cristian le quedan solo 1 segundo", sessionId: 4, timeLeft: 1, timestamp: Date.now() },
          { text: "¡Atención! A ramon le quedan solo 1 segundo", sessionId: 5, timeLeft: 1, timestamp: Date.now() },
          { text: "¡Atención! A santiago le quedan solo 1 segundo", sessionId: 6, timeLeft: 1, timestamp: Date.now() }
        ];
        speakAlertWithRepetitionFixed(scenario5, 6);
      }, 12000);
      
      console.log(`🚨 PRUEBA DE ESTRÉS INICIADA - VERIFICAR CONSOLA Y AUDIO`);
    }
    
    // Hacer función global para prueba de estrés
    window.runStressTest = runStressTest;
    
    // DIAGNÓSTICO COMPLETO DEL SISTEMA DE VOZ
    function diagnoseVoiceSystem() {
      console.log(`🔍 DIAGNÓSTICO COMPLETO DEL SISTEMA DE VOZ`);
      console.log(`==========================================`);
      
      // 1. VERIFICAR ESTADO DEL SISTEMA
      console.log(`\n📊 ESTADO DEL SISTEMA:`);
      console.log(`  - voiceNotificationsEnabled: ${voiceNotificationsEnabled}`);
      console.log(`  - voiceSystemActivated: ${voiceSystemActivated}`);
      console.log(`  - speechSynthesis disponible: ${typeof speechSynthesis !== 'undefined'}`);
      console.log(`  - voces disponibles: ${speechSynthesis.getVoices().length}`);
      console.log(`  - adaptiveAlertSystem.enabled: ${adaptiveAlertSystem.enabled}`);
      
      // 2. PROBAR EXTRACCIÓN DE NOMBRES
      console.log(`\n🧪 PROBANDO EXTRACCIÓN DE NOMBRES:`);
      const testTexts = [
        "¡Atención! A sofia le quedan solo 5 segundos",
        "¡Atención! A david le quedan solo 3 segundos",
        "¡Atención! A mathias le quedan solo 2 segundos"
      ];
      
      testTexts.forEach((text, index) => {
        const name = extractChildNameFromAlert(text);
        const gender = detectGenderByName(name);
        console.log(`  ${index + 1}. "${text}" → Nombre: "${name}", Género: "${gender}"`);
      });
      
      // 3. PROBAR GENERACIÓN DE MENSAJES
      console.log(`\n🎯 PROBANDO GENERACIÓN DE MENSAJES:`);
      
      // Escenario 1: Un niño
      const scenario1 = [{ text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() }];
      const message1 = generateNaturalVoiceMessage(scenario1, 1);
      console.log(`  ESCENARIO 1: "${message1}"`);
      
      // Escenario 2: Dos niños
      const scenario2 = [
        { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() },
        { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 3, timestamp: Date.now() }
      ];
      const message2 = generateNaturalVoiceMessage(scenario2, 2);
      console.log(`  ESCENARIO 2: "${message2}"`);
      
      // Escenario 3: Tres niños
      const scenario3 = [
        { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 5, timestamp: Date.now() },
        { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 3, timestamp: Date.now() },
        { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 2, timestamp: Date.now() }
      ];
      const message3 = generateNaturalVoiceMessage(scenario3, 3);
      console.log(`  ESCENARIO 3: "${message3}"`);
      
      // 4. PROBAR REPETICIONES ADAPTATIVAS
      console.log(`\n🔄 PROBANDO REPETICIONES ADAPTATIVAS:`);
      for (let i = 1; i <= 6; i++) {
        const { repetitions, delay } = calculateAdaptiveRepetitions('', i);
        console.log(`  ${i} niño(s): ${repetitions} repeticiones, delay: ${delay}ms`);
      }
      
      // 5. PROBAR AUDIO DIRECTO
      console.log(`\n🔊 PROBANDO AUDIO DIRECTO:`);
      console.log(`  - Ejecutando testAudioUrgent()...`);
      testAudioUrgent();
      
      console.log(`\n✅ DIAGNÓSTICO COMPLETO FINALIZADO`);
      console.log(`📋 REVISAR LOGS ANTERIORES PARA IDENTIFICAR PROBLEMAS`);
    }
    
    // Hacer función global para diagnóstico
    window.diagnoseVoiceSystem = diagnoseVoiceSystem;
    
    // 🚨 CORRECCIÓN URGENTE DE TODOS LOS PROBLEMAS IDENTIFICADOS
    function fixAllVoiceProblems() {
      console.log(`🚨 APLICANDO CORRECCIONES URGENTES A TODOS LOS PROBLEMAS`);
      console.log(`=======================================================`);
      
      // PROBLEMA 1: extractChildNameFromAlert() más robusto
      function extractChildNameFromAlertFixed(text) {
        if (!text || typeof text !== 'string') {
          console.log(`⚠️ extractChildNameFromAlert: texto inválido`);
          return null;
        }
        
        // Múltiples patrones para mayor robustez
        const patterns = [
          /A (\w+) le quedan/,
          /(\w+) le quedan/,
          /A (\w+) le queda/,
          /(\w+) le queda/
        ];
        
        for (const pattern of patterns) {
          const match = text.match(pattern);
          if (match && match[1]) {
            console.log(`✅ extractChildNameFromAlert: "${match[1]}" extraído de "${text}"`);
            return match[1];
          }
        }
        
        console.log(`❌ extractChildNameFromAlert: no se pudo extraer nombre de "${text}"`);
        return null;
      }
      
      // PROBLEMA 2: detectGenderByName() con acentos
      function detectGenderByNameFixed(name) {
        if (!name || typeof name !== 'string') {
          console.log(`⚠️ detectGenderByName: nombre inválido`);
          return 'unknown';
        }
        
        const normalizedName = name.toLowerCase()
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, ''); // Remover acentos
        
        const femaleNames = [
          'sofia', 'maria', 'ana', 'lucia', 'carla', 'laura', 'isabella', 'valentina',
          'camila', 'natalia', 'andrea', 'paula', 'fernanda', 'alejandra', 'diana'
        ];
        
        const maleNames = [
          'david', 'mathias', 'cristian', 'ramon', 'santiago', 'carlos', 'juan', 'pedro',
          'miguel', 'antonio', 'jose', 'manuel', 'francisco', 'alejandro', 'daniel'
        ];
        
        if (femaleNames.includes(normalizedName)) {
          console.log(`✅ detectGenderByName: "${name}" → female`);
          return 'female';
        }
        if (maleNames.includes(normalizedName)) {
          console.log(`✅ detectGenderByName: "${name}" → male`);
          return 'male';
        }
        
        console.log(`⚠️ detectGenderByName: "${name}" → unknown`);
        return 'unknown';
      }
      
      // PROBLEMA 3: generateNaturalVoiceMessage() con validación
      function generateNaturalVoiceMessageFixed(pendingAlerts, alertCount) {
        console.log(`🎯 GENERANDO MENSAJE NATURAL PARA ${alertCount} NIÑOS`);
        
        // VALIDACIÓN CRÍTICA DE ENTRADA
        if (!pendingAlerts || !Array.isArray(pendingAlerts) || pendingAlerts.length === 0) {
          console.log(`❌ generateNaturalVoiceMessage: pendingAlerts inválido`);
          return "Hola, algunos niños han terminado su tiempo de juego. Por favor, recógelos.";
        }
        
        if (!alertCount || alertCount < 1) {
          console.log(`❌ generateNaturalVoiceMessage: alertCount inválido`);
          return "Hola, algunos niños han terminado su tiempo de juego. Por favor, recógelos.";
        }
        
        // Extraer información de los niños con validación
        const childrenInfo = pendingAlerts.map((alert, index) => {
          if (!alert || !alert.text) {
            console.log(`⚠️ generateNaturalVoiceMessage: alert ${index} inválido`);
            return null;
          }
          
          const childName = extractChildNameFromAlertFixed(alert.text);
          if (!childName) {
            console.log(`⚠️ generateNaturalVoiceMessage: no se pudo extraer nombre del alert ${index}`);
            return null;
          }
          
          const gender = detectGenderByNameFixed(childName);
          return {
            name: childName,
            gender: gender,
            relationship: gender === 'female' ? 'hija' : (gender === 'male' ? 'hijo' : 'niño')
          };
        }).filter(child => child !== null);
        
        console.log(`👶 INFORMACIÓN DE NIÑOS:`, childrenInfo);
        
        if (childrenInfo.length === 0) {
          console.log(`❌ generateNaturalVoiceMessage: no se pudieron extraer nombres válidos`);
          return "Hola, algunos niños han terminado su tiempo de juego. Por favor, recógelos.";
        }
        
        // GENERAR MENSAJE SEGÚN ESCENARIOS NATURALES
        if (alertCount === 1) {
          const child = childrenInfo[0];
          return `Hola, ${child.name} ha terminado su tiempo de juego. Por favor, recógelo.`;
          
        } else if (alertCount === 2) {
          const child1 = childrenInfo[0];
          const child2 = childrenInfo[1];
          return `Hola, ${child1.name} y ${child2.name} han terminado su tiempo de juego. Por favor, recógelos.`;
          
        } else if (alertCount <= 5) {
          const names = childrenInfo.map(child => child.name);
          const lastChild = names.pop();
          const otherChildren = names.join(', ');
          return `Hola, ${otherChildren} y ${lastChild} han terminado su tiempo de juego. Por favor, recógelos.`;
          
        } else {
          return `Hola, ${alertCount} niños han terminado su tiempo de juego. Por favor, recógelos.`;
        }
      }
      
      // PROBLEMA 4: calculateAdaptiveRepetitions() con edge cases
      function calculateAdaptiveRepetitionsFixed(message, alertCount) {
        if (!adaptiveAlertSystem || !adaptiveAlertSystem.enabled) {
          console.log(`⚠️ calculateAdaptiveRepetitions: adaptiveAlertSystem deshabilitado`);
          return { repetitions: 1, delay: 0 };
        }
        
        // VALIDACIÓN DE ENTRADA
        if (!alertCount || alertCount < 1 || alertCount > 20) {
          console.log(`⚠️ calculateAdaptiveRepetitions: alertCount inválido (${alertCount})`);
          return { repetitions: 1, delay: 0 };
        }
        
        let repetitions;
        let delay;
        
        // LÓGICA INTELIGENTE PARA EVITAR CONTAMINACIÓN DE AUDIO
        if (alertCount === 1) {
          // 1 niño: 3 repeticiones con delays largos para dar tiempo
          repetitions = 3;
          delay = 45000; // 45 segundos entre cada llamado
        } else if (alertCount === 2) {
          // 2 niños: 2 repeticiones con delay moderado
          repetitions = 2;
          delay = 60000; // 1 minuto entre llamados
        } else if (alertCount <= 5) {
          // 3-5 niños: 2 repeticiones con delay largo
          repetitions = 2;
          delay = 90000; // 1.5 minutos entre llamados
        } else {
          // 6+ niños: 1 mensaje consolidado inmediato
          // En este caso, los padres deben estar atentos por la cantidad
          repetitions = 1;
          delay = 0;
        }
        
        console.log(`🧠 ADAPTATIVO INTELIGENTE: ${alertCount} niños → ${repetitions} repeticiones, delay: ${delay}ms (${delay/1000}s)`);
        return { repetitions, delay };
      }
      
      // SISTEMA DUPLICADO ELIMINADO - USAR SOLO voiceQueue PRINCIPAL
      
      console.log(`✅ TODAS LAS CORRECCIONES APLICADAS`);
      console.log(`📋 FUNCIONES CORREGIDAS DISPONIBLES GLOBALMENTE`);
    }
    
    // Hacer función global para correcciones
    window.fixAllVoiceProblems = fixAllVoiceProblems;
    
    // 🧪 PRUEBA ESPECÍFICA: 3 SESIONES ACTIVAS TERMINANDO
    function test3ActiveSessions() {
      console.log(`🧪 INICIANDO PRUEBA: 3 SESIONES ACTIVAS TERMINANDO`);
      console.log(`=================================================`);
      
      // Primero aplicar todas las correcciones
      console.log(`🔧 APLICANDO CORRECCIONES...`);
      fixAllVoiceProblems();
      
      // Simular 3 sesiones activas terminando
      const activeSessions = [
        {
          childName: "sofia",
          parents: "Luis & Ana",
          game: "trampolin",
          timeLeft: 5,
          sessionId: 1
        },
        {
          childName: "david", 
          parents: "Carlos & Maria",
          game: "trampolin",
          timeLeft: 3,
          sessionId: 2
        },
        {
          childName: "mathias",
          parents: "Pedro & Laura", 
          game: "trampolin",
          timeLeft: 2,
          sessionId: 3
        }
      ];
      
      console.log(`\n📊 SESIONES ACTIVAS SIMULADAS:`);
      activeSessions.forEach((session, index) => {
        console.log(`  ${index + 1}. ${session.childName} (${session.parents}) - ${session.timeLeft}s restantes`);
      });
      
      // Simular alertas de tiempo terminado
      const timeOutAlerts = [
        {
          text: "¡Atención! A sofia le quedan solo 5 segundos",
          sessionId: 1,
          timeLeft: 0,
          timestamp: Date.now()
        },
        {
          text: "¡Atención! A david le quedan solo 3 segundos", 
          sessionId: 2,
          timeLeft: 0,
          timestamp: Date.now()
        },
        {
          text: "¡Atención! A mathias le quedan solo 2 segundos",
          sessionId: 3, 
          timeLeft: 0,
          timestamp: Date.now()
        }
      ];
      
      console.log(`\n🎯 SIMULANDO TERMINACIÓN DE SESIONES...`);
      console.log(`📝 Alertas generadas: ${timeOutAlerts.length}`);
      
      // Probar extracción de nombres
      console.log(`\n🧪 PROBANDO EXTRACCIÓN DE NOMBRES:`);
      timeOutAlerts.forEach((alert, index) => {
        const name = extractChildNameFromAlertFixed(alert.text);
        const gender = detectGenderByNameFixed(name);
        console.log(`  ${index + 1}. "${alert.text}" → Nombre: "${name}", Género: "${gender}"`);
      });
      
      // Probar generación de mensaje natural
      console.log(`\n🎯 PROBANDO GENERACIÓN DE MENSAJE NATURAL:`);
      const naturalMessage = generateNaturalVoiceMessageFixed(timeOutAlerts, 3);
      console.log(`📢 MENSAJE GENERADO: "${naturalMessage}"`);
      
      // Probar repeticiones adaptativas
      console.log(`\n🔄 PROBANDO REPETICIONES ADAPTATIVAS:`);
      const { repetitions, delay } = calculateAdaptiveRepetitionsFixed('', 3);
      console.log(`📊 3 niños → ${repetitions} repeticiones, delay: ${delay}ms`);
      
      // Probar cola de voz
      console.log(`\n🎵 PROBANDO COLA DE VOZ:`);
      console.log(`📝 Agregando mensaje a cola...`);
      
      // Agregar mensaje a la cola
      const success = addToVoiceQueueFixed(naturalMessage, { 
        priority: 'high',
        sessionId: 'test-3-sessions'
      });
      
      if (success) {
        console.log(`✅ MENSAJE AGREGADO A COLA EXITOSAMENTE`);
        console.log(`🔊 EL AUDIO DEBERÍA REPRODUCIRSE EN BREVE...`);
        console.log(`📋 ESCUCHA ATENTAMENTE EL MENSAJE DE VOZ`);
        console.log(`🎯 DEBERÍAS ESCUCHAR: "${naturalMessage}"`);
      } else {
        console.log(`❌ ERROR AL AGREGAR MENSAJE A COLA`);
      }
      
      // Probar escenarios individuales
      console.log(`\n🧪 PROBANDO ESCENARIOS INDIVIDUALES:`);
      
      // Escenario 1: Solo sofia
      setTimeout(() => {
        console.log(`\n📝 ESCENARIO 1: Solo sofia`);
        const sofiaAlert = [timeOutAlerts[0]];
        const sofiaMessage = generateNaturalVoiceMessageFixed(sofiaAlert, 1);
        console.log(`📢 MENSAJE SOFIA: "${sofiaMessage}"`);
        addToVoiceQueueFixed(sofiaMessage, { priority: 'high' });
      }, 2000);
      
      // Escenario 2: sofia y david
      setTimeout(() => {
        console.log(`\n📝 ESCENARIO 2: sofia y david`);
        const twoAlerts = [timeOutAlerts[0], timeOutAlerts[1]];
        const twoMessage = generateNaturalVoiceMessageFixed(twoAlerts, 2);
        console.log(`📢 MENSAJE DOS: "${twoMessage}"`);
        addToVoiceQueueFixed(twoMessage, { priority: 'high' });
      }, 4000);
      
      // Escenario 3: Los tres
      setTimeout(() => {
        console.log(`\n📝 ESCENARIO 3: Los tres (sofia, david, mathias)`);
        const threeMessage = generateNaturalVoiceMessageFixed(timeOutAlerts, 3);
        console.log(`📢 MENSAJE TRES: "${threeMessage}"`);
        addToVoiceQueueFixed(threeMessage, { priority: 'high' });
      }, 6000);
      
      console.log(`\n✅ PRUEBA INICIADA - VERIFICAR AUDIO Y LOGS`);
      console.log(`📋 INSTRUCCIONES:`);
      console.log(`  1. ESCUCHA el mensaje de voz`);
      console.log(`  2. VERIFICA que dice los 3 nombres correctamente`);
      console.log(`  3. CONFIRMA que el mensaje es natural y claro`);
      console.log(`  4. REVISA los logs en consola`);
      
      return {
        success: true,
        message: naturalMessage,
        sessions: activeSessions,
        alerts: timeOutAlerts
      };
    }
    
    // Hacer función global para prueba de 3 sesiones
    window.test3ActiveSessions = test3ActiveSessions;
    
    // 🚨 SISTEMA DE PRUEBAS ROBUSTO - ESCUCHAR AUDIO REAL
    function testVoiceSystemRobust() {
      console.log(`🚨 INICIANDO PRUEBAS ROBUSTAS DEL SISTEMA DE VOZ`);
      console.log(`================================================`);
      
      // Verificar estado del sistema
      console.log(`\n📊 ESTADO DEL SISTEMA:`);
      console.log(`  - voiceNotificationsEnabled: ${voiceNotificationsEnabled}`);
      console.log(`  - voiceSystemActivated: ${voiceSystemActivated}`);
      console.log(`  - speechSynthesis disponible: ${typeof speechSynthesis !== 'undefined'}`);
      console.log(`  - voces disponibles: ${speechSynthesis.getVoices().length}`);
      
      // PRUEBA 1: Audio básico
      console.log(`\n🧪 PRUEBA 1: AUDIO BÁSICO`);
      console.log(`📢 Reproduciendo: "Prueba de audio básico"`);
      speakChildName("Prueba de audio básico");
      
      setTimeout(() => {
        // PRUEBA 2: Un niño
        console.log(`\n🧪 PRUEBA 2: UN NIÑO`);
        const scenario1 = [{
          text: "¡Atención! A sofia le quedan solo 5 segundos",
          sessionId: 1,
          timeLeft: 0,
          timestamp: Date.now()
        }];
        console.log(`📢 Escenario: 1 niño (sofia)`);
        speakAlertWithRepetitionFixed(scenario1, 1);
      }, 3000);
      
      setTimeout(() => {
        // PRUEBA 3: Dos niños
        console.log(`\n🧪 PRUEBA 3: DOS NIÑOS`);
        const scenario2 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: 2 niños (sofia, david)`);
        speakAlertWithRepetitionFixed(scenario2, 2);
      }, 6000);
      
      setTimeout(() => {
        // PRUEBA 4: Tres niños
        console.log(`\n🧪 PRUEBA 4: TRES NIÑOS`);
        const scenario3 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: 3 niños (sofia, david, mathias)`);
        speakAlertWithRepetitionFixed(scenario3, 3);
      }, 9000);
      
      setTimeout(() => {
        // PRUEBA 5: Cinco niños
        console.log(`\n🧪 PRUEBA 5: CINCO NIÑOS`);
        const scenario4 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A cristian le quedan solo 1 segundo", sessionId: 4, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A ramon le quedan solo 1 segundo", sessionId: 5, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: 5 niños (sofia, david, mathias, cristian, ramon)`);
        speakAlertWithRepetitionFixed(scenario4, 5);
      }, 12000);
      
      setTimeout(() => {
        // PRUEBA 6: Seis niños
        console.log(`\n🧪 PRUEBA 6: SEIS NIÑOS`);
        const scenario5 = [
          { text: "¡Atención! A sofia le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A david le quedan solo 3 segundos", sessionId: 2, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A mathias le quedan solo 2 segundos", sessionId: 3, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A cristian le quedan solo 1 segundo", sessionId: 4, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A ramon le quedan solo 1 segundo", sessionId: 5, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A santiago le quedan solo 1 segundo", sessionId: 6, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: 6 niños (sofia, david, mathias, cristian, ramon, santiago)`);
        speakAlertWithRepetitionFixed(scenario5, 6);
      }, 15000);
      
      setTimeout(() => {
        // PRUEBA 7: Nombres con acentos
        console.log(`\n🧪 PRUEBA 7: NOMBRES CON ACENTOS`);
        const scenario6 = [
          { text: "¡Atención! A josé le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A maría le quedan solo 3 segundos", sessionId: 2, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: Nombres con acentos (josé, maría)`);
        speakAlertWithRepetitionFixed(scenario6, 2);
      }, 18000);
      
      setTimeout(() => {
        // PRUEBA 8: Nombres complejos
        console.log(`\n🧪 PRUEBA 8: NOMBRES COMPLEJOS`);
        const scenario7 = [
          { text: "¡Atención! A alejandro le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() },
          { text: "¡Atención! A valentina le quedan solo 3 segundos", sessionId: 2, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: Nombres complejos (alejandro, valentina)`);
        speakAlertWithRepetitionFixed(scenario7, 2);
      }, 21000);
      
      setTimeout(() => {
        // PRUEBA 9: Casos edge
        console.log(`\n🧪 PRUEBA 9: CASOS EDGE`);
        const scenario8 = [
          { text: "¡Atención! A niño le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: Casos edge (niño genérico)`);
        speakAlertWithRepetitionFixed(scenario8, 1);
      }, 24000);
      
      setTimeout(() => {
        // PRUEBA 10: Datos inválidos
        console.log(`\n🧪 PRUEBA 10: DATOS INVÁLIDOS`);
        const scenario9 = [
          { text: "¡Atención! A  le quedan solo 5 segundos", sessionId: 1, timeLeft: 0, timestamp: Date.now() }
        ];
        console.log(`📢 Escenario: Datos inválidos (nombre vacío)`);
        speakAlertWithRepetitionFixed(scenario9, 1);
      }, 27000);
      
      console.log(`\n✅ PRUEBAS INICIADAS - ESCUCHAR AUDIO EN SECUENCIA`);
      console.log(`📋 INSTRUCCIONES:`);
      console.log(`  1. ESCUCHA cada mensaje de voz`);
      console.log(`  2. VERIFICA que los nombres se pronuncian correctamente`);
      console.log(`  3. CONFIRMA que los mensajes son naturales`);
      console.log(`  4. IDENTIFICA cualquier problema`);
      console.log(`  5. REVISA los logs en consola`);
      
      return {
        success: true,
        message: "Pruebas robustas iniciadas",
        tests: 10,
        duration: "30 segundos"
      };
    }
    
    // Hacer función global para pruebas robustas
    window.testVoiceSystemRobust = testVoiceSystemRobust;
    
    // PRUEBAS EXHAUSTIVAS DEL SISTEMA DE VOZ - POST FIX
    function testVoiceSystemExhaustive() {
      console.log('🧪 INICIANDO PRUEBAS EXHAUSTIVAS DEL SISTEMA DE VOZ');
      console.log('='.repeat(60));
      
      // Verificar estado inicial
      console.log('📊 ESTADO INICIAL:');
      console.log('- voiceNotificationsEnabled:', voiceNotificationsEnabled);
      console.log('- voiceQueueProcessing:', voiceQueueProcessing);
      console.log('- isVoicePlaying:', isVoicePlaying);
      console.log('- voiceQueue.length:', voiceQueue.length);
      
      // Prueba 1: Mensaje simple
      console.log('\n🔬 PRUEBA 1: Mensaje simple');
      addToVoiceQueue('Prueba 1: Mensaje simple de prueba');
      
      // Prueba 2: Múltiples mensajes rápidos (simular niños terminando seguidos)
      console.log('\n🔬 PRUEBA 2: Múltiples mensajes rápidos');
      setTimeout(() => {
        addToVoiceQueue('Prueba 2A: Juan ha terminado su tiempo de juego. Papá: Carlos, por favor recoge a tu hijo');
      }, 100);
      
      setTimeout(() => {
        addToVoiceQueue('Prueba 2B: María ha terminado su tiempo de juego. Papá: Luis, Mamá: Ana, por favor recoge a tu hija');
      }, 200);
      
      setTimeout(() => {
        addToVoiceQueue('Prueba 2C: Pedro ha terminado su tiempo de juego. Papá: Roberto, por favor recoge a tu hijo');
      }, 300);
      
      // Prueba 3: Mensaje largo (simular consolidado)
      console.log('\n🔬 PRUEBA 3: Mensaje largo consolidado');
      setTimeout(() => {
        addToVoiceQueue('Prueba 3: Hola, Juan (Papá: Carlos), María (Papá: Luis, Mamá: Ana) y Pedro (Papá: Roberto) han terminado su tiempo de juego. Por favor, recógelos');
      }, 2000);
      
      // Prueba 4: Mensajes con acentos
      console.log('\n🔬 PRUEBA 4: Mensajes con acentos');
      setTimeout(() => {
        addToVoiceQueue('Prueba 4: José ha terminado su tiempo de juego. Papá: José, por favor recoge a tu hijo');
      }, 4000);
      
      setTimeout(() => {
        addToVoiceQueue('Prueba 4B: María José ha terminado su tiempo de juego. Papá: José, Mamá: María, por favor recoge a tu hija');
      }, 5000);
      
      // Prueba 5: Simular error de interrupción
      console.log('\n🔬 PRUEBA 5: Simular condiciones de error');
      setTimeout(() => {
        console.log('⚠️ Simulando condiciones que antes causaban interrupciones...');
        addToVoiceQueue('Prueba 5: Este mensaje debería reproducirse sin interrupciones');
      }, 6000);
      
      // Monitoreo continuo
      let monitorCount = 0;
      const monitor = setInterval(() => {
        monitorCount++;
        console.log(`📊 MONITOR ${monitorCount}: Cola=${voiceQueue.length}, Procesando=${voiceQueueProcessing}, Reproduciendo=${isVoicePlaying}`);
        
        if (monitorCount >= 20) {
          clearInterval(monitor);
          console.log('\n✅ PRUEBAS COMPLETADAS');
          console.log('📊 ESTADO FINAL:');
          console.log('- voiceQueue.length:', voiceQueue.length);
          console.log('- voiceQueueProcessing:', voiceQueueProcessing);
          console.log('- isVoicePlaying:', isVoicePlaying);
          console.log('='.repeat(60));
        }
      }, 1000);
      
      return 'Pruebas exhaustivas iniciadas - revisar consola para resultados';
    }
    
    // Hacer función global
    window.testVoiceSystemExhaustive = testVoiceSystemExhaustive;
    
    // PRUEBA ESPECÍFICA: Verificar que NO hay cancelaciones
    function testNoCancellations() {
      console.log('🔍 PRUEBA ESPECÍFICA: Verificar que NO hay cancelaciones');
      console.log('='.repeat(50));
      
      // Interceptar speechSynthesis.cancel para detectar llamadas
      const originalCancel = window.speechSynthesis.cancel;
      let cancelCallCount = 0;
      const cancelCalls = [];
      
      window.speechSynthesis.cancel = function() {
        cancelCallCount++;
        const stack = new Error().stack;
        cancelCalls.push({
          count: cancelCallCount,
          timestamp: Date.now(),
          stack: stack
        });
        console.log(`🚨 DETECTADA CANCELACIÓN #${cancelCallCount}:`, stack);
        return originalCancel.call(this);
      };
      
      // Ejecutar pruebas
      console.log('🧪 Ejecutando pruebas de voz...');
      addToVoiceQueue('Prueba de cancelación 1: Este mensaje no debería ser cancelado');
      
      setTimeout(() => {
        addToVoiceQueue('Prueba de cancelación 2: Segundo mensaje sin cancelación');
      }, 1000);
      
      setTimeout(() => {
        addToVoiceQueue('Prueba de cancelación 3: Tercer mensaje para verificar cola');
      }, 2000);
      
      // Restaurar función original después de 10 segundos
      setTimeout(() => {
        window.speechSynthesis.cancel = originalCancel;
        console.log('\n📊 RESULTADOS DE LA PRUEBA:');
        console.log(`- Total de cancelaciones detectadas: ${cancelCallCount}`);
        console.log('- Detalles de cancelaciones:', cancelCalls);
        
        if (cancelCallCount === 0) {
          console.log('✅ ÉXITO: No se detectaron cancelaciones innecesarias');
        } else {
          console.log('❌ PROBLEMA: Se detectaron cancelaciones que no deberían existir');
        }
        console.log('='.repeat(50));
      }, 10000);
      
      return 'Prueba de cancelaciones iniciada - revisar consola en 10 segundos';
    }
    
    // Hacer función global
    window.testNoCancellations = testNoCancellations;
    
    // PRUEBA REAL: Simular escenario de niños terminando
    function testRealScenario() {
      console.log('🎯 PRUEBA REAL: Simular escenario de niños terminando');
      console.log('='.repeat(60));
      
      // Simular datos reales
      const testChildren = [
        { name: 'Sofia', fatherName: 'Fernando', motherName: null },
        { name: 'Juan', fatherName: 'Carlos', motherName: 'María' },
        { name: 'María', fatherName: 'Luis', motherName: 'Ana' },
        { name: 'Pedro', fatherName: 'Roberto', motherName: null },
        { name: 'José', fatherName: 'José', motherName: 'Carmen' }
      ];
      
      console.log('👶 Simulando 5 niños terminando en secuencia...');
      
      // Niño 1 termina
      setTimeout(() => {
        console.log('🔔 Niño 1 (Sofia) termina');
        const message = `Hola, Sofia ha terminado su tiempo de juego. Papá: Fernando, por favor recoge a tu hija`;
        addToVoiceQueue(message);
      }, 1000);
      
      // Niño 2 termina (mientras 1 se reproduce)
      setTimeout(() => {
        console.log('🔔 Niño 2 (Juan) termina');
        const message = `Hola, Juan ha terminado su tiempo de juego. Papá: Carlos, Mamá: María, por favor recoge a tu hijo`;
        addToVoiceQueue(message);
      }, 2000);
      
      // Niño 3 termina (mientras 1 y 2 están en cola)
      setTimeout(() => {
        console.log('🔔 Niño 3 (María) termina');
        const message = `Hola, María ha terminado su tiempo de juego. Papá: Luis, Mamá: Ana, por favor recoge a tu hija`;
        addToVoiceQueue(message);
      }, 3000);
      
      // Niño 4 termina
      setTimeout(() => {
        console.log('🔔 Niño 4 (Pedro) termina');
        const message = `Hola, Pedro ha terminado su tiempo de juego. Papá: Roberto, por favor recoge a tu hijo`;
        addToVoiceQueue(message);
      }, 4000);
      
      // Niño 5 termina
      setTimeout(() => {
        console.log('🔔 Niño 5 (José) termina');
        const message = `Hola, José ha terminado su tiempo de juego. Papá: José, Mamá: Carmen, por favor recoge a tu hijo`;
        addToVoiceQueue(message);
      }, 5000);
      
      // Monitoreo detallado
      let monitorCount = 0;
      const monitor = setInterval(() => {
        monitorCount++;
        console.log(`📊 MONITOR ${monitorCount}: Cola=${voiceQueue.length}, Procesando=${voiceQueueProcessing}, Reproduciendo=${isVoicePlaying}`);
        
        if (monitorCount >= 15) {
          clearInterval(monitor);
          console.log('\n✅ PRUEBA REAL COMPLETADA');
          console.log('📊 ESTADO FINAL:');
          console.log('- voiceQueue.length:', voiceQueue.length);
          console.log('- voiceQueueProcessing:', voiceQueueProcessing);
          console.log('- isVoicePlaying:', isVoicePlaying);
          console.log('='.repeat(60));
        }
      }, 1000);
      
      return 'Prueba real iniciada - revisar consola para monitoreo';
    }
    
    // Hacer función global
    window.testRealScenario = testRealScenario;
    
    // PRUEBA URGENTE: Detectar EXACTAMENTE dónde se cancela
    function testDetectCancellations() {
      console.log('🚨 PRUEBA URGENTE: Detectar EXACTAMENTE dónde se cancela');
      console.log('='.repeat(60));
      
      // Interceptar TODAS las llamadas a speechSynthesis.cancel
      const originalCancel = window.speechSynthesis.cancel;
      let cancelCount = 0;
      const cancelDetails = [];
      
      window.speechSynthesis.cancel = function() {
        cancelCount++;
        const stack = new Error().stack;
        const timestamp = new Date().toISOString();
        
        cancelDetails.push({
          count: cancelCount,
          timestamp: timestamp,
          stack: stack
        });
        
        console.log(`🚨 CANCELACIÓN #${cancelCount} DETECTADA:`, {
          timestamp: timestamp,
          stack: stack.split('\n').slice(0, 5).join('\n')
        });
        
        // Llamar a la función original
        return originalCancel.call(this);
      };
      
      // Ejecutar prueba de voz
      console.log('🧪 Ejecutando prueba de voz...');
      addToVoiceQueue('Prueba de detección de cancelaciones: Este mensaje no debería ser cancelado');
      
      setTimeout(() => {
        addToVoiceQueue('Segundo mensaje: Verificando que no hay cancelaciones');
      }, 2000);
      
      setTimeout(() => {
        addToVoiceQueue('Tercer mensaje: Sistema debe ser estable');
      }, 4000);
      
      // Reportar resultados después de 15 segundos
      setTimeout(() => {
        window.speechSynthesis.cancel = originalCancel;
        
        console.log('\n📊 REPORTE FINAL DE CANCELACIONES:');
        console.log(`- Total de cancelaciones detectadas: ${cancelCount}`);
        console.log('- Detalles completos:', cancelDetails);
        
        if (cancelCount === 0) {
          console.log('✅ ÉXITO: No se detectaron cancelaciones innecesarias');
        } else {
          console.log('❌ PROBLEMA: Se detectaron cancelaciones que causan interrupciones');
          console.log('🔍 ANALIZAR STACK TRACE para identificar la fuente');
        }
        
        console.log('='.repeat(60));
      }, 15000);
      
      return 'Prueba de detección iniciada - revisar consola en 15 segundos';
    }
    
    // Hacer función global
    window.testDetectCancellations = testDetectCancellations;
    
    // PRUEBA EXHAUSTIVA: Verificar TODOS los posibles causales del error
    function testAllPossibleCauses() {
      console.log('🔍 PRUEBA EXHAUSTIVA: Verificar TODOS los posibles causales del error');
      console.log('='.repeat(80));
      
      const results = {
        speechSynthesis: {},
        voices: {},
        browser: {},
        timing: {},
        conflicts: {},
        errors: []
      };
      
      // 1. VERIFICAR SPEECH SYNTHESIS BÁSICO
      console.log('\n📊 CAUSAL 1: Speech Synthesis Básico');
      try {
        results.speechSynthesis.available = 'speechSynthesis' in window;
        results.speechSynthesis.speak = typeof window.speechSynthesis.speak === 'function';
        results.speechSynthesis.cancel = typeof window.speechSynthesis.cancel === 'function';
        results.speechSynthesis.getVoices = typeof window.speechSynthesis.getVoices === 'function';
        console.log('✅ Speech Synthesis básico:', results.speechSynthesis);
      } catch (error) {
        results.errors.push({ causal: 'speechSynthesis_basic', error: error.message });
        console.log('❌ Error en Speech Synthesis básico:', error);
      }
      
      // 2. VERIFICAR VOCES
      console.log('\n📊 CAUSAL 2: Voces Disponibles');
      try {
        const voices = window.speechSynthesis.getVoices();
        results.voices.total = voices.length;
        results.voices.spanish = voices.filter(v => v.lang.startsWith('es')).length;
        results.voices.english = voices.filter(v => v.lang.startsWith('en')).length;
        results.voices.default = voices.filter(v => v.default).length;
        console.log('✅ Voces:', results.voices);
      } catch (error) {
        results.errors.push({ causal: 'voices', error: error.message });
        console.log('❌ Error en voces:', error);
      }
      
      // 3. VERIFICAR NAVEGADOR
      console.log('\n📊 CAUSAL 3: Navegador y Permisos');
      try {
        results.browser.userAgent = navigator.userAgent;
        results.browser.language = navigator.language;
        results.browser.online = navigator.onLine;
        results.browser.cookieEnabled = navigator.cookieEnabled;
        results.browser.mediaDevices = 'mediaDevices' in navigator;
        results.browser.permissions = 'permissions' in navigator;
        console.log('✅ Navegador:', results.browser);
      } catch (error) {
        results.errors.push({ causal: 'browser', error: error.message });
        console.log('❌ Error en navegador:', error);
      }
      
      // 4. VERIFICAR TIMING Y CONCURRENCIA
      console.log('\n📊 CAUSAL 4: Timing y Concurrencia');
      try {
        results.timing.voiceQueueLength = voiceQueue.length;
        results.timing.isVoicePlaying = isVoicePlaying;
        results.timing.voiceQueueProcessing = voiceQueueProcessing;
        results.timing.voiceNotificationsEnabled = voiceNotificationsEnabled;
        results.timing.voiceSystemActivated = voiceSystemActivated;
        console.log('✅ Timing:', results.timing);
      } catch (error) {
        results.errors.push({ causal: 'timing', error: error.message });
        console.log('❌ Error en timing:', error);
      }
      
      // 5. VERIFICAR CONFLICTOS DE AUDIO
      console.log('\n📊 CAUSAL 5: Conflictos de Audio');
      try {
        results.conflicts.audioContext = typeof AudioContext !== 'undefined';
        results.conflicts.webAudio = typeof window.AudioContext !== 'undefined';
        results.conflicts.mediaDevices = 'mediaDevices' in navigator;
        results.conflicts.autoplay = document.querySelector('audio, video') !== null;
        console.log('✅ Conflictos:', results.conflicts);
      } catch (error) {
        results.errors.push({ causal: 'conflicts', error: error.message });
        console.log('❌ Error en conflictos:', error);
      }
      
      // 6. PRUEBA DE AUDIO REAL
      console.log('\n📊 CAUSAL 6: Prueba de Audio Real');
      try {
        const testMessage = 'Prueba de audio exhaustiva';
        const utterance = new SpeechSynthesisUtterance(testMessage);
        
        utterance.onstart = () => {
          console.log('✅ Audio iniciado correctamente');
        };
        
        utterance.onend = () => {
          console.log('✅ Audio terminado correctamente');
        };
        
        utterance.onerror = (error) => {
          console.log('❌ Error en audio:', error);
          results.errors.push({ causal: 'audio_test', error: error.error, message: testMessage });
        };
        
        addToGlobalVoiceQueue(utterance.text || 'Test message', {
  volume: utterance.volume,
  rate: utterance.rate,
  pitch: utterance.pitch,
  lang: utterance.lang
});
        
        // Esperar 3 segundos para ver si hay errores
        setTimeout(() => {
          console.log('✅ Prueba de audio completada');
        }, 3000);
        
      } catch (error) {
        results.errors.push({ causal: 'audio_test', error: error.message });
        console.log('❌ Error en prueba de audio:', error);
      }
      
      // 7. VERIFICAR MÚLTIPLES LLAMADAS SIMULTÁNEAS
      console.log('\n📊 CAUSAL 7: Múltiples Llamadas Simultáneas');
      try {
        const messages = [
          'Primer mensaje de prueba',
          'Segundo mensaje de prueba',
          'Tercer mensaje de prueba'
        ];
        
        messages.forEach((message, index) => {
          setTimeout(() => {
            const utterance = new SpeechSynthesisUtterance(message);
            utterance.onerror = (error) => {
              console.log(`❌ Error en mensaje ${index + 1}:`, error);
              results.errors.push({ causal: 'multiple_calls', error: error.error, message: message });
            };
            addToGlobalVoiceQueue(utterance.text || 'Test message', {
  volume: utterance.volume,
  rate: utterance.rate,
  pitch: utterance.pitch,
  lang: utterance.lang
});
          }, index * 1000);
        });
        
      } catch (error) {
        results.errors.push({ causal: 'multiple_calls', error: error.message });
        console.log('❌ Error en múltiples llamadas:', error);
      }
      
      // 8. REPORTE FINAL
      setTimeout(() => {
        console.log('\n📊 REPORTE FINAL EXHAUSTIVO:');
        console.log('='.repeat(80));
        console.log('📋 TODOS LOS RESULTADOS:');
        console.log(JSON.stringify(results, null, 2));
        
        if (results.errors.length === 0) {
          console.log('✅ ÉXITO: No se detectaron errores en ningún causal');
        } else {
          console.log('❌ PROBLEMAS DETECTADOS:');
          results.errors.forEach((error, index) => {
            console.log(`${index + 1}. Causal: ${error.causal}, Error: ${error.error}`);
          });
        }
        
        console.log('='.repeat(80));
      }, 10000);
      
      return 'Prueba exhaustiva iniciada - revisar consola en 10 segundos';
    }
    
    // Hacer función global
    window.testAllPossibleCauses = testAllPossibleCauses;
    
    // PRUEBA DE ESCENARIO REAL: Simular uso real para detectar interrupciones
    function testRealWorldScenario() {
      console.log('🌍 PRUEBA DE ESCENARIO REAL: Simular uso real para detectar interrupciones');
      console.log('='.repeat(80));
      
      let interruptionCount = 0;
      let successCount = 0;
      const interruptionDetails = [];
      
      // Función para crear utterance con monitoreo completo
      function createMonitoredUtterance(message, id) {
        const utterance = new SpeechSynthesisUtterance(message);
        
        utterance.onstart = () => {
          console.log(`🎤 Audio iniciado: "${message}" (ID: ${id})`);
        };
        
        utterance.onend = () => {
          console.log(`✅ Audio terminado: "${message}" (ID: ${id})`);
          successCount++;
        };
        
        utterance.onerror = (error) => {
          interruptionCount++;
          const detail = {
            id: id,
            message: message,
            error: error.error,
            timestamp: new Date().toISOString(),
            stack: new Error().stack
          };
          interruptionDetails.push(detail);
          
          console.log(`❌ INTERRUPCIÓN DETECTADA #${interruptionCount}:`, detail);
          
          // Si es 'interrupted', intentar reanudar
          if (error.error === 'interrupted') {
            console.log(`🔄 Reintentando mensaje interrumpido: "${message}"`);
            setTimeout(() => {
              const retryUtterance = createMonitoredUtterance(message, `${id}-retry`);
              addToGlobalVoiceQueue(retryUtterance.text || message, {
                volume: retryUtterance.volume,
                rate: retryUtterance.rate,
                pitch: retryUtterance.pitch,
                lang: retryUtterance.lang
              });
            }, 1000);
          }
        };
        
        utterance.onpause = () => {
          console.log(`⏸️ Audio pausado: "${message}" (ID: ${id})`);
        };
        
        utterance.onresume = () => {
          console.log(`▶️ Audio reanudado: "${message}" (ID: ${id})`);
        };
        
        return utterance;
      }
      
      // Simular escenario real: múltiples mensajes con diferentes timings
      const messages = [
        'Primer mensaje: Prueba de estabilidad del sistema',
        'Segundo mensaje: Verificación de cola de voz',
        'Tercer mensaje: Simulación de alerta de tiempo',
        'Cuarto mensaje: Prueba de mensaje largo para verificar estabilidad',
        'Quinto mensaje: Verificación final del sistema'
      ];
      
      console.log('🚀 Iniciando simulación de escenario real...');
      
      // Enviar mensajes con diferentes timings para simular uso real
      messages.forEach((message, index) => {
        setTimeout(() => {
          console.log(`📤 Enviando mensaje ${index + 1}/${messages.length}: "${message}"`);
          const utterance = createMonitoredUtterance(message, `msg-${index + 1}`);
          addToGlobalVoiceQueue(utterance.text || 'Test message', {
  volume: utterance.volume,
  rate: utterance.rate,
  pitch: utterance.pitch,
  lang: utterance.lang
});
        }, index * 2000); // 2 segundos entre mensajes
      });
      
      // Simular interacciones del usuario que podrían causar interrupciones
      setTimeout(() => {
        console.log('🖱️ Simulando interacción del usuario (scroll)...');
        window.scrollTo(0, 100);
        setTimeout(() => window.scrollTo(0, 0), 500);
      }, 3000);
      
      setTimeout(() => {
        console.log('🔄 Simulando cambio de foco de ventana...');
        window.blur();
        setTimeout(() => window.focus(), 1000);
      }, 6000);
      
      // Reporte final después de 20 segundos
      setTimeout(() => {
        console.log('\n📊 REPORTE FINAL DE ESCENARIO REAL:');
        console.log('='.repeat(80));
        console.log(`✅ Mensajes exitosos: ${successCount}`);
        console.log(`❌ Interrupciones detectadas: ${interruptionCount}`);
        console.log(`📊 Tasa de éxito: ${((successCount / (successCount + interruptionCount)) * 100).toFixed(1)}%`);
        
        if (interruptionDetails.length > 0) {
          console.log('\n🔍 DETALLES DE INTERRUPCIONES:');
          interruptionDetails.forEach((detail, index) => {
            console.log(`${index + 1}. ID: ${detail.id}, Error: ${detail.error}, Mensaje: "${detail.message}"`);
          });
        }
        
        if (interruptionCount === 0) {
          console.log('✅ ÉXITO: Sistema estable en escenario real');
        } else {
          console.log('❌ PROBLEMA: Se detectaron interrupciones en escenario real');
          console.log('🔍 Analizar detalles para identificar patrón de interrupciones');
        }
        
        console.log('='.repeat(80));
      }, 20000);
      
      return 'Prueba de escenario real iniciada - revisar consola en 20 segundos';
    }
    
    // Hacer función global
    window.testRealWorldScenario = testRealWorldScenario;
    
    // PRUEBA DE PRODUCCIÓN: Simular escenario exacto donde ocurren interrupciones
    function testProductionScenario() {
      console.log('🏭 PRUEBA DE PRODUCCIÓN: Simular escenario exacto donde ocurren interrupciones');
      console.log('='.repeat(80));
      
      let interruptionCount = 0;
      let successCount = 0;
      const interruptionDetails = [];
      
      // Función para crear utterance con monitoreo completo de producción
      function createProductionUtterance(message, id) {
        const utterance = new SpeechSynthesisUtterance(message);
        
        utterance.onstart = () => {
          console.log(`🎤 PRODUCCIÓN - Audio iniciado: "${message}" (ID: ${id})`);
        };
        
        utterance.onend = () => {
          console.log(`✅ PRODUCCIÓN - Audio terminado: "${message}" (ID: ${id})`);
          successCount++;
        };
        
        utterance.onerror = (error) => {
          interruptionCount++;
          const detail = {
            id: id,
            message: message,
            error: error.error,
            timestamp: new Date().toISOString(),
            stack: new Error().stack,
            userAgent: navigator.userAgent,
            language: navigator.language,
            online: navigator.onLine
          };
          interruptionDetails.push(detail);
          
          console.log(`❌ PRODUCCIÓN - INTERRUPCIÓN DETECTADA #${interruptionCount}:`, detail);
          
          // Si es 'interrupted', intentar reanudar con delay
          if (error.error === 'interrupted') {
            console.log(`🔄 PRODUCCIÓN - Reintentando mensaje interrumpido: "${message}"`);
            setTimeout(() => {
              const retryUtterance = createProductionUtterance(message, `${id}-retry`);
              addToGlobalVoiceQueue(retryUtterance.text || message, {
                volume: retryUtterance.volume,
                rate: retryUtterance.rate,
                pitch: retryUtterance.pitch,
                lang: retryUtterance.lang
              });
            }, 2000); // Delay más largo para producción
          }
        };
        
        utterance.onpause = () => {
          console.log(`⏸️ PRODUCCIÓN - Audio pausado: "${message}" (ID: ${id})`);
        };
        
        utterance.onresume = () => {
          console.log(`▶️ PRODUCCIÓN - Audio reanudado: "${message}" (ID: ${id})`);
        };
        
        return utterance;
      }
      
      // Simular escenario de producción: alertas de tiempo real
      const productionMessages = [
        '¡Atención! A sofia le quedan solo 30 segundos',
        '¡Atención! A mathias le quedan solo 30 segundos',
        '¡Atención! A cristian le quedan solo 30 segundos',
        '¡Atención! sofia, mathias y cristian han terminado su tiempo de juego',
        '¡Atención! Por favor, padres, recojan a sus hijos inmediatamente'
      ];
      
      console.log('🚀 Iniciando simulación de escenario de producción...');
      
      // Enviar mensajes con timing de producción (más rápido)
      productionMessages.forEach((message, index) => {
        setTimeout(() => {
          console.log(`📤 PRODUCCIÓN - Enviando mensaje ${index + 1}/${productionMessages.length}: "${message}"`);
          const utterance = createProductionUtterance(message, `prod-${index + 1}`);
          addToGlobalVoiceQueue(utterance.text || 'Test message', {
  volume: utterance.volume,
  rate: utterance.rate,
  pitch: utterance.pitch,
  lang: utterance.lang
});
        }, index * 1000); // 1 segundo entre mensajes (más rápido)
      });
      
      // Simular interacciones reales de producción
      setTimeout(() => {
        console.log('🖱️ PRODUCCIÓN - Simulando interacción del usuario (scroll)...');
        window.scrollTo(0, 200);
        setTimeout(() => window.scrollTo(0, 0), 300);
      }, 2000);
      
      setTimeout(() => {
        console.log('🔄 PRODUCCIÓN - Simulando cambio de foco de ventana...');
        window.blur();
        setTimeout(() => window.focus(), 500);
      }, 4000);
      
      setTimeout(() => {
        console.log('📱 PRODUCCIÓN - Simulando notificación del sistema...');
        // Simular notificación que podría interrumpir audio
        if ('Notification' in window) {
          Notification.requestPermission().then(permission => {
            if (permission === 'granted') {
              new Notification('Notificación del sistema', {
                body: 'Esta notificación podría interrumpir el audio',
                icon: '/favicon.ico'
              });
            }
          });
        }
      }, 6000);
      
      // Reporte final después de 15 segundos
      setTimeout(() => {
        console.log('\n📊 REPORTE FINAL DE PRODUCCIÓN:');
        console.log('='.repeat(80));
        console.log(`✅ Mensajes exitosos: ${successCount}`);
        console.log(`❌ Interrupciones detectadas: ${interruptionCount}`);
        console.log(`📊 Tasa de éxito: ${((successCount / (successCount + interruptionCount)) * 100).toFixed(1)}%`);
        
        if (interruptionDetails.length > 0) {
          console.log('\n🔍 DETALLES DE INTERRUPCIONES EN PRODUCCIÓN:');
          interruptionDetails.forEach((detail, index) => {
            console.log(`${index + 1}. ID: ${detail.id}, Error: ${detail.error}, Mensaje: "${detail.message}"`);
            console.log(`   Timestamp: ${detail.timestamp}`);
            console.log(`   User Agent: ${detail.userAgent}`);
            console.log(`   Language: ${detail.language}`);
            console.log(`   Online: ${detail.online}`);
          });
        }
        
        if (interruptionCount === 0) {
          console.log('✅ ÉXITO: Sistema estable en escenario de producción');
        } else {
          console.log('❌ PROBLEMA: Se detectaron interrupciones en escenario de producción');
          console.log('🔍 Analizar detalles para identificar patrón de interrupciones en producción');
        }
        
        console.log('='.repeat(80));
      }, 15000);
      
      return 'Prueba de producción iniciada - revisar consola en 15 segundos';
    }
    
    // Hacer función global
    window.testProductionScenario = testProductionScenario;
    
    // PRUEBA DE ESTRÉS EXTREMO: Simular condiciones extremas que causan interrupciones
    function testExtremeStressScenario() {
      console.log('💥 PRUEBA DE ESTRÉS EXTREMO: Simular condiciones extremas que causan interrupciones');
      console.log('='.repeat(80));
      
      let interruptionCount = 0;
      let successCount = 0;
      const interruptionDetails = [];
      
      // Función para crear utterance con monitoreo extremo
      function createExtremeUtterance(message, id) {
        const utterance = new SpeechSynthesisUtterance(message);
        
        utterance.onstart = () => {
          console.log(`🎤 ESTRÉS - Audio iniciado: "${message}" (ID: ${id})`);
        };
        
        utterance.onend = () => {
          console.log(`✅ ESTRÉS - Audio terminado: "${message}" (ID: ${id})`);
          successCount++;
        };
        
        utterance.onerror = (error) => {
          interruptionCount++;
          const detail = {
            id: id,
            message: message,
            error: error.error,
            timestamp: new Date().toISOString(),
            stack: new Error().stack,
            userAgent: navigator.userAgent,
            language: navigator.language,
            online: navigator.onLine,
            memory: performance.memory ? performance.memory.usedJSHeapSize : 'N/A'
          };
          interruptionDetails.push(detail);
          
          console.log(`❌ ESTRÉS - INTERRUPCIÓN DETECTADA #${interruptionCount}:`, detail);
          
          // Si es 'interrupted', intentar reanudar con delay extremo
          if (error.error === 'interrupted') {
            console.log(`🔄 ESTRÉS - Reintentando mensaje interrumpido: "${message}"`);
            setTimeout(() => {
              const retryUtterance = createExtremeUtterance(message, `${id}-retry`);
              addToGlobalVoiceQueue(retryUtterance.text || message, {
                volume: retryUtterance.volume,
                rate: retryUtterance.rate,
                pitch: retryUtterance.pitch,
                lang: retryUtterance.lang
              });
            }, 3000); // Delay extremo para estrés
          }
        };
        
        utterance.onpause = () => {
          console.log(`⏸️ ESTRÉS - Audio pausado: "${message}" (ID: ${id})`);
        };
        
        utterance.onresume = () => {
          console.log(`▶️ ESTRÉS - Audio reanudado: "${message}" (ID: ${id})`);
        };
        
        return utterance;
      }
      
      // Simular condiciones extremas de estrés
      const stressMessages = [
        '¡Atención! A sofia le quedan solo 30 segundos',
        '¡Atención! A mathias le quedan solo 30 segundos',
        '¡Atención! A cristian le quedan solo 30 segundos',
        '¡Atención! A david le quedan solo 30 segundos',
        '¡Atención! A martin le quedan solo 30 segundos',
        '¡Atención! A ramon le quedan solo 30 segundos',
        '¡Atención! A santiago le quedan solo 30 segundos',
        '¡Atención! sofia, mathias, cristian, david, martin, ramon y santiago han terminado su tiempo de juego',
        '¡Atención! Por favor, padres, recojan a sus hijos inmediatamente',
        '¡Atención! Sistema de alertas activado para múltiples niños'
      ];
      
      console.log('🚀 Iniciando simulación de condiciones extremas de estrés...');
      
      // Enviar mensajes con timing extremo (muy rápido)
      stressMessages.forEach((message, index) => {
        setTimeout(() => {
          console.log(`📤 ESTRÉS - Enviando mensaje ${index + 1}/${stressMessages.length}: "${message}"`);
          const utterance = createExtremeUtterance(message, `stress-${index + 1}`);
          addToGlobalVoiceQueue(utterance.text || 'Test message', {
  volume: utterance.volume,
  rate: utterance.rate,
  pitch: utterance.pitch,
  lang: utterance.lang
});
        }, index * 500); // 0.5 segundos entre mensajes (extremadamente rápido)
      });
      
      // Simular condiciones extremas de estrés
      setTimeout(() => {
        console.log('🖱️ ESTRÉS - Simulando interacción extrema del usuario...');
        // Scroll extremo
        for (let i = 0; i < 10; i++) {
          setTimeout(() => {
            window.scrollTo(0, Math.random() * 1000);
          }, i * 100);
        }
      }, 1000);
      
      setTimeout(() => {
        console.log('🔄 ESTRÉS - Simulando cambio de foco extremo...');
        // Cambio de foco extremo
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            window.blur();
            setTimeout(() => window.focus(), 100);
          }, i * 200);
        }
      }, 2000);
      
      setTimeout(() => {
        console.log('📱 ESTRÉS - Simulando notificaciones extremas...');
        // Múltiples notificaciones
        for (let i = 0; i < 3; i++) {
          setTimeout(() => {
            if ('Notification' in window) {
              Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                  new Notification(`Notificación de estrés ${i + 1}`, {
                    body: 'Esta notificación podría interrumpir el audio',
                    icon: '/favicon.ico'
                  });
                }
              });
            }
          }, i * 1000);
        }
      }, 3000);
      
      setTimeout(() => {
        console.log('💾 ESTRÉS - Simulando carga de memoria...');
        // Cargar memoria para simular estrés
        const memoryStress = [];
        for (let i = 0; i < 1000; i++) {
          memoryStress.push(new Array(1000).fill(Math.random()));
        }
      }, 4000);
      
      // Reporte final después de 20 segundos
      setTimeout(() => {
        console.log('\n📊 REPORTE FINAL DE ESTRÉS EXTREMO:');
        console.log('='.repeat(80));
        console.log(`✅ Mensajes exitosos: ${successCount}`);
        console.log(`❌ Interrupciones detectadas: ${interruptionCount}`);
        console.log(`📊 Tasa de éxito: ${((successCount / (successCount + interruptionCount)) * 100).toFixed(1)}%`);
        
        if (interruptionDetails.length > 0) {
          console.log('\n🔍 DETALLES DE INTERRUPCIONES EN ESTRÉS:');
          interruptionDetails.forEach((detail, index) => {
            console.log(`${index + 1}. ID: ${detail.id}, Error: ${detail.error}, Mensaje: "${detail.message}"`);
            console.log(`   Timestamp: ${detail.timestamp}`);
            console.log(`   Memory: ${detail.memory}`);
            console.log(`   Online: ${detail.online}`);
          });
        }
        
        if (interruptionCount === 0) {
          console.log('✅ ÉXITO: Sistema estable incluso en condiciones extremas de estrés');
        } else {
          console.log('❌ PROBLEMA: Se detectaron interrupciones en condiciones extremas de estrés');
          console.log('🔍 Analizar detalles para identificar patrón de interrupciones en estrés');
        }
        
        console.log('='.repeat(80));
      }, 20000);
      
      return 'Prueba de estrés extremo iniciada - revisar consola en 20 segundos';
    }
    
    // Hacer función global
    window.testExtremeStressScenario = testExtremeStressScenario;
    
    // SISTEMA DE REINTENTO AUTOMÁTICO PARA INTERRUPCIONES EXTERNAS
    function createRobustUtterance(message, options = {}) {
      const utterance = new SpeechSynthesisUtterance(message);
      
      // Configuración robusta
      utterance.volume = options.volume || 1.0;
      utterance.rate = options.rate || 1.0;
      utterance.pitch = options.pitch || 1.0;
      utterance.lang = options.lang || 'es-ES';
      
      // Sistema de reintento automático
      let retryCount = 0;
      const maxRetries = options.maxRetries || 3;
      const retryDelay = options.retryDelay || 2000;
      
      utterance.onerror = (error) => {
        console.log(`❌ Error en audio: ${error.error} - Mensaje: "${message}"`);
        
        if (error.error === 'interrupted' && retryCount < maxRetries) {
          retryCount++;
          console.log(`🔄 Reintentando audio (${retryCount}/${maxRetries}): "${message}"`);
          
          setTimeout(() => {
            const retryUtterance = createRobustUtterance(message, {
              ...options,
              maxRetries: maxRetries - 1
            });
            addToGlobalVoiceQueue(retryUtterance.text || message, {
              volume: retryUtterance.volume,
              rate: retryUtterance.rate,
              pitch: retryUtterance.pitch,
              lang: retryUtterance.lang
            });
          }, retryDelay);
        } else {
          console.log(`❌ Máximo de reintentos alcanzado para: "${message}"`);
        }
      };
      
      utterance.onstart = () => {
        console.log(`🎤 Audio iniciado: "${message}"`);
      };
      
      utterance.onend = () => {
        console.log(`✅ Audio completado: "${message}"`);
      };
      
      return utterance;
    }
    
    // Función mejorada para reproducir audio con reintento automático
    function speakWithRetry(message, options = {}) {
      const utterance = createRobustUtterance(message, options);
      addToGlobalVoiceQueue(utterance.text || 'Test message', {
  volume: utterance.volume,
  rate: utterance.rate,
  pitch: utterance.pitch,
  lang: utterance.lang
});
    }
    
    // Hacer funciones globales
    window.createRobustUtterance = createRobustUtterance;
    window.speakWithRetry = speakWithRetry;
    
    // 🚨 SOLUCIÓN DEFINITIVA: Sistema de Cola Secuencial Estricto
    let globalVoiceQueue = [];
    let isGlobalVoicePlaying = false;
    let globalVoiceProcessing = false;
    let lastVoiceActivityTime = Date.now();
    let voiceWatchdogTimer = null;
    
    // Función watchdog para detectar y resetear estado bloqueado
    function startVoiceWatchdog() {
      // Limpiar watchdog anterior si existe
      if (voiceWatchdogTimer) {
        clearInterval(voiceWatchdogTimer);
      }
      
      // Verificar cada 5 segundos si el sistema está bloqueado
      voiceWatchdogTimer = setInterval(() => {
        const now = Date.now();
        const timeSinceLastActivity = now - lastVoiceActivityTime;
        
        // Si han pasado más de 10 segundos sin actividad y hay mensajes en cola
        if (timeSinceLastActivity > 10000 && globalVoiceQueue.length > 0) {
          console.log(`🚨 WATCHDOG: Sistema de voz bloqueado detectado. Reseteando...`);
          console.log(`📊 Estado antes del reset:`, {
            queueLength: globalVoiceQueue.length,
            isPlaying: isGlobalVoicePlaying,
            isProcessing: globalVoiceProcessing,
            timeSinceLastActivity: timeSinceLastActivity
          });
          
          // Resetear estado
          isGlobalVoicePlaying = false;
          globalVoiceProcessing = false;
          
          // Intentar procesar cola nuevamente
          setTimeout(() => {
            console.log(`🔄 WATCHDOG: Reintentando procesar cola...`);
            processGlobalVoiceQueue();
          }, 500);
          
          // Actualizar tiempo de actividad
          lastVoiceActivityTime = now;
        }
      }, 5000);
    }
    
    // Iniciar watchdog
    startVoiceWatchdog();
    
    // Función definitiva para agregar mensajes a la cola global
    function addToGlobalVoiceQueue(message, options = {}) {
      // Actualizar tiempo de actividad
      lastVoiceActivityTime = Date.now();
      
      // VERIFICACIÓN CRÍTICA: NUNCA agregar mensajes de error a la cola de voz global
      const errorPhrases = [
        'Por favor seleccione un niño',
        'Por favor seleccione un juego',
        'El tiempo debe ser',
        'El tiempo mínimo',
        'El tiempo máximo',
        'Error al',
        'debe ser un número válido',
        'Validation failed'
      ];
      
      const isErrorMessage = errorPhrases.some(phrase => message.includes(phrase));
      if (isErrorMessage) {
        console.log(`🔇 BLOQUEADO: Mensaje de error detectado en cola global, no se agregará a la cola de voz: "${message}"`);
        return;
      }
      
      const queueItem = {
        message: message,
        options: options,
        timestamp: Date.now(),
        id: Math.random().toString(36).substr(2, 9)
      };
      
      globalVoiceQueue.push(queueItem);
      console.log(`📝 AGREGANDO A COLA GLOBAL: "${message}" (ID: ${queueItem.id})`);
      
      if (!isGlobalVoicePlaying && !globalVoiceProcessing) {
        processGlobalVoiceQueue();
      }
    }
    
    // Función definitiva para procesar la cola global secuencialmente
    function processGlobalVoiceQueue() {
      if (globalVoiceProcessing || globalVoiceQueue.length === 0) {
        return;
      }
      
      // Actualizar tiempo de actividad
      lastVoiceActivityTime = Date.now();
      
      globalVoiceProcessing = true;
      isGlobalVoicePlaying = true;
      
      const queueItem = globalVoiceQueue.shift();
      console.log(`🔄 PROCESANDO COLA GLOBAL: "${queueItem.message}" (ID: ${queueItem.id})`);
      
      // VERIFICACIÓN CRÍTICA FINAL: Bloquear mensajes de error antes de reproducir
      const errorPhrases = [
        'Validation failed',
        'Por favor seleccione un niño',
        'Por favor seleccione un juego',
        'El tiempo debe ser',
        'El tiempo mínimo',
        'El tiempo máximo',
        'Error al',
        'debe ser un número válido',
        'Test message' // Bloquear también test messages
      ];
      
      const isErrorMessage = errorPhrases.some(phrase => queueItem.message.includes(phrase));
      if (isErrorMessage) {
        console.log(`🔇 BLOQUEADO EN processGlobalVoiceQueue: Mensaje de error detectado: "${queueItem.message}"`);
        isGlobalVoicePlaying = false;
        globalVoiceProcessing = false;
        // Continuar con el siguiente mensaje
        setTimeout(() => processGlobalVoiceQueue(), 100);
        return;
      }
      
      // Sistema de audio robusto y funcional
      speakRobustAudio(queueItem.message, queueItem.options, queueItem.id);
    }
    
    // FUNCIÓN PARA LIMPIAR TEXTO PARA VOZ NATURAL
    function cleanTextForVoice(text) {
      if (!text || typeof text !== 'string') return text;
      
      // Reemplazar símbolos problemáticos con palabras naturales
      let cleanedText = text
        .replace(/&/g, ' y ')  // & → y
        .replace(/\(/g, ', ')   // ( → coma y espacio
        .replace(/\)/g, '')     // ) → sin espacio
        .replace(/\s+/g, ' ')  // Múltiples espacios → un espacio
        .replace(/,\s*,/g, ',') // Dobles comas → una coma
        .replace(/\s*,\s*/g, ', ') // Limpiar espacios alrededor de comas
        .trim();
      
      console.log(`🧹 Texto limpiado: "${text}" → "${cleanedText}"`);
      return cleanedText;
    }
    
    // SISTEMA DE AUDIO ROBUSTO Y FUNCIONAL CON VOZ HÍBRIDA
    function speakRobustAudio(message, options = {}, messageId = 'unknown') {
      console.log(`🔊 Reproduciendo: "${message}" (ID: ${messageId})`);
      
      // VERIFICACIÓN CRÍTICA ABSOLUTA: Última línea de defensa contra mensajes de error
      const errorPhrases = [
        'Validation failed',
        'Por favor seleccione un niño',
        'Por favor seleccione un juego',
        'El tiempo debe ser',
        'El tiempo mínimo',
        'El tiempo máximo',
        'Error al',
        'debe ser un número válido',
        'Test message'
      ];
      
      const isErrorMessage = errorPhrases.some(phrase => message.includes(phrase));
      if (isErrorMessage) {
        console.log(`🔇 BLOQUEADO EN speakRobustAudio: Mensaje de error detectado: "${message}"`);
        isGlobalVoicePlaying = false;
        globalVoiceProcessing = false;
        setTimeout(() => processGlobalVoiceQueue(), 100);
        return;
      }
      
      // Verificar disponibilidad básica
      if (!('speechSynthesis' in window)) {
        console.error('❌ SpeechSynthesis no disponible');
        isGlobalVoicePlaying = false;
        globalVoiceProcessing = false;
        setTimeout(() => processGlobalVoiceQueue(), 1000);
        return;
      }
      
      // Limpiar texto para voz natural
      const cleanedMessage = cleanTextForVoice(message);
      
      // NO cancelar - puede interrumpir audio en curso
      // window.speechSynthesis.cancel();
      
      // USAR createHybridUtterance para tener la mejor configuración de voz
      const alertCount = options.alertCount || 1;
      const utterance = createHybridUtterance(cleanedMessage, alertCount);
      
      // Guardar el onstart original de createHybridUtterance
      const originalOnStart = utterance.onstart;
      
      // Eventos optimizados
      utterance.onstart = () => {
        console.log(`🎤 Iniciando: "${cleanedMessage}"`);
        // Ejecutar también el onstart original que incluye takeAudioDeviceControl
        if (originalOnStart) originalOnStart();
      };
      
      utterance.onend = () => {
        console.log(`✅ Completado: "${cleanedMessage}"`);
        lastVoiceActivityTime = Date.now();
        isGlobalVoicePlaying = false;
        globalVoiceProcessing = false;
        setTimeout(() => processGlobalVoiceQueue(), 1000);
      };
      
      utterance.onerror = (error) => {
        console.log(`❌ Error: ${error.error} - "${cleanedMessage}"`);
        lastVoiceActivityTime = Date.now();
        isGlobalVoicePlaying = false;
        globalVoiceProcessing = false;
        // En caso de error, reintentar después de un tiempo
        setTimeout(() => processGlobalVoiceQueue(), 1500);
      };
      
      // Reproducir
      try {
        window.speechSynthesis.speak(utterance);
      } catch (error) {
        console.error(`❌ Error al reproducir: ${error.message}`);
        isGlobalVoicePlaying = false;
        globalVoiceProcessing = false;
        setTimeout(() => processGlobalVoiceQueue(), 1000);
      }
    }
    
    // Función definitiva para limpiar la cola global
    function clearGlobalVoiceQueue() {
      globalVoiceQueue = [];
      isGlobalVoicePlaying = false;
      globalVoiceProcessing = false;
      // NO cancelar - puede interrumpir audio en curso
      // window.speechSynthesis.cancel();
      console.log('🧹 COLA GLOBAL LIMPIADA');
    }
    
    // SISTEMA SIMPLE - SIN PRUEBAS AUTOMÁTICAS
    console.log('🔊 Sistema de audio simple cargado');
    
    // Función definitiva para obtener estado de la cola global
    function getGlobalVoiceQueueStatus() {
      return {
        queueLength: globalVoiceQueue.length,
        isPlaying: isGlobalVoicePlaying,
        isProcessing: globalVoiceProcessing
      };
    }
    
    // Hacer funciones globales
    window.addToGlobalVoiceQueue = addToGlobalVoiceQueue;
    window.clearGlobalVoiceQueue = clearGlobalVoiceQueue;
    window.getGlobalVoiceQueueStatus = getGlobalVoiceQueueStatus;
    
    // SISTEMA ADAPTATIVO DE REPETICIONES
    function calculateAdaptiveRepetitions(message, alertCount) {
      if (!adaptiveAlertSystem.enabled) {
        return { repetitions: 1, delay: 0 }; // Repetición única si está deshabilitado
      }
      
      let repetitions;
      let delay;
      
      // LÓGICA INTELIGENTE PARA EVITAR CONTAMINACIÓN DE AUDIO
      if (alertCount === 1) {
        // 1 niño: 3 repeticiones con delays largos para dar tiempo
        repetitions = 3;
        delay = 45000; // 45 segundos entre cada llamado
      } else if (alertCount === 2) {
        // 2 niños: 2 repeticiones con delay moderado
        repetitions = 2;
        delay = 60000; // 1 minuto entre llamados
      } else if (alertCount <= 5) {
        // 3-5 niños: 2 repeticiones con delay largo
        repetitions = 2;
        delay = 90000; // 1.5 minutos entre llamados
      } else {
        // 6+ niños: 1 mensaje consolidado inmediato
        // En este caso, los padres deben estar atentos por la cantidad
        repetitions = 1;
        delay = 0;
      }
      
      console.log(`🧠 ADAPTATIVO INTELIGENTE: ${alertCount} niños → ${repetitions} repeticiones, delay: ${delay}ms (${delay/1000}s)`);
      return { repetitions, delay };
    }
    
    // SISTEMA DE VOZ CORREGIDO - SOLUCIÓN A TODOS LOS PROBLEMAS
    async function speakAlertWithRepetitionFixed(pendingAlerts, alertCount) {
      // FORZAR ACTIVACIÓN DEL SISTEMA DE VOZ
      voiceNotificationsEnabled = true;
      voiceSystemActivated = true;
      voicePermissionsGranted = true;
      
      console.log(`🔊 PROCESANDO ALERTA DE VOZ (forzado activo)`);
      
      console.log(`🧠 SISTEMA CORREGIDO: Procesando ${alertCount} alertas`);
      console.log(`📊 pendingAlerts:`, pendingAlerts);
      
      // VALIDAR DATOS DE ENTRADA
      if (!pendingAlerts || pendingAlerts.length === 0) {
        console.log(`⚠️ speakAlertWithRepetitionFixed: pendingAlerts vacío o inválido`);
        return;
      }
      
      // EXTRAER NOMBRES CON VALIDACIÓN ROBUSTA
      console.log(`🔍 DEBUG: Estructura de pendingAlerts:`, pendingAlerts.map(alert => ({
        text: alert.text,
        hasText: !!alert.text,
        textType: typeof alert.text,
        keys: Object.keys(alert)
      })));
      
      const childNames = pendingAlerts.map(alert => {
        console.log(`🔍 DEBUG: Procesando alert:`, alert);
        
        // MANEJAR DOS TIPOS DE ESTRUCTURA:
        let name = null;
        
        if (alert.name) {
          // Estructura: {name: 'sofia', parents: 'Papá: fernando'}
          name = alert.name;
          console.log(`🔍 DEBUG: Nombre directo: "${name}"`);
        } else if (alert.text) {
          // Estructura: {text: '¡Atención! A sofia le quedan solo 30 segundos'}
          name = extractChildNameFromAlert(alert.text);
          console.log(`🔍 DEBUG: Nombre extraído de texto: "${name}"`);
        }
        
        console.log(`🔍 DEBUG: Nombre final: "${name}"`);
        return name && name !== 'null' ? name : null;
      }).filter(name => name !== null);
      
      console.log(`👶 NOMBRES EXTRAÍDOS:`, childNames);
      
      // GENERAR MENSAJE SEGÚN ESCENARIOS CON INFORMACIÓN DE PADRES
      let message;
      
      // Obtener información de padres de pendingAlerts - SIN DUPLICADOS
      const uniqueChildren = new Map();
      
      pendingAlerts.forEach(alert => {
        let childName = null;
        let parentsInfo = '';
        
        if (alert.name) {
          // Estructura: {name: 'sofia', parents: 'Papá: fernando'}
          childName = alert.name;
          parentsInfo = alert.parents || '';
        } else if (alert.text) {
          // Estructura: {text: '¡Atención! A sofia le quedan solo 30 segundos'}
          childName = extractChildNameFromAlert(alert.text);
          // Buscar información del niño en childrenCache
          const child = childrenCache.find(c => c.name === childName);
          
          if (child) {
            if (child.fatherName && child.motherName) {
              parentsInfo = `Papá: ${child.fatherName} & Mamá: ${child.motherName}`;
            } else if (child.fatherName) {
              parentsInfo = `Papá: ${child.fatherName}`;
            } else if (child.motherName) {
              parentsInfo = `Mamá: ${child.motherName}`;
            }
          }
        }
        
        if (childName && childName !== 'null') {
          // Usar nombre como clave única para evitar duplicados
          uniqueChildren.set(childName, { name: childName, parents: parentsInfo });
        }
      });
      
      const childrenWithParents = Array.from(uniqueChildren.values());
      
      if (childrenWithParents.length === 1) {
        const child = childrenWithParents[0];
        if (child.parents) {
          // Estructura natural: primero el mensaje, luego los padres
          if (child.parents.includes('&')) {
            // Cuando hay papá y mamá: "Hola, david ha terminado su tiempo de juego. Papá: harrison y Mamá: maria, por favor recójanlo"
            message = `Hola, ${child.name} ha terminado su tiempo de juego. ${child.parents.replace(/&/g, 'y')}, por favor recójanlo.`;
          } else {
            // Solo papá o solo mamá: "Hola, david ha terminado su tiempo de juego. Papá: fernando, por favor recógelo"
            message = `Hola, ${child.name} ha terminado su tiempo de juego. ${child.parents}, por favor recógelo.`;
          }
        } else {
          message = `Hola, ${child.name} ha terminado su tiempo de juego. Por favor, recógelo.`;
        }
      } else if (childrenWithParents.length === 2) {
        const child1 = childrenWithParents[0];
        const child2 = childrenWithParents[1];
        
        let fullMessage = `Hola, ${child1.name}`;
        if (child1.parents) fullMessage += ` (${child1.parents})`;
        fullMessage += ` y ${child2.name}`;
        if (child2.parents) fullMessage += ` (${child2.parents})`;
        fullMessage += ` han terminado su tiempo de juego. Por favor, recógelos.`;
        
        message = fullMessage;
      } else if (childrenWithParents.length <= 5) {
        // LISTAR NOMBRES ESPECÍFICOS HASTA 5
        const names = childrenWithParents.map(child => {
          return child.parents ? `${child.name} (${child.parents})` : child.name;
        });
        const lastChild = names.pop();
        const otherChildren = names.join(', ');
        message = `Hola, ${otherChildren} y ${lastChild} han terminado su tiempo de juego. Por favor, recógelos.`;
      } else {
        // MENSAJE CONSOLIDADO PARA 6+ NIÑOS
        message = `Hola, ${childrenWithParents.length} niños han terminado su tiempo de juego. Por favor, recógelos.`;
      }
      
      console.log(`🔊 MENSAJE GENERADO: "${message}"`);
      
      // REPRODUCIR CON REPETICIONES ADAPTATIVAS
      const { repetitions, delay } = calculateAdaptiveRepetitions('', alertCount);
      
      console.log(`🔊 ACTIVANDO SISTEMA DE REPETICIONES: ${repetitions} repeticiones con ${delay}ms de delay`);
      
      // AGREGAR TODAS LAS REPETICIONES A LA COLA DE VOZ
      for (let i = 0; i < repetitions; i++) {
        if (i === 0) {
          // Primera repetición inmediata
          addToVoiceQueue(message, { immediate: true });
        } else {
          // Repeticiones subsecuentes con delay
          setTimeout(() => {
            addToVoiceQueue(message, { immediate: false });
          }, i * delay);
        }
      }
    }
    
    // GENERADOR DE MENSAJES NATURALES Y PERSONALIZADOS - USAR FUNCIONES CORREGIDAS
    function generateNaturalVoiceMessage(pendingAlerts, alertCount) {
      console.log(`🎯 GENERANDO MENSAJE NATURAL PARA ${alertCount} NIÑOS (USANDO FUNCIONES CORREGIDAS)`);
      
      // USAR FUNCIONES CORREGIDAS
      return generateNaturalVoiceMessageFixed(pendingAlerts, alertCount);
    }
    
    function shouldShowAlert(type, options) {
      // Alertas críticas siempre se muestran
      if (type === 'error' || type === 'danger') {
        return true;
      }
      
      // Verificar preferencias por tipo
      switch (type) {
        case 'success':
          return alertPreferences.showSuccessAlerts;
        case 'warning':
          return alertPreferences.showVisualAlerts;
        case 'info':
          return alertPreferences.showStatusAlerts;
        default:
          return true;
      }
    }
    
    function determineAlertTypes(type, options) {
      // REGLA CRÍTICA 1: ERRORES NUNCA TIENEN VOZ - SIN EXCEPCIONES
      if (type === 'error' || type === 'danger') {
        console.log('🔇 TIPO ERROR DETECTADO EN determineAlertTypes - VOZ FORZADA A FALSE');
        return {
          visual: alertPreferences.showVisualAlerts,
          voice: false, // FORZAR A FALSE PARA ERRORES
          browser: alertPreferences.showBrowserNotifications
        };
      }
      
      // REGLA CRÍTICA 2: Si voiceOnly es explícitamente false, desactivar voz inmediatamente
      if (options.voiceOnly === false) {
        console.log('🔇 VOZ DESACTIVADA EXPLÍCITAMENTE - Retornando sin voz');
        return {
          visual: alertPreferences.showVisualAlerts,
          voice: false, // FORZAR A FALSE
          browser: alertPreferences.showBrowserNotifications
        };
      }
      
      const result = {
        visual: alertPreferences.showVisualAlerts && !options.voiceOnly,
        voice: alertPreferences.showVoiceAlerts && !options.voiceOnly && !options.visualOnly,
        browser: alertPreferences.showBrowserNotifications && !options.visualOnly
      };
      
      return result;
    }
    
    function showVisualAlert(text, type, sessionId) {
      console.log(`🔔 showVisualAlert LLAMADA: "${text}" [${type}] sessionId: ${sessionId}`);
      
      // CANCELAR ALERTA ANTERIOR SI EXISTE
      const existingMsg = document.getElementById('statusMessage');
      if (existingMsg && existingMsg.timeoutId) {
        console.log(`🔔 CANCELANDO ALERTA ANTERIOR: "${existingMsg.textContent}"`);
        clearTimeout(existingMsg.timeoutId);
        existingMsg.remove();
      }
      
      // CREAR NUEVA ALERTA
      let msg = document.createElement('div');
      msg.id = 'statusMessage';
      msg.className = 'status-message';
      msg.innerHTML = `
        <span class="status-text"></span>
        <button class="status-close" onclick="hideStatusMessage()" title="Cerrar">
          <i class="fas fa-times"></i>
        </button>
      `;
      document.body.appendChild(msg);
      
      // Reproducir sonido según el tipo
      if (type === 'warning' || type === 'danger') {
        playNotificationSound(type);
      }
      
      // Limpiar cualquier timeout anterior
      if (msg.timeoutId) {
        clearTimeout(msg.timeoutId);
      }
      
      // Usar el span para el texto
      const textSpan = msg.querySelector('.status-text');
      if (textSpan) {
        textSpan.textContent = text;
      } else {
        msg.textContent = text; // Fallback para compatibilidad
      }
      msg.className = `status-message ${type} show`;
      msg.style.display = 'flex'; // Asegurar que se muestre
      msg.style.transform = 'translateX(0)'; // Asegurar que esté en posición visible
      
      // NO marcar sesión como alertada - permitir todas las notificaciones
      
      // Auto-ocultar después de tiempo apropiado según el tipo
      let timeoutDuration;
      if (type === 'error') {
        // Para errores de validación, mostrar menos tiempo para mejor UX
        if (text.includes('Validation failed') || text.includes('Por favor seleccione')) {
          timeoutDuration = 4000; // 4 segundos para errores de validación
        } else {
          timeoutDuration = 6000; // Errores más tiempo para leer
        }
      } else if (type === 'warning') {
        // Alertas de warning con texto largo (nombres + padres) necesitan más tiempo
        if (text.includes('terminó su tiempo') || text.includes('Tiempo terminado')) {
          timeoutDuration = 12000; // 12 segundos para alertas de tiempo terminado
        } else if (text.includes('30 segundos')) {
          timeoutDuration = 7000; // 7 segundos para alertas de 30 segundos
        } else {
          timeoutDuration = text.length > 50 ? 8000 : 6000; // Más tiempo para texto largo
        }
      } else {
        timeoutDuration = text.length < 10 ? 2000 : 4000; // Éxito menos tiempo
      }
      
      msg.timeoutId = setTimeout(() => {
        console.log(`🔔 ALERTA OCULTÁNDOSE AUTOMÁTICAMENTE: "${text}" después de ${timeoutDuration}ms`);
        // Usar la función de ocultar que remueve completamente del DOM
        hideStatusMessage();
        
        // NO limpiar alertas de sesión - permitir todas las notificaciones
      }, timeoutDuration);
      
      console.log(`✅ ALERTA VISUAL CONFIGURADA: "${text}" se ocultará en ${timeoutDuration}ms`);
      
      // Log específico para alertas de 30 segundos
      if (text.includes('30 segundos')) {
        console.log(`🚨 ALERTA DE 30 SEGUNDOS VISUAL: "${text}" - Debería ser visible por ${timeoutDuration}ms`);
      }
    }

    // Función para ocultar manualmente el mensaje de estado
    function hideStatusMessage() {
      const msg = document.getElementById('statusMessage');
      if (msg) {
        console.log(`🔔 hideStatusMessage LLAMADA: ocultando "${msg.textContent}"`);
        msg.style.display = 'none';
        msg.style.opacity = '0';
        msg.style.transform = 'translateX(400px)';
        
        // REMOVER COMPLETAMENTE DEL DOM DESPUÉS DE LA ANIMACIÓN
        setTimeout(() => {
          if (msg && msg.parentNode) {
            console.log(`🔔 REMOVIENDO ALERTA DEL DOM: "${msg.textContent}"`);
            msg.remove();
          }
        }, 300); // Esperar 300ms para la animación
      }
    }

    function showLoading(buttonId, show = true) {
      const button = document.getElementById(buttonId);
      if (!button) return;
      
      if (show) {
        button.disabled = true;
        button.innerHTML = '<div class="loading"></div> Procesando...';
      } else {
        button.disabled = false;
        // Restaurar texto original basado en el botón
        if (buttonId === 'addChildBtn') {
          button.innerHTML = '<i class="fas fa-plus"></i> Agregar Niño';
        } else if (buttonId === 'addGameBtn') {
          button.innerHTML = '<i class="fas fa-plus"></i> Agregar Juego';
        } else if (buttonId === 'startBtn') {
          button.innerHTML = '<i class="fas fa-play"></i> Iniciar Sesión';
        }
      }
    }

    // Función para limpiar todas las alertas de sesiones
    function clearAllSessionAlerts() {
      alertedSessions.clear();
      // Sistema de alertas individuales - no hay consolidación que limpiar
      const msg = document.getElementById('statusMessage');
      if (msg) {
        if (msg.timeoutId) {
          clearTimeout(msg.timeoutId);
          msg.timeoutId = null;
        }
        msg.classList.remove('show');
        msg.textContent = '';
        msg.className = 'status-message';
      }
    }

    // Función para cerrar manualmente todas las alertas (para casos críticos)
    function dismissAllAlerts() {
      clearAllSessionAlerts();
      showStatusMessage('✅ Todas las alertas cerradas', 'success');
    }

    // Función inteligente para determinar si mostrar información de padres
    function shouldShowParentsInfo(context, children) {
      switch(context) {
        case 'search':
        case 'list':
        case 'history':
          return true; // Siempre mostrar en estos contextos
          
        case 'alert':
          // En alertas, solo si hay nombres duplicados
          const nameCount = {};
          children.forEach(child => {
            nameCount[child.name] = (nameCount[child.name] || 0) + 1;
          });
          return Object.values(nameCount).some(count => count > 1);
          
        case 'ranking':
          // En ranking, solo si hay duplicados
          const rankingNames = {};
          children.forEach(child => {
            rankingNames[child.name] = (rankingNames[child.name] || 0) + 1;
          });
          return Object.values(rankingNames).some(count => count > 1);
          
        default:
          return false;
      }
    }



    // Función para limpiar alerta específica de sesión
    function clearSessionAlert(sessionId) {
      alertedSessions.delete(sessionId);
      const msg = document.getElementById('statusMessage');
      if (msg && msg.textContent.includes('quedan solo') && msg.textContent.includes('segundos')) {
        if (msg.timeoutId) {
          clearTimeout(msg.timeoutId);
          msg.timeoutId = null;
        }
        msg.classList.remove('show');
        msg.textContent = '';
        msg.className = 'status-message';
      }
    }


    // Sistema de notificaciones con sonido
    function playNotificationSound(type = 'default') {
      try {
        // Crear audio context para sonidos
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        let frequency = 800;
        let duration = 0.2;
        
        switch(type) {
          case 'warning':
            frequency = 600;
            duration = 0.3;
            break;
          case 'danger':
            frequency = 400;
            duration = 0.5;
            break;
          case 'success':
            frequency = 1000;
            duration = 0.2;
            break;
        }
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
      } catch (error) {
        console.log('Could not play notification sound:', error);
      }
    }

    // Sistema de inicialización de permisos (mejores prácticas para producción)
    async function initializeNotificationPermissions() {
      try {
        console.log('🎤 Inicializando sistema de notificaciones de voz...');
        
        // Verificar soporte de APIs
        const hasSpeechSynthesis = 'speechSynthesis' in window;
        const hasNotifications = 'Notification' in window;
        
        console.log('🔍 Soporte APIs:', { speechSynthesis: hasSpeechSynthesis, notifications: hasNotifications });
        
        if (!hasSpeechSynthesis) {
          console.warn('⚠️ Speech Synthesis no soportado en este navegador');
          // NO desactivar voz - mantener habilitada
          console.log('🔧 Manteniendo voz habilitada a pesar de la falta de soporte');
          return;
        }
        
        if (!hasNotifications) {
          console.warn('⚠️ Notifications API no soportado en este navegador');
        }
        
        // Verificar voces disponibles - CRÍTICO para producción
        let voices = window.speechSynthesis.getVoices();
        
        // En algunos navegadores, las voces necesitan tiempo para cargar
        if (voices.length === 0) {
          console.log('🔄 Cargando voces del navegador...');
          await new Promise(resolve => {
            const loadVoices = () => {
              voices = window.speechSynthesis.getVoices();
              if (voices.length > 0) {
                resolve();
              } else {
                setTimeout(loadVoices, 100);
              }
            };
            loadVoices();
          });
        }
        
        console.log('🎙️ Voces disponibles:', voices.length);
        
        const spanishVoices = voices.filter(voice => voice.lang.startsWith('es'));
        console.log('🇪🇸 Voces en español:', spanishVoices.length);
        
        // Verificar voz femenina disponible usando función helper
        const selectedVoice = getFemaleSpanishVoice();
        
        if (spanishVoices.length === 0) {
          console.warn('⚠️ No se encontraron voces en español disponibles');
          showStatusMessage('⚠️ No hay voces en español - usará inglés como fallback', 'warning');
        } else {
          console.log('✅ Voces en español encontradas:', spanishVoices.map(v => v.name).join(', '));
          if (selectedVoice) {
            console.log('👩 Voz femenina seleccionada:', selectedVoice.name);
          } else {
            console.log('👩 No se detectaron voces específicamente femeninas, usando la primera disponible');
          }
        }
        
        // Solicitar permisos de notificaciones del navegador
        if (hasNotifications && Notification.permission === 'default') {
          const permission = await Notification.requestPermission();
          browserNotificationsEnabled = permission === 'granted';
          window.browserNotificationsEnabled = browserNotificationsEnabled; // Actualizar variable global
          
          if (browserNotificationsEnabled) {
            showStatusMessage('🔔 Notificaciones del navegador activadas', 'success');
          } else {
            showStatusMessage('🔕 Notificaciones del navegador denegadas', 'warning');
          }
        } else if (hasNotifications) {
          browserNotificationsEnabled = Notification.permission === 'granted';
          window.browserNotificationsEnabled = browserNotificationsEnabled; // Actualizar variable global
        }
        
        // PRUEBA CRÍTICA: Hacer un test de voz para activar el sistema (SILENCIOSO)
        try {
          await testVoiceSystem();
        } catch (error) {
          console.warn('⚠️ Test de voz falló (continuando):', error);
          // NO desactivar voz - mantener habilitada
          console.log('🔧 Manteniendo voz habilitada a pesar del error de test');
        }
        
        voicePermissionsGranted = true;
        console.log('✅ Sistema de notificaciones inicializado correctamente');
        
      } catch (error) {
        console.error('❌ Error inicializando permisos:', error);
        showStatusMessage('❌ Error configurando notificaciones: ' + error.message, 'error');
        voicePermissionsGranted = false;
      }
    }
    
    // Función para probar el sistema de voz (crítico para producción)
    async function testVoiceSystem() {
      try {
        console.log('🧪 Probando sistema de voz...');
        
        if (!('speechSynthesis' in window)) {
          throw new Error('Speech Synthesis no soportado');
        }
        
        // NO cancelar aquí - respetar cola secuencial
        // window.speechSynthesis.cancel();
        
        // Crear un test básico SILENCIOSO
        const testUtterance = new SpeechSynthesisUtterance('');
        testUtterance.volume = 0; // COMPLETAMENTE SILENCIOSO
        testUtterance.rate = 1;
        
        // Configurar idioma básico
        testUtterance.lang = 'es-ES';
        
        // Configurar eventos para detectar problemas
        testUtterance.onstart = () => {
          console.log('✅ Sistema de voz funcionando correctamente');
        };
        
        testUtterance.onerror = (event) => {
          console.warn('⚠️ Error en sistema de voz (continuando):', event.error);
          // NO desactivar voz - mantener habilitada
          console.log('🔧 Manteniendo voz habilitada a pesar del error');
          // Resolver inmediatamente para no bloquear
          return true;
        };
        
        // Ejecutar test (sin esperar)
        addToGlobalVoiceQueue(testUtterance.text || 'Test message', {
          volume: testUtterance.volume,
          rate: testUtterance.rate,
          pitch: testUtterance.pitch,
          lang: testUtterance.lang
        });
        
        // Esperar un momento para ver si hay errores (con timeout)
        await new Promise(resolve => {
          const timeout = setTimeout(() => {
            console.log('⏰ Timeout en test de voz - continuando');
            resolve(true);
          }, 500); // 500ms máximo
          
          // Si hay error, se resuelve en onerror
          testUtterance.onend = () => {
            clearTimeout(timeout);
            resolve(true);
          };
        });
        
        return true;
        
      } catch (error) {
        console.error('❌ Fallo en test de voz:', error);
        // NO desactivar voz - mantener habilitada
        console.log('🔧 Manteniendo voz habilitada a pesar del error');
        return true; // Cambiar a true para no bloquear
      }
    }

    // Control de notificaciones de voz (mejorado para producción)
    function toggleVoiceNotifications() {
      // Activar sistema de voz en esta interacción del usuario
      activateVoiceSystemOnUserInteraction();
      
      // Establecer permisos como concedidos al activar
      voicePermissionsGranted = true;
      window.voicePermissionsGranted = true;
      
      voiceNotificationsEnabled = !voiceNotificationsEnabled;
      window.voiceNotificationsEnabled = voiceNotificationsEnabled; // Actualizar variable global
      
      const voiceToggle = document.getElementById('voiceToggle');
      const voiceStatus = document.getElementById('voiceStatus');
      const icon = voiceToggle.querySelector('i');
      
      if (voiceNotificationsEnabled) {
        voiceToggle.classList.remove('muted');
        icon.className = 'fas fa-volume-up';
        voiceStatus.textContent = 'Voz Activada';
        
        // MEJORA PARA iOS/BLUETOOTH: Intentar tomar control del dispositivo de audio
        takeAudioDeviceControl().catch(err => {
          console.log('⚠️ No se pudo tomar control de audio en toggle:', err.message);
        });
        
        // Hacer un test rápido para verificar que funciona - USANDO LA MISMA VOZ Y PARÁMETROS OPTIMIZADOS
        setTimeout(() => {
          try {
            const testUtterance = new SpeechSynthesisUtterance('Voz activada');
            
            // Obtener parámetros optimizados por navegador
            const voiceParams = getVoiceParameters();
            testUtterance.lang = voiceParams.lang;
            testUtterance.rate = voiceParams.rate * 1.2; // Un poco más rápido para el test
            testUtterance.pitch = voiceParams.pitch;
            testUtterance.volume = 0.3; // Volumen bajo para el test
            
            // Configurar la MISMA voz que se usa para los nombres de los niños
            const selectedVoice = getFemaleSpanishVoice();
            if (selectedVoice) {
              testUtterance.voice = selectedVoice;
              console.log('🎤 Test de voz usando la misma voz que los nombres:', selectedVoice.name, selectedVoice.lang);
            } else {
              console.warn('⚠️ No se encontró voz en español para el test');
            }
            
            addToGlobalVoiceQueue(testUtterance.text || 'Test message', {
          volume: testUtterance.volume,
          rate: testUtterance.rate,
          pitch: testUtterance.pitch,
          lang: testUtterance.lang
        });
          } catch (error) {
            console.error('Error en test de voz:', error);
          }
        }, 500);
        
      } else {
        voiceToggle.classList.add('muted');
        icon.className = 'fas fa-volume-mute';
        voiceStatus.textContent = 'Voz Desactivada';
        showStatusMessage('🔇 Notificaciones de voz desactivadas', 'info');
        
        // NO cancelar aquí - respetar cola secuencial
        // window.speechSynthesis.cancel();
      }
    }



    // Función helper global para crear utterance híbrido
    function createHybridUtterance(msg, alertCount = 1) {
      const hybridConfig = getHybridVoiceSystem();
      const utterance = new SpeechSynthesisUtterance(msg);
      const browser = detectBrowser();
      
      // Aplicar configuración híbrida
      Object.assign(utterance, hybridConfig);
      
      // MEJORAS ADICIONALES PARA PRONUNCIACIÓN EN NAVEGADORES NO-SAFARI
      if (browser !== 'safari') {
        // Ajustes específicos para mejorar pronunciación en Chrome/Firefox/Edge
        utterance.rate = Math.max(utterance.rate * 0.95, 0.6); // Ligeramente más lento para claridad
        utterance.pitch = Math.min(utterance.pitch * 1.05, 1.3); // Pitch ligeramente más alto para naturalidad
        utterance.volume = Math.min(utterance.volume * 1.02, 1.0); // Volumen ligeramente más alto
        
        // Asegurar idioma español
        utterance.lang = 'es-ES';
        
        console.log(`🔧 Aplicando optimizaciones de pronunciación para ${browser}:`, {
          rate: utterance.rate,
          pitch: utterance.pitch,
          volume: utterance.volume,
          lang: utterance.lang
        });
      }
      
      // Ajustar según cantidad de niños
      if (alertCount > 3) {
        utterance.rate = Math.max(utterance.rate * 0.9, 0.5);
        utterance.volume = Math.min(utterance.volume * 1.1, 1.0);
      }
      
      // MEJORA PARA iOS/BLUETOOTH: Preparar audio context antes de hablar
      utterance.onstart = () => {
        console.log(`🎤 Iniciando reproducción de voz: "${msg}"`);
        
        // Intentar tomar control del dispositivo de audio
        takeAudioDeviceControl().catch(err => {
          console.log('⚠️ No se pudo tomar control de audio:', err.message);
        });
      };
      
      return utterance;
    }

    // Función para repetir mensajes 3 veces (mejorada para producción)
    function speakWithRepetition(message, alertCount) {
      console.log(`🔊 speakWithRepetition llamado con mensaje:`, message);
      console.log(`🔊 Estado del sistema:`, { 
        voiceNotificationsEnabled, 
        voiceSystemActivated, 
        speechSynthesisAvailable: 'speechSynthesis' in window 
      });
      
      // Verificar que el sistema de voz esté disponible y habilitado
      if (!voiceNotificationsEnabled || !('speechSynthesis' in window)) {
        console.warn('⚠️ Sistema de voz no disponible:', { voiceNotificationsEnabled, speechSynthesis: 'speechSynthesis' in window });
        return;
      }
      
      console.log(`🔊 Iniciando alerta de voz: ${alertCount} niño(s)`);
      
      // Usar sistema de cola para evitar interrupciones
      console.log('🎤 Usando sistema de COLA para repetición sin interrupciones');
      
      // LÓGICA ADAPTATIVA PARA EVITAR CONTAMINACIÓN DE AUDIO
      const repetitions = calculateAdaptiveRepetitions(message, alertCount);
      
      console.log(`🎤 Usando sistema ADAPTATIVO: ${repetitions.length} repeticiones para ${alertCount} niño(s)`);
      
      repetitions.forEach((rep, index) => {
        if (rep.options.immediate) {
          // Primera repetición inmediata
          addToVoiceQueue(rep.message, rep.options);
        } else {
          // Repeticiones con delay
          setTimeout(() => {
            addToVoiceQueue(rep.message, rep.options);
          }, rep.options.delay);
        }
      });
      
      console.log(`📝 Agregadas ${repetitions.length} repeticiones ADAPTATIVAS a la cola de voz`);
      console.log(`🔊 Alerta adaptativa programada: ${alertCount} niño(s) - ${repetitions.length} repeticiones`);
    }
    
    // FUNCIÓN DUPLICADA ELIMINADA - USAR SOLO speakAlertWithRepetitionFixed


    // Función para alertas de múltiples niños (más de 5) - DEPRECATED
    function speakMultipleChildrenAlert(pendingAlerts) {
      const children = Array.from(pendingAlerts.values());
      
      // Crear lista de nombres únicos (diferenciando por padres si es necesario)
      const uniqueNames = new Map();
      children.forEach(child => {
        let key = child.name;
        if (child.parents) {
          const parentName = child.parents.split(' & ')[0];
          key = `${child.name} (${parentName})`;
        }
        uniqueNames.set(key, child);
      });
      
      const names = Array.from(uniqueNames.keys());
      
      // Mensaje principal
      const mainMessage = `ATENCIÓN: ${children.length} niños han terminado su tiempo de juego`;
      
      // Lista de nombres (uno por uno)
      const nameList = names.join(', ');
      const detailedMessage = `Los niños son: ${nameList}`;
      
      // Mensaje de llamada a padres
      const callMessage = `Por favor, padres, recojan a sus hijos inmediatamente`;
      
      // Repetir 3 veces con pausas
      const fullMessage = `${mainMessage}. ${detailedMessage}. ${callMessage}`;
      
      // Función helper para crear utterance con voz mejorada y parámetros optimizados por navegador
      const createUtteranceWithVoice = (message) => {
        const utterance = new SpeechSynthesisUtterance(message);
        
        // Obtener parámetros optimizados por navegador
        const voiceParams = getVoiceParameters();
        utterance.lang = voiceParams.lang;
        utterance.rate = voiceParams.rate;
        utterance.pitch = voiceParams.pitch;
        utterance.volume = voiceParams.volume;
        
        // Configurar voz femenina en español (usando función helper mejorada)
        const selectedVoice = getFemaleSpanishVoice();
        
        if (selectedVoice) {
          utterance.voice = selectedVoice;
          console.log('🎤 Voz seleccionada:', selectedVoice.name, selectedVoice.lang, 'localService:', selectedVoice.localService);
        } else {
          console.warn('⚠️ No se encontró voz en español, usando configuración por defecto');
        }
        
        return utterance;
      };
      
      // Primera repetición
      setTimeout(() => {
        const utterance1 = createUtteranceWithVoice(fullMessage);
        addToGlobalVoiceQueue(utterance1.text || fullMessage, {
          volume: utterance1.volume,
          rate: utterance1.rate,
          pitch: utterance1.pitch,
          lang: utterance1.lang
        });
      }, 100);
      
      // Segunda repetición (después de 15 segundos - mejorado)
      setTimeout(() => {
        const utterance2 = createUtteranceWithVoice(fullMessage);
        addToGlobalVoiceQueue(utterance2.text || fullMessage, {
          volume: utterance2.volume,
          rate: utterance2.rate,
          pitch: utterance2.pitch,
          lang: utterance2.lang
        });
      }, 15000);
      
      // Tercera repetición (después de 30 segundos - mejorado)
      setTimeout(() => {
        const utterance3 = createUtteranceWithVoice(fullMessage);
        addToGlobalVoiceQueue(utterance3.text || fullMessage, {
          volume: utterance3.volume,
          rate: utterance3.rate,
          pitch: utterance3.pitch,
          lang: utterance3.lang
        });
      }, 30000);
      
      console.log(`🔊 Alerta múltiple: ${children.length} niños - ${names.length} nombres únicos`);
    }

    // Sistema de notificaciones de voz
    function speakChildName(childName, parentsInfo = '') {
      try {
        // Verificar si las notificaciones de voz están habilitadas
        if (!voiceNotificationsEnabled) {
          console.log('Notificaciones de voz desactivadas');
          return;
        }

        // Verificar si el navegador soporta Speech Synthesis
        if (!('speechSynthesis' in window)) {
          console.warn('Speech synthesis no soportado en este navegador');
          return;
        }

        // NO cancelar aquí - puede interrumpir audio en curso
        // window.speechSynthesis.cancel();

        // Las voces se cargarán en getFemaleSpanishVoice si es necesario

        // Crear el mensaje personalizado
        let message = `${childName}, tu tiempo de juego ha terminado`;
        if (parentsInfo) {
          message += `. ${parentsInfo}, por favor recojan a ${childName}`;
        }

        // Usar sistema híbrido para sonido humano universal
        console.log('🎤 Usando sistema híbrido para sonido humano universal');
        return speakWithHybridVoice(message);
        
        console.log(`🔊 Mensaje de voz: "${message}"`);
        
      } catch (error) {
        console.error('Error en síntesis de voz:', error);
        // Fallback al sonido normal si falla la voz
        playNotificationSound('warning');
      }
    }

    // Sistema de alertas mejorado
    function showCustomModal(msg) {
      // Reproducir sonido de notificación
      playNotificationSound('danger');
      
      // Mostrar notificación del navegador
      showBrowserNotification('⏰ Tiempo Terminado', msg);
      
      // Crear alerta persistente en la esquina
      const alertContainer = document.getElementById('alertContainer') || createAlertContainer();
      
      const alertId = 'alert-' + Date.now();
      const alert = document.createElement('div');
      alert.id = alertId;
      alert.className = 'persistent-alert';
      alert.innerHTML = `
        <div class="alert-content">
          <span class="alert-message">${msg}</span>
          <button class="alert-close" onclick="closeAlert('${alertId}')">
            <i class="fas fa-times"></i>
          </button>
        </div>
      `;
      
      alertContainer.appendChild(alert);
      
      // Auto-remover después de 10 segundos si no se cierra manualmente
      setTimeout(() => {
        if (document.getElementById(alertId)) {
          closeAlert(alertId);
        }
      }, 10000);
    }
    
    function createAlertContainer() {
      const container = document.createElement('div');
      container.id = 'alertContainer';
      container.className = 'alert-container';
      document.body.appendChild(container);
      return container;
    }
    
    function closeAlert(alertId) {
      const alert = document.getElementById(alertId);
      if (alert) {
        alert.style.display = 'none';
        alert.style.opacity = '0';
        alert.style.transform = 'translateX(100%)';
        alert.style.transition = 'all 0.3s ease';
        setTimeout(() => {
          if (alert && alert.parentNode) {
          alert.remove();
          }
        }, 100);
      }
    }

    // Función para limpiar alertas transparentes
    function clearTransparentAlerts() {
      // Limpiar statusMessage específicamente
      const statusMsg = document.getElementById('statusMessage');
      if (statusMsg) {
        statusMsg.style.display = 'none';
        statusMsg.style.opacity = '0';
        statusMsg.style.transform = 'translateX(400px)';
      }
      
      // Limpiar otras alertas transparentes
      const alerts = document.querySelectorAll('.status-message, .alert-container > div');
      alerts.forEach(alert => {
        if (alert.style.opacity === '0' || alert.style.display === 'none') {
          alert.remove();
        }
      });
    }
    
    
    // Función para mostrar alertas elegantes
    function showElegantAlert(msg, type = 'info', sessionId = null) {
      const container = document.getElementById('alertContainer') || createAlertContainer();
      const alertId = `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      const alertElement = document.createElement('div');
      alertElement.className = 'persistent-alert';
      alertElement.id = alertId;
      
      // Truncar mensaje si es muy largo
      const truncatedMsg = msg.length > 60 ? msg.substring(0, 57) + '...' : msg;
      
      alertElement.innerHTML = `
        <div class="alert-content">
          <div class="alert-message">${truncatedMsg}</div>
          <button class="alert-close" onclick="closeAlert('${alertId}')">
            <i class="fas fa-times"></i>
          </button>
        </div>
      `;
      
      container.appendChild(alertElement);
      
      // Auto-cerrar después de 8 segundos
      setTimeout(() => {
        closeAlert(alertId);
      }, 8000);
      
    }

    // Función para limpiar todas las alertas persistentes
    function clearAllPersistentAlerts() {
      const alertContainer = document.getElementById('alertContainer');
      if (alertContainer) {
        alertContainer.innerHTML = '';
      }
      // También limpiar cualquier alerta que pueda estar fuera del contenedor
      document.querySelectorAll('.persistent-alert').forEach(alert => {
        alert.remove();
      });
    }

    function closeModal() {
      document.getElementById('customModal').classList.remove('show');
    }

    function showExtendModal(sessionId, childName) {
      currentExtendSession = sessionId;
      
      // Buscar información del niño para mostrar padres si existen
      const session = activeSessionsData.find(s => s.id === sessionId);
      const child = session ? childrenCache.find(c => c.id === session.childId) : null;
      
      let displayMessage = `¿Cuánto tiempo adicional quiere darle a ${childName}?`;
      if (child) {
        const parentsText = getParentsInfo(child, 'simple');
        if (parentsText) {
          displayMessage = `¿Cuánto tiempo adicional quiere darle a ${childName}${parentsText}?`;
        }
      }
      
      document.getElementById('extendMsg').textContent = displayMessage;
      document.getElementById('extendTimeInput').value = 5;
      document.getElementById('extendModal').classList.add('show');
    }

    function closeExtendModal() {
      document.getElementById('extendModal').classList.remove('show');
      currentExtendSession = null;
    }


    function validateSession(childId, gameId, duration) {
      // Solo validar duración aquí, los otros valores ya se validaron arriba
      if (isNaN(duration)) {
        showStatusMessage('El tiempo debe ser un número válido', 'error', null, { voiceOnly: false });
        return false;
      }
      if (duration < 1) {
        showStatusMessage('El tiempo mínimo es 1 minuto', 'error', null, { voiceOnly: false });
        return false;
      }
      if (duration > 180) {
        showStatusMessage('El tiempo máximo es 180 minutos', 'error', null, { voiceOnly: false });
        return false;
      }
      return true;
    }

    // Funciones de fetch ROBUSTAS con reintentos
    async function fetchWithRetry(url, options = {}, retries = 3) {
      // 🚀 OPTIMIZACIÓN: Reduce timeout para carga inicial más rápida
      const timeoutMs = options.initialLoad ? 5000 : 8000; // 5s para carga inicial, 8s para el resto
      
      // Extraer opciones especiales
      const { initialLoad, silent404, ...fetchOptions } = options;
      
      for (let i = 0; i < retries; i++) {
        try {
          // Crear AbortController para timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
          
          const finalFetchOptions = {
            ...fetchOptions,
            signal: controller.signal
          };
          
          const res = await fetch(url, finalFetchOptions);
          clearTimeout(timeoutId);
          
          if (res.ok) {
            return res;
          }
          
          // Manejo especial para 404 silencioso (para finalizar sesiones)
          if (res.status === 404 && silent404) {
            return res; // Retornar la respuesta 404 sin lanzar error
          }
          
          // Manejo especial para rate limiting (429)
          if (res.status === 429) {
            const retryAfter = res.headers.get('retry-after') || '60';
            const waitTime = parseInt(retryAfter) * 1000;
            console.warn(`Rate limited, esperando ${retryAfter} segundos...`);
            await new Promise(resolve => setTimeout(resolve, waitTime));
            continue; // Reintentar sin contar como fallo
          }
          
          if (i === retries - 1) {
            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          }
        } catch (error) {
          if (error.name === 'AbortError') {
            throw new Error(`Timeout: La solicitud tardó más de ${timeoutMs/1000} segundos`);
          }
          
          if (i === retries - 1) {
            throw error;
          }
          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
      }
    }

    async function fetchChildren(forceRefresh = false) {
      try {
        // Limpiar caché si es refresh forzado
        if (forceRefresh) {
          childrenCache = [];
        }
        
        const timestamp = Date.now();
        const res = await fetchWithRetry(api + '/children?t=' + timestamp);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        // Validar que la respuesta sea JSON válido
        let children;
        try {
          const text = await res.text();
          if (!text || text.trim() === '') {
            throw new Error('Respuesta vacía del servidor');
          }
          children = JSON.parse(text);
        } catch (parseError) {
          console.error('Error parsing JSON:', parseError);
          throw new Error('Respuesta inválida del servidor');
        }
        
        // Verificar que los datos son válidos
        if (!Array.isArray(children)) {
          console.error('Invalid children data format:', children);
          throw new Error('Invalid children data format');
        }
        
        childrenCache = children || [];
        
        // Renderizar inmediatamente
        renderChildrenList(childrenCache);
        updateChildSelect(childrenCache);
        
        return childrenCache;
      } catch (error) {
        console.error('Error fetching children:', error);
        showStatusMessage('Error al cargar la lista de niños', 'error');
        childrenCache = [];
        renderChildrenList([]);
        updateChildSelect([]);
        throw error; // Re-throw para que initializeApp pueda manejarlo
      }
    }


    async function fetchGames() {
      try {
        console.log('Fetching games from:', api + '/games');
        
        // LIMPIAR CACHÉ ANTES DE FETCH
        gamesCache = [];
        renderGamesList([]);
        updateGameSelect([]);
        
        const res = await fetchWithRetry(api + '/games');
        console.log('Games response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        // Validar que la respuesta sea JSON válido
        let games;
        try {
          const text = await res.text();
          if (!text || text.trim() === '') {
            throw new Error('Respuesta vacía del servidor');
          }
          games = JSON.parse(text);
        } catch (parseError) {
          console.error('Error parsing games JSON:', parseError);
          throw new Error('Respuesta inválida del servidor');
        }
        
        console.log('Games data received:', games, 'Length:', games ? games.length : 0);
        
        // VALIDAR Y ASIGNAR DATOS
        gamesCache = Array.isArray(games) ? games : [];
        
        // RENDERIZAR INMEDIATAMENTE
        renderGamesList(gamesCache);
        updateGameSelect(gamesCache);
        
        console.log('Games loaded successfully - Cache length:', gamesCache.length, 'Cache content:', gamesCache.map(g => `${g.id}:${g.name}`));
      } catch (error) {
        console.error('Error fetching games:', error);
        showStatusMessage('Error al cargar la lista de juegos', 'error');
        gamesCache = [];
        renderGamesList([]);
        updateGameSelect([]);
        throw error; // Re-throw para que initializeApp pueda manejarlo
      }
    }

    function renderChildrenList(children) {
      const list = document.getElementById('childrenList');
      console.log('renderChildrenList called with:', children ? children.length : 0, 'children');
      console.log('Children data:', children);
      
      if (!list) {
        console.error('childrenList element not found');
        return;
      }
      
      if (!children || children.length === 0) {
        console.log('No children to render, showing empty message');
        list.innerHTML = '<li class="list-item">No hay niños registrados</li>';
        return;
      }
      
      console.log('Rendering children list with', children.length, 'items');
        list.innerHTML = children.map(child => {
          const displayName = sanitizeHTML(child.displayName || child.name);
          const avatar = sanitizeHTML(child.avatar || child.name.charAt(0).toUpperCase());
          const fatherName = sanitizeHTML((child.father_name || child.fatherName) || '');
          const motherName = sanitizeHTML((child.mother_name || child.motherName) || '');
          const totalTime = child.totalTimePlayed || 0;
          
          // Información de padres mejorada para mejor diferenciación
          let parentsInfo = '';
          // Usar los nombres correctos del backend (con guión bajo)
          const backendFatherName = child.father_name || child.fatherName;
          const backendMotherName = child.mother_name || child.motherName;
          
          console.log(`Child ${child.name} parent data:`, { 
            fatherName: backendFatherName, 
            motherName: backendMotherName 
          });
          
          if (backendFatherName && backendMotherName) {
            parentsInfo = `<div class="child-parents" style="color: #555; font-size: 12px; font-style: italic; margin-top: 2px;">
              <i class="fas fa-users" style="margin-right: 4px;"></i>${backendFatherName} & ${backendMotherName}
            </div>`;
          } else if (backendFatherName) {
            parentsInfo = `<div class="child-parents" style="color: #555; font-size: 12px; font-style: italic; margin-top: 2px;">
              <i class="fas fa-male" style="margin-right: 4px;"></i>Papá: ${backendFatherName}
            </div>`;
          } else if (backendMotherName) {
            parentsInfo = `<div class="child-parents" style="color: #555; font-size: 12px; font-style: italic; margin-top: 2px;">
              <i class="fas fa-female" style="margin-right: 4px;"></i>Mamá: ${backendMotherName}
            </div>`;
          }

          return `<li class="list-item child-item">
            <div class="child-info" style="flex: 1; margin-right: 10px;">
              <span class="child-avatar">${avatar}</span>
              <div class="child-details">
                <div class="child-name">${displayName}</div>
                ${parentsInfo}
                <div class="child-time">${totalTime} min</div>
              </div>
            </div>
            <div class="delete-button-container" style="flex-shrink: 0;">
              <div class="button-group-small">
                <button onclick="editChild(${child.id})" class="btn-edit" title="Editar información">
                  <i class="fas fa-edit"></i>
                </button>
                <button onclick="deleteChild(${child.id})" class="btn-danger btn-small" title="Eliminar niño">
            <i class="fas fa-trash"></i>
          </button>
              </div>
            </div>
          </li>`;
        }).join('');
        
        console.log('Children list rendered with', children.length, 'items');
        console.log('List HTML length:', list.innerHTML.length);
    }

    function renderGamesList(games) {
      const list = document.getElementById('gamesList');
      if (!list) return;
      
      if (!games || games.length === 0) {
        list.innerHTML = '<li class="list-item">No hay juegos registrados</li>';
        return;
      }
      list.innerHTML = games.map(game => 
        `<li class="list-item">
          <div style="flex: 1; margin-right: 10px;">
          <span><i class="fas fa-dice"></i> ${sanitizeHTML(game.name)}</span>
          </div>
          <div class="delete-button-container" style="flex-shrink: 0;">
            <button onclick="deleteGame(${game.id})" class="btn-danger btn-small">
            <i class="fas fa-trash"></i>
          </button>
          </div>
        </li>`
      ).join('');
    }

    function updateChildSelect(children) {
      const select = document.getElementById('selectedChildId');
      if (!select) return;
      
      select.innerHTML = '<option value="">Seleccione un niño</option>' +
        (children || []).map(child => {
          const displayName = sanitizeHTML(child.displayName || child.name);
          
          // Agregar información de padres si existe para diferenciar
          let parentInfo = '';
          const fatherName = child.father_name || child.fatherName;
          const motherName = child.mother_name || child.motherName;
          if (fatherName || motherName) {
            const father = sanitizeHTML(fatherName || '');
            const mother = sanitizeHTML(motherName || '');
            const separator = father && mother ? ', ' : '';
            parentInfo = ` (${father}${separator}${mother})`;
          }
          
          return `<option value="${child.id}">${displayName}${parentInfo}</option>`;
        }).join('');
    }

    function updateGameSelect(games) {
      const select = document.getElementById('gameSelect');
      if (!select) {
        console.warn('Game select element not found');
        return;
      }
      
      console.log('Updating game select with games:', games ? games.length : 0, 'games');
      
      if (!games || !Array.isArray(games) || games.length === 0) {
        console.warn('No games provided to updateGameSelect');
        select.innerHTML = '<option value="">Seleccione un juego</option>';
        return;
      }
      
      select.innerHTML = '<option value="">Seleccione un juego</option>' +
        games.map(game => `<option value="${game.id}">${sanitizeHTML(game.name)}</option>`).join('');
        
      console.log('Game select updated with', games.length, 'options');
    }

    // Función para forzar la recarga de juegos
    async function forceRefreshGames() {
      console.log('🔄 Forzando recarga de juegos...');
      showStatusMessage('Recargando lista de juegos...', 'info');
      
      try {
        // Limpiar caché completamente
        gamesCache = [];
        updateGameSelect([]);
        
        // Hacer fetch directo
        const response = await fetch(api + '/games');
        console.log('Force refresh - Response status:', response.status);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const games = await response.json();
        console.log('Force refresh - Games received:', games);
        
        if (Array.isArray(games)) {
          gamesCache = games;
          updateGameSelect(gamesCache);
          renderGamesList(gamesCache);
          
          console.log('✅ Juegos recargados exitosamente:', gamesCache.length);
          showStatusMessage(`✅ ${gamesCache.length} juegos cargados`, 'success');
        } else {
          throw new Error('Formato de datos inválido');
        }
        
      } catch (error) {
        console.error('❌ Error forzando recarga de juegos:', error);
        showStatusMessage('❌ Error al recargar juegos', 'error');
        gamesCache = [];
        updateGameSelect([]);
      }
    }

    // Funciones de sesiones activas ROBUSTAS
    async function fetchActiveSessions() {
      try {
        console.log('Fetching active sessions from:', api + '/sessions/active');
        const res = await fetchWithRetry(api + '/sessions/active');
        console.log('Active sessions response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const newActiveSessionsData = await res.json() || [];
        console.log('Active sessions data received:', newActiveSessionsData);
        
        // Actualizar siempre para mostrar cambios
        activeSessionsData = newActiveSessionsData;
        console.log('Active sessions data updated:', activeSessionsData);
        console.log('Children cache length:', childrenCache.length);
        console.log('Games cache length:', gamesCache.length);
        renderActiveSessions();
        console.log('Active sessions rendered:', activeSessionsData.length, 'sessions');
        
      } catch (error) {
        console.error('Error fetching active sessions:', error);
        
        // NO resetear las sesiones activas en caso de error
        console.warn('Failed to fetch active sessions, keeping current data');
        
        // Solo actualizar timers con datos existentes
        if (activeSessionsData.length > 0) {
          updateExistingTimers();
        } else {
          // Si no hay datos, mostrar mensaje de no sesiones activas
          const list = document.getElementById('activeSessions');
          if (list) {
            list.innerHTML = '<li class="list-item">No hay sesiones activas</li>';
          }
        }
      }
    }


    function renderActiveSessions() {
      const list = document.getElementById('activeSessions');
      if (!list) return;
      
      // Limitar a 50 sesiones visibles para mejor rendimiento
      const visibleSessions = activeSessionsData.slice(0, 50);
      const hiddenCount = activeSessionsData.length - 50;
      
      if (activeSessionsData.length === 0) {
        if (list.innerHTML !== '<li class="list-item">No hay sesiones activas</li>') {
          list.innerHTML = '<li class="list-item">No hay sesiones activas</li>';
        }
        return;
      }
      
      // Solo re-renderizar si la estructura cambió
      const sessionHash = visibleSessions.map(s => `${s.id}-${s.childId}-${s.gameId}-${s.duration}`).join('|');
      
      if (list.dataset.sessionHash !== sessionHash) {
        let html = visibleSessions.map(s => generateSingleSessionHTML(s)).join('');
        
        if (hiddenCount > 0) {
          html += `<li class="list-item info"><i class="fas fa-info-circle"></i> ... y ${hiddenCount} sesiones más</li>`;
        }
        
        list.innerHTML = html;
        list.dataset.sessionHash = sessionHash;
        startTimers();
        console.log('Active sessions structure updated:', visibleSessions.length, 'visible,', hiddenCount, 'hidden');
      }
    }
    
    function generateSingleSessionHTML(s) {
      const child = childrenCache.find(c => c.id === s.childId);
      const game = gamesCache.find(g => g.id === s.gameId);
      
      // Si no encontramos el niño o juego, solo mostrar datos desconocidos
      if (!child || !game) {
        console.warn('Missing child or game data for session:', s.id);
      }
      
      // Usar displayName si existe y no es null/undefined, sino el nombre original
      const childDisplayName = child ? (child.displayName && child.displayName !== 'null' ? child.displayName : child.name) : 'Niño desconocido';
      const childAvatar = child ? (child.avatar || child.name.charAt(0).toUpperCase()) : '?';
      const gameName = game ? game.name : 'Juego desconocido';
      
      // Información de padres para diferenciación
      let parentsInfo = '';
      if (child) {
        const fatherName = child.father_name || child.fatherName;
        const motherName = child.mother_name || child.motherName;
        
        parentsInfo = getParentsInfo(child, 'html');
      }
      
      return '<li class="list-item active" data-session-id="' + s.id + '" id="session-' + s.id + '">' +
        '<div class="session-info">' +
          '<strong><span class="child-avatar-small">' + childAvatar + '</span> <i class="fas fa-child"></i> ' + childDisplayName + '</strong>' + parentsInfo + '<br>' +
          '<small><i class="fas fa-gamepad"></i> ' + gameName + '</small><br>' +
          '<small><i class="fas fa-clock"></i> Duración: ' + s.duration + ' min</small>' +
        '</div>' +
        '<div class="session-controls">' +
          '<div class="timer" id="timer-' + s.id + '">Calculando...</div>' +
          '<div class="button-group">' +
            '<button class="btn-danger" onclick="endSession(' + s.id + ')" style="padding: 4px 8px; font-size: 11px; margin-right: 3px;">' +
              '<i class="fas fa-stop"></i> FIN' +
            '</button>' +
            '<button class="extend-time" onclick="showExtendModal(' + s.id + ', \`' + childDisplayName + '\`)" style="padding: 4px 8px; font-size: 11px;">' +
              '<i class="fas fa-plus"></i> +5' +
            '</button>' +
          '</div>' +
        '</div>' +
      '</li>';
    }
    
    function generateActiveSessionsHTML() {
      if (!activeSessionsData || activeSessionsData.length === 0) {
        return '<li class="list-item">No hay sesiones activas</li>';
      }
      
      return activeSessionsData.map(s => {
        const child = childrenCache.find(c => c.id === s.childId);
        const game = gamesCache.find(g => g.id === s.gameId);
        
        // Si no encontramos el niño o juego, solo mostrar datos desconocidos
        if (!child || !game) {
          console.warn('Missing child or game data for session:', s.id);
        }
        
        // Usar displayName si existe y no es null/undefined, sino el nombre original
        const childDisplayName = child ? (child.displayName && child.displayName !== 'null' ? child.displayName : child.name) : 'Niño desconocido';
        const childAvatar = child ? (child.avatar || child.name.charAt(0).toUpperCase()) : '?';
        const gameName = game ? game.name : 'Juego desconocido';
        
        // Información de padres para diferenciación
        let parentsInfo = getParentsInfo(child, 'html');
        
        return `<li class="list-item active" data-session-id="${s.id}" id="session-${s.id}">
          <div class="session-info">
            <strong><span class="child-avatar-small">${childAvatar}</span> <i class="fas fa-child"></i> ${childDisplayName}</strong>${parentsInfo}<br>
            <small><i class="fas fa-gamepad"></i> ${gameName}</small><br>
            <small><i class="fas fa-clock"></i> Duración: ${s.duration} min</small>
          </div>
          <div class="session-controls">
            <div class="timer" id="timer-${s.id}">Calculando...</div>
            <div class="button-group">
              <button class="btn-danger" onclick="endSession(${s.id})" style="padding: 4px 8px; font-size: 11px; margin-right: 3px;">
                <i class="fas fa-stop"></i> FIN
              </button>
              <button class="extend-time" onclick="showExtendModal(${s.id}, \`${childDisplayName}\`)" style="padding: 4px 8px; font-size: 11px;">
                <i class="fas fa-plus"></i> +5
              </button>
            </div>
          </div>
        </li>`;
      }).join('');
    }
    
    function updateExistingTimers() {
      // Solo actualizar timers existentes sin recrear el DOM
      const list = document.getElementById('activeSessions');
      if (!list) return;
      
      if (!activeSessionsData || activeSessionsData.length === 0) return;
      
      activeSessionsData.forEach(s => {
        const sessionElement = list.querySelector(`[data-session-id="${s.id}"]`);
        const timerElement = sessionElement ? sessionElement.querySelector('.timer') : null;
        
        if (!sessionElement || !timerElement) return;
        
          // Actualizar directamente el contenido del timer sin recrear el elemento
          const now = Date.now();
        
        // Buscar startTime en múltiples formatos posibles
        let startTime = s.start || s.startTime;
        
        // Convertir string a timestamp si es necesario
        if (typeof startTime === 'string') {
          startTime = new Date(startTime).getTime();
        }
        
        // Si no hay startTime válido, usar createdAt como fallback
        if (!startTime || isNaN(startTime)) {
          startTime = s.created_at ? new Date(s.created_at).getTime() : now;
        }
        
        // Asegurar que startTime es un número válido
        if (isNaN(startTime) || startTime <= 0) {
          startTime = now;
        }
        
        const elapsed = Math.floor((now - startTime) / 1000);
        const totalDurationSeconds = (s.duration || 1) * 60;
        const remaining = Math.max(0, totalDurationSeconds - elapsed);
        
        // Validar que los cálculos son válidos
        if (isNaN(elapsed) || isNaN(remaining) || isNaN(totalDurationSeconds)) {
          console.error('Invalid timer calculation:', { elapsed, remaining, totalDurationSeconds, startTime, now, duration: s.duration });
          timerElement.innerHTML = '<strong>Calculando...</strong>';
          timerElement.className = 'timer';
          return;
        }
          
          if (remaining <= 0) {
          timerElement.innerHTML = '<strong>Tiempo agotado</strong>';
            timerElement.className = 'timer danger';
          } else {
            const h = Math.floor(remaining / 3600);
            const m = Math.floor((remaining % 3600) / 60);
            const s = remaining % 60;
            const elapsedMin = Math.floor(elapsed / 60);
            const elapsedSec = elapsed % 60;
            
          timerElement.innerHTML = 'Restante: ' + h + ':' + m.toString().padStart(2, '0') + ':' + s.toString().padStart(2, '0') + '<br><small>Transcurrido: ' + elapsedMin + ':' + elapsedSec.toString().padStart(2, '0') + '</small>';
            
            // Cambiar color según tiempo restante
            if (remaining <= 60) {
              timerElement.className = 'timer danger';
            } else if (remaining <= 300) {
              timerElement.className = 'timer warning';
            } else {
              timerElement.className = 'timer';
          }
        }
      });
    }

    function startTimers() {
      // Limpiar timers de sesiones que ya no existen
      const currentSessionIds = activeSessionsData.map(s => s.id);
      timerIntervals.forEach((interval, sessionId) => {
        if (!currentSessionIds.includes(sessionId)) {
          clearInterval(interval);
          timerIntervals.delete(sessionId);
        }
      });

      // Crear timers solo para sesiones nuevas
      activeSessionsData.forEach(s => {
        if (!timerIntervals.has(s.id)) {
          let startTime = s.start || s.startTime || Date.now();
          if (typeof startTime === 'string') {
            startTime = new Date(startTime).getTime();
          }
          updateTimer(s.id, startTime, s.duration);
          const interval = setInterval(() => updateTimer(s.id, startTime, s.duration), 1000);
          timerIntervals.set(s.id, interval);
        }
      });
    }

    function updateTimer(sessionId, startTime, duration) {
      const timerSpan = document.getElementById(`timer-${sessionId}`);
      if (!timerSpan) return;
      
      // Usar datos actualizados de activeSessionsData si están disponibles
      const sessionData = activeSessionsData.find(s => s.id === sessionId);
      
      // Convertir timestamp de string a número si es necesario
      let currentStartTime = sessionData ? (sessionData.start || sessionData.startTime || startTime) : startTime;
      if (typeof currentStartTime === 'string') {
        currentStartTime = new Date(currentStartTime).getTime();
      }
      
      const currentDuration = sessionData ? sessionData.duration : duration;
      
      // VALIDACIÓN CRÍTICA DE DURACIÓN
      if (!currentDuration || typeof currentDuration !== 'number' || currentDuration <= 0) {
        console.error('Invalid duration in updateTimer:', { sessionId, currentDuration, sessionData });
        timerSpan.textContent = '⏱️ Duración inválida';
        return;
      }
      
      const now = Date.now();
      
      // Validar que currentStartTime es un número válido
      if (isNaN(currentStartTime) || currentStartTime <= 0) {
        console.error('Invalid startTime in updateTimer:', { sessionId, currentStartTime, sessionData });
        timerSpan.textContent = '⏱️ Calculando...';
        return;
      }
      
      const elapsedSeconds = Math.floor((now - currentStartTime) / 1000);
      const totalSeconds = Math.floor(currentDuration * 60);
      const remainingSeconds = totalSeconds - elapsedSeconds;
      
      // VALIDACIÓN CRÍTICA DE CÁLCULOS
      if (isNaN(elapsedSeconds) || isNaN(totalSeconds) || isNaN(remainingSeconds)) {
        console.error('Invalid timer calculations:', { sessionId, elapsedSeconds, totalSeconds, remainingSeconds });
        timerSpan.textContent = '⏱️ Error de cálculo';
        return;
      }
      
      const h = String(Math.floor(remainingSeconds / 3600)).padStart(2, '0');
      const m = String(Math.floor((remainingSeconds % 3600) / 60)).padStart(2, '0');
      const s = String(remainingSeconds % 60).padStart(2, '0');
      
      // Calcular tiempo transcurrido para mostrar también
      const elapsedMinutes = Math.floor(elapsedSeconds / 60);
      const elapsedSecs = elapsedSeconds % 60;
      
      // Actualizar clases según el tiempo restante
      timerSpan.className = 'timer';
      if (remainingSeconds <= 0) {
        timerSpan.textContent = '⏰ ¡Tiempo terminado!';
        timerSpan.classList.add('danger');
        if (!timerSpan.classList.contains('alerted')) {
          timerSpan.classList.add('alerted');
          const session = activeSessionsData.find(s => s.id === sessionId);
          const child = childrenCache.find(c => c.id === session.childId);
          
          // 🔊 CRÍTICO: Activar notificaciones de voz cuando se acaba el tiempo
          if (child) {
            let childName = child.displayName || child.name;
            let parentsInfo = '';
            
            // Construir información de padres de manera compatible con la función
            parentsInfo = getParentsInfo(child, 'simple');
            
            console.log('🔊 Disparando alerta de voz para:', childName, parentsInfo);
            showConsolidatedTimeAlert(childName, parentsInfo);
          }
          
          showCustomModal(`¡Se acabó el tiempo para ${child ? child.name : 'este niño'}!`);
          endSession(sessionId);
        }
      } else if (remainingSeconds <= 60) {
        timerSpan.innerHTML = '<strong>Restante:</strong> ' + sanitizeHTML(m) + ':' + sanitizeHTML(s) + '<br><small>Transcurrido: ' + sanitizeHTML(String(elapsedMinutes)) + ':' + sanitizeHTML(String(elapsedSecs).padStart(2, '0')) + '</small>';
        timerSpan.classList.add('warning');
        // Alerta cuando quedan 30 segundos
        if (remainingSeconds <= 30 && !timerSpan.classList.contains('alerted-30')) {
          timerSpan.classList.add('alerted-30');
          const session = activeSessionsData.find(s => s.id === sessionId);
          const child = childrenCache.find(c => c.id === session.childId);
          
          let childDisplayName = child ? (child.displayName || child.name) : 'este niño';
          let parentsText = getParentsInfo(child, 'simple');
          
          // SOLO ALERTAR UNA VEZ A LOS 30 SEGUNDOS - NO CADA SEGUNDO
          if (remainingSeconds === 30) {
            console.log(`🚨 ALERTA DE 30 SEGUNDOS: ${childDisplayName}${parentsText}`);
            showStatusMessage(`¡Atención! A ${childDisplayName}${parentsText} le quedan solo 30 segundos`, 'warning', sessionId, { voiceOnly: false });
          }
        }
      } else {
        timerSpan.innerHTML = '<strong>Restante:</strong> ' + sanitizeHTML(h) + ':' + sanitizeHTML(m) + ':' + sanitizeHTML(s) + '<br><small>Transcurrido: ' + sanitizeHTML(String(elapsedMinutes)) + ':' + sanitizeHTML(String(elapsedSecs).padStart(2, '0')) + '</small>';
      }
    }

    async function fetchSessionHistory() {
      try {
        console.log('Fetching session history from:', api + '/sessions');
        const res = await fetchWithRetry(api + '/sessions');
        console.log('Session history response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const sessions = await res.json() || [];
        console.log('Session history data received:', sessions);
        
        renderSessionHistory(sessions);
        console.log('Session history loaded successfully:', sessions);
      } catch (error) {
        console.error('Error fetching session history:', error);
        
        // En caso de error, mostrar mensaje de no historial
        const list = document.getElementById('sessionHistory');
        if (list) {
          list.innerHTML = '<li class="list-item">No hay sesiones registradas</li>';
        }
        
        console.warn('Failed to fetch session history, showing empty state');
      }
    }

    function renderSessionHistory(sessions) {
      const list = document.getElementById('sessionHistory');
      if (!list) return;
      
      if (!sessions || sessions.length === 0) {
        list.innerHTML = '<div class="history-item" style="text-align: center; padding: 20px; color: #666;"><i class="fas fa-history" style="font-size: 24px; margin-bottom: 8px; display: block;"></i>No hay sesiones registradas</div>';
        return;
      }
      
      // Asegurar que tenemos datos de niños y juegos antes de renderizar
      if (childrenCache.length === 0 || gamesCache.length === 0) {
        console.log('Missing cache data, refreshing...');
        fetchChildren().then(() => fetchGames()).then(() => {
          // Re-renderizar con datos actualizados
          renderSessionHistory(sessions);
        });
        return;
      }
      
      // Mostrar las últimas 5 sesiones por defecto, resto colapsado
      const recentSessions = sessions.slice(0, 5);
      const hiddenSessions = sessions.slice(5);
      
      let html = '';
      
      // Botón para expandir/colapsar si hay más de 5 sesiones - RESTAURADO
      if (sessions.length > 5) {
        html += `
        <button class="history-toggle" onclick="toggleHistoryView()" id="historyToggle">
          <i class="fas fa-chevron-down"></i>
          Ver ${hiddenSessions.length} sesiones anteriores
        </button>`;
      }
      
      html += recentSessions.map(s => {
        const child = childrenCache.find(c => c.id === s.childId);
        const game = gamesCache.find(g => g.id === s.gameId);
        
        // Usar nombres reales, si no se encuentran, mostrar "Desconocido"
        const childName = child ? (child.displayName && child.displayName !== 'null' ? child.displayName : child.name) : 'Niño desconocido';
        const gameName = game ? game.name : 'Juego desconocido';
        
        // Información de padres para diferenciación
        let parentsInfo = getParentsInfo(child, 'history');
        
        const startTimeValue = s.startTime || s.start || Date.now();
        const startTime = new Date(startTimeValue);
        const timeStr = startTime.toLocaleTimeString('es-ES', {
          hour: '2-digit',
          minute: '2-digit'
        });
        const dateStr = startTime.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit'
        });
        
        let statusClass, iconClass, durationText, durationClass;
        
        if (s.endTime || s.end) {
          // Sesión finalizada
          const endTimeValue = s.endTime || s.end;
          const endTime = new Date(endTimeValue);
          
          // Para sesiones con endTime, siempre mostrar FINALIZADO (fue finalizada manualmente)
          // No importa la duración - si tiene endTime, fue por botón FIN
          durationText = 'FINALIZADO'; // Usuario presionó FIN
          statusClass = 'completed';
          iconClass = 'completed';
          durationClass = 'completed';
        } else {
          // Sesión en curso - usar la misma lógica que renderActiveSessions
          const currentTime = Date.now();
          
          // Verificar que startTimeValue sea válido
          if (isNaN(startTime.getTime())) {
            console.warn('Invalid start time for session:', s.id, 'start:', startTimeValue);
            durationText = 'FINALIZADO'; // Sesión antigua con datos corruptos
            statusClass = 'completed';
            iconClass = 'completed';
            durationClass = 'completed';
          } else {
            const elapsedSeconds = Math.floor((currentTime - startTime.getTime()) / 1000);
            const totalSeconds = (s.duration || 15) * 60;
            const remainingSeconds = Math.max(0, totalSeconds - elapsedSeconds);
            
            // Convertir a minutos para mostrar
            const elapsedMinutes = Math.floor(elapsedSeconds / 60);
            const totalMinutes = s.duration || 15;
          
            if (remainingSeconds <= 0) {
              statusClass = 'expired';
              iconClass = 'expired';
              durationText = 'Agotado';
              durationClass = 'expired';
            } else {
              statusClass = 'active';
              iconClass = 'active';
              durationText = `${elapsedMinutes}/${totalMinutes}min`;
              durationClass = 'active';
            }
          }
        }
        
        return `
        <div class="history-item ${statusClass}">
          <div class="history-icon ${iconClass}">
            <i class="fas fa-${s.endTime || s.end ? 'check-circle' : (statusClass === 'expired' ? 'exclamation-triangle' : 'play-circle')}"></i>
          </div>
          <div class="history-content">
            <div class="history-title">
              <i class="fas fa-child"></i>
              ${childName}
            </div>
            ${parentsInfo}
            <div class="history-subtitle">
              <i class="fas fa-gamepad"></i>
              ${gameName}
            </div>
          </div>
          <div class="history-meta">
            <div class="history-duration ${durationClass}">
              ${durationText}
            </div>
            <div class="history-time">
              ${dateStr} ${timeStr}
            </div>
          </div>
        </div>`;
      }).join('');
      
      // Agregar sesiones ocultas si las hay
      if (hiddenSessions.length > 0) {
        html += `<div id="hiddenSessions" class="history-hidden">`;
        html += hiddenSessions.map(s => {
          const child = childrenCache.find(c => c.id === s.childId);
          const game = gamesCache.find(g => g.id === s.gameId);
          
          const childName = child ? (child.displayName && child.displayName !== 'null' ? child.displayName : child.name) : 'Niño desconocido';
          const gameName = game ? game.name : 'Juego desconocido';
          
          // Información de padres para diferenciación
          let parentsInfo = getParentsInfo(child, 'history');
          
          const startTime = new Date(s.start);
          const timeStr = startTime.toLocaleTimeString('es-ES', {
            hour: '2-digit',
            minute: '2-digit'
          });
          const dateStr = startTime.toLocaleDateString('es-ES', {
            day: '2-digit',
            month: '2-digit'
          });
          
          let statusClass, iconClass, durationText, durationClass;
          
          if (s.end) {
            const duration = Math.round((s.end - s.start) / 60000);
            statusClass = 'completed';
            iconClass = 'completed';
            durationText = 'FINALIZADO'; // Siempre FINALIZADO para sesiones con end
            durationClass = 'completed';
          } else {
            const currentTime = Date.now();
            const elapsedMinutes = Math.round((currentTime - s.start) / 60000);
            const totalMinutes = s.duration || 15;
            const remainingMinutes = Math.max(0, totalMinutes - elapsedMinutes);
            
            if (remainingMinutes <= 0) {
              statusClass = 'expired';
              iconClass = 'expired';
              durationText = 'Agotado';
              durationClass = 'expired';
            } else {
              statusClass = 'active';
              iconClass = 'active';
              durationText = `${elapsedMinutes}/${totalMinutes}min`;
              durationClass = 'active';
            }
          }
          
          return `
          <div class="history-item ${statusClass}">
            <div class="history-icon ${iconClass}">
              <i class="fas fa-${s.end ? 'check' : (statusClass === 'expired' ? 'exclamation' : 'play')}"></i>
            </div>
            <div class="history-content">
              <div class="history-title">
                <i class="fas fa-child"></i>
                ${childName}
              </div>
              ${parentsInfo}
              <div class="history-subtitle">
                <i class="fas fa-gamepad"></i>
                ${gameName}
              </div>
            </div>
            <div class="history-meta">
              <div class="history-duration ${durationClass}">
                ${durationText}
              </div>
              <div class="history-time">
                ${dateStr} ${timeStr}
              </div>
            </div>
          </div>`;
        }).join('');
        html += `</div>`;
      }
      
      list.innerHTML = html;
    }

    // Función para alternar vista del historial
    function toggleHistoryView() {
      const hiddenSessions = document.getElementById('hiddenSessions');
      const toggleBtn = document.getElementById('historyToggle');
      
      if (hiddenSessions && toggleBtn) {
        // Obtener el número de sesiones ocultas del texto del botón original
        const hiddenCount = hiddenSessions.children.length;
        
        if (hiddenSessions.classList.contains('history-hidden')) {
          // Expandir
          hiddenSessions.classList.remove('history-hidden');
          toggleBtn.innerHTML = `<i class="fas fa-chevron-up"></i> Ocultar ${hiddenCount} sesiones anteriores`;
          toggleBtn.classList.add('expanded');
        } else {
          // Colapsar
          hiddenSessions.classList.add('history-hidden');
          toggleBtn.innerHTML = `<i class="fas fa-chevron-down"></i> Ver ${hiddenCount} sesiones anteriores`;
          toggleBtn.classList.remove('expanded');
        }
      }
    }

    // Funciones principales ROBUSTAS
    async function addChild() {
      try {
        checkRateLimit('addChild');
      } catch (error) {
        showStatusMessage(error.message, 'error');
        return;
      }
      
      const name = document.getElementById('childName').value;
      const nickname = document.getElementById('childNickname').value;
      const fatherName = document.getElementById('fatherName').value;
      const motherName = document.getElementById('motherName').value;
      
      // Validar datos y declarar variables en el scope correcto
      let validatedName, validatedNickname, validatedFatherName, validatedMotherName;
      
      // Validación simple y directa
      if (!name || name.trim().length < 2) {
        showStatusMessage('El nombre del niño debe tener al menos 2 caracteres', 'error');
        return;
      }
      
      validatedName = name.trim();
      validatedNickname = nickname ? nickname.trim() : null;
      validatedFatherName = fatherName ? fatherName.trim() : null;
      validatedMotherName = motherName ? motherName.trim() : null;
      
      showLoading('addChildBtn', true);
      try {
        const requestData = { 
          name: validatedName,
          nickname: validatedNickname,
          fatherName: validatedFatherName,
          motherName: validatedMotherName
        };
        
        // console.log('Adding child:', requestData);
        
        const res = await fetchWithRetry(api + '/children', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestData)
        });
        
        // console.log('Response status:', res.status);
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          console.log('Error response:', errorData);
          
          // Manejar duplicados con sugerencias
          if (errorData.duplicate && errorData.suggestion) {
            showStatusMessage('⚠️ ' + errorData.suggestion, 'warning');
            return;
          }
          
          throw new Error(errorData.error || 'Error al agregar niño');
        }
        
        const responseData = await res.json();
        // console.log('Success response:', responseData);
        
        // Limpiar formulario
        document.getElementById('childName').value = '';
        document.getElementById('childNickname').value = '';
        document.getElementById('fatherName').value = '';
        document.getElementById('motherName').value = '';
        
        // Limpiar caché y recargar datos frescos
        
        // Limpiar caché completamente
        childrenCache = [];
        console.log('Cache cleared, fetching fresh data...');
        
        // Recargar datos frescos del backend con cache busting
        try {
          const timestamp = Date.now();
          const freshRes = await fetchWithRetry(api + '/children?t=' + timestamp);
          const freshChildren = await freshRes.json();
          
          console.log('Fresh children data received:', freshChildren);
          childrenCache = freshChildren || [];
          
          // Renderizar inmediatamente con datos frescos
          renderChildrenList(childrenCache);
          updateChildSelect(childrenCache);
          
          console.log('Children list updated with', childrenCache.length, 'items');
        } catch (error) {
          console.error('Error reloading fresh data:', error);
          // NO recargar página - mantener estado del usuario
          showStatusMessage('Error al recargar datos. Por favor, intente nuevamente.', 'error');
          // Intentar recargar datos en segundo plano después de 5 segundos
          setTimeout(() => {
            console.log('Reintentando recarga de datos en segundo plano...');
            fetchChildren(true).catch(() => {
              console.log('Recarga en segundo plano falló, continuando con datos actuales');
            });
          }, 1000);
        }
        
        showStatusMessage('Niño agregado exitosamente', 'success', null, { voiceOnly: false });
      } catch (error) {
        console.error('Error adding child:', error);
            showStatusMessage('Error al agregar niño: ' + error.message, 'error');
      } finally {
        showLoading('addChildBtn', false);
      }
    }

    async function addGame() {
      const name = document.getElementById('gameName').value.trim();
      if (!validateName(name, 'nombre del juego')) return;
      
      showLoading('addGameBtn', true);
      try {
        const res = await fetchWithRetry(api + '/games', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al agregar juego');
        }
        
        document.getElementById('gameName').value = '';
        
        // Actualizar juegos primero para mostrar inmediatamente
        await fetchGames();
        
        // Luego actualizar el resto de datos
        await Promise.all([
          fetchChildren(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        
        showStatusMessage('Juego agregado exitosamente', 'success', null, { voiceOnly: false });
      } catch (error) {
        console.error('Error adding game:', error);
        showStatusMessage('Error al agregar juego: ' + error.message, 'error');
      } finally {
        showLoading('addGameBtn', false);
      }
    }


    async function startSession() {
      console.log('🚀 INICIANDO SESIÓN - DIAGNÓSTICO COMPLETO');
      console.log('==========================================');
      
      // Prevenir doble-clic
      if (AppState?.isStartingSession) {
        console.log('⚠️ Sesión ya en progreso, bloqueando doble-clic');
        showStatusMessage('⏳ Iniciando sesión, por favor espera...', 'warning');
        return;
      }
      
      try {
        AppState.isStartingSession = true;
        console.log('✅ Estado de sesión bloqueado');
        
        const durationInput = document.getElementById('durationInput').value;
        console.log('⏱️ Duración ingresada:', durationInput);
        
        // Validar duración primero
        if (!durationInput || durationInput.trim() === '') {
          console.log('❌ Duración vacía o inválida');
          showStatusMessage('Por favor ingrese un tiempo válido', 'error', null, { voiceOnly: false });
          AppState.isStartingSession = false;
          return;
        }
        
        const duration = validateDuration(durationInput);
        console.log('✅ Duración validada:', duration);
        
        // OBTENER VALORES INMEDIATAMENTE - NO ESPERAR
        const selectedChildId = document.getElementById('selectedChildId').value;
        const gameId = document.getElementById('gameSelect').value;
        
        console.log('👶 Niño seleccionado:', selectedChildId);
        console.log('🎮 Juego seleccionado:', gameId);
        
        // VALIDAR INMEDIATAMENTE - NO HACER NADA MÁS SI FALTA ALGO
        if (!selectedChildId) {
          console.log('❌ No se seleccionó niño');
          showStatusMessage('Por favor seleccione un niño', 'error', null, { voiceOnly: false });
          AppState.isStartingSession = false;
          return;
        }
        
        if (!gameId) {
          console.log('❌ No se seleccionó juego');
          showStatusMessage('Por favor seleccione un juego', 'error', null, { voiceOnly: false });
          AppState.isStartingSession = false;
          return;
        }
      
        console.log('Starting session:', { selectedChildId, gameId, duration, originalInput: durationInput });
        
        console.log('🔍 Validando sesión...');
        if (!validateSession(selectedChildId, gameId, duration)) {
          console.log('❌ Validación de sesión falló');
          AppState.isStartingSession = false;
          return;
        }
        console.log('✅ Validación de sesión exitosa');
        
        // Verificar que el niño y juego existen en el caché
        console.log('🔍 Verificando datos en caché...');
        console.log('- childrenCache.length:', childrenCache.length);
        console.log('- gamesCache.length:', gamesCache.length);
        
        const child = childrenCache.find(c => c.id == selectedChildId);
      const game = gamesCache.find(g => g.id == gameId);
        
        console.log('👶 Niño encontrado en caché:', child ? 'SÍ' : 'NO');
        console.log('🎮 Juego encontrado en caché:', game ? 'SÍ' : 'NO');
      
      if (!child) {
          console.error('❌ Niño no encontrado en caché:', selectedChildId);
          console.error('👶 Niños disponibles:', childrenCache.map(c => `${c.id}:${c.name}`));
          showStatusMessage('Error: Niño no encontrado. Por favor selecciona un niño válido.', 'error', null, { voiceOnly: false });
          document.getElementById('selectedChildId').value = '';
          AppState.isStartingSession = false;
          return;
      }
      
      if (!game) {
          console.error('❌ Juego no encontrado en caché:', gameId);
          console.error('🎮 Juegos disponibles:', gamesCache.map(g => `${g.id}:${g.name}`));
          showStatusMessage('Error: Juego no encontrado. Por favor selecciona un juego válido.', 'error', null, { voiceOnly: false });
          document.getElementById('gameSelect').value = '';
          AppState.isStartingSession = false;
          return;
      }
        
        console.log('Validación exitosa - Iniciando sesión:', {
          childId: selectedChildId,
          gameId: gameId,
          duration: duration,
          childName: child.name,
          gameName: game.name
        });
      
      showLoading('startBtn', true);
        
        const requestBody = { 
          childId: validateId(selectedChildId, 'ID del niño'), 
          gameId: validateId(gameId, 'ID del juego'), 
          duration: duration 
        };
        
        console.log('Request body:', requestBody);
        
        const res = await fetchWithRetry(api + '/sessions/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });
        
        console.log('Response status:', res.status);
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al iniciar sesión');
        }
        
        const result = await res.json();
        console.log('Session started:', result);
        
        // Actualizar datos inmediatamente después de iniciar sesión
        await Promise.all([
          fetchActiveSessions(),
          fetchSessionHistory(),
          fetchChildren() // Asegurar datos actualizados
        ]);
        showStatusMessage('Sesión iniciada exitosamente', 'success', null, { voiceOnly: false });
        
        // Limpiar alertas de sesiones anteriores
        clearAllSessionAlerts();
        
      } catch (error) {
        console.error('Error starting session:', error);
        showStatusMessage('Error al iniciar sesión: ' + error.message, 'error');
      } finally {
        showLoading('startBtn', false);
        AppState.isStartingSession = false; // Liberar el lock
      }
    }

    async function endSession(sessionId) {
      try {
        console.log('🚨 Ending session:', sessionId);
        
        // Verificar que la sesión aún existe antes de intentar finalizarla
        const sessionExists = activeSessionsData.find(s => s.id === sessionId);
        if (!sessionExists) {
          console.log('🚨 Session already ended or not found locally:', sessionId);
          // Limpiar timer de todas formas por si acaso
          if (timerIntervals.has(sessionId)) {
            clearInterval(timerIntervals.get(sessionId));
            timerIntervals.delete(sessionId);
          }
          // Actualizar datos para sincronizar
          await fetchActiveSessions();
          return; // No mostrar error si la sesión ya no existe
        }
        
        const res = await fetchWithRetry(api + '/sessions/' + sessionId + '/end', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          silent404: true // Suprimir errores 404 en consola para finalizar sesiones
        });
        
        console.log('🚨 End session response status:', res.status);
        
        if (!res.ok) {
          // Si es 404, probablemente la sesión ya fue finalizada
          if (res.status === 404) {
            console.log('🚨 Session not found on server (404) - likely already ended:', sessionId);
            // Limpiar timer local
            if (timerIntervals.has(sessionId)) {
              clearInterval(timerIntervals.get(sessionId));
              timerIntervals.delete(sessionId);
            }
            // Actualizar datos para sincronizar
            await fetchActiveSessions();
            return; // No mostrar error para 404
          }
          
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al finalizar sesión');
        }
        
        console.log('✅ Session ended successfully');
        
        // Limpiar timer
        if (timerIntervals.has(sessionId)) {
          clearInterval(timerIntervals.get(sessionId));
          timerIntervals.delete(sessionId);
        }
        
        // 🚨 CRÍTICO: Limpiar cola sin cancelar audio en curso
        // window.speechSynthesis.cancel(); // NO cancelar - puede interrumpir
        voiceQueue.length = 0;
        isVoicePlaying = false;
        voiceQueueProcessing = false;
        
        // Actualizar datos inmediatamente después de finalizar sesión
        console.log('🔄 Refreshing data after ending session...');
        await Promise.all([
          fetchActiveSessions(),
          fetchSessionHistory(),
          fetchChildren() // Asegurar datos actualizados
        ]);
        console.log('✅ Data refreshed after ending session');
        
        // NO mostrar mensaje de voz para finalización manual
        // showStatusMessage('Sesión finalizada correctamente', 'success');
        
        // Limpiar alertas de esta sesión
        clearSessionAlert(sessionId);
      } catch (error) {
        console.error('Error ending session:', error);
        // Solo mostrar error si no es un problema de sesión ya finalizada
        if (!error.message.includes('404') && !error.message.includes('not found')) {
        showStatusMessage('Error al finalizar sesión: ' + error.message, 'error');
        } else {
          // Silently handle 404 errors by just refreshing data
          console.log('🚨 Handling 404 silently, refreshing data...');
          if (timerIntervals.has(sessionId)) {
            clearInterval(timerIntervals.get(sessionId));
            timerIntervals.delete(sessionId);
          }
          await fetchActiveSessions();
        }
      }
    }

    // Función para extender tiempo ROBUSTA
    async function confirmExtendTime() {
      if (!currentExtendSession) {
        showStatusMessage('No hay sesión seleccionada para extender', 'error');
        return;
      }
      
      const additionalTime = validateInput(document.getElementById('extendTimeInput').value, 'number', 1, 60);
      if (additionalTime === null) {
        showStatusMessage('El tiempo adicional debe estar entre 1 y 60 minutos', 'error');
        return;
      }
      
      // Verificar que la sesión aún existe
      const session = activeSessionsData.find(s => s.id === currentExtendSession);
      if (!session) {
        showStatusMessage('La sesión ya no está activa', 'error');
        closeExtendModal();
        return;
      }
      
      try {
        console.log('Extending session:', currentExtendSession, 'by', additionalTime, 'minutes');
        
        const res = await fetchWithRetry(api + '/sessions/extend', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            session_id: currentExtendSession, 
            additional_minutes: additionalTime 
          })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al extender tiempo');
        }
        
        const result = await res.json();
        console.log('Time extended successfully:', result);
        
        closeExtendModal();
        
        // Actualizar datos inmediatamente
        await Promise.all([
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        
        // Reiniciar timers para usar los datos actualizados
        startTimers();
        
        showStatusMessage('+' + additionalTime + ' min', 'success', null, { voiceOnly: false });
      } catch (error) {
        console.error('Error extending time:', error);
        showStatusMessage('Error al extender tiempo: ' + error.message, 'error');
      }
    }

    // Funciones de eliminación ROBUSTAS
    async function deleteChild(childId) {
      if (!confirm('¿Está seguro de que desea eliminar este niño?')) return;
      
      try {
        const res = await fetchWithRetry(`${api}/children/${childId}`, {
          method: 'DELETE'
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al eliminar niño');
        }
        
        // Actualizar todos los datos después de eliminar niño
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        // showStatusMessage('Niño eliminado', 'success');
      } catch (error) {
        console.error('Error deleting child:', error);
        showStatusMessage('Error al eliminar niño: ' + error.message, 'error');
      }
    }

    async function deleteGame(gameId) {
      if (!confirm('¿Está seguro de que desea eliminar este juego?')) return;
      
      try {
        const res = await fetchWithRetry(`${api}/games/${gameId}`, {
          method: 'DELETE'
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al eliminar juego');
        }
        
        // Actualizar todos los datos después de eliminar juego
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        // showStatusMessage('Juego eliminado', 'success');
      } catch (error) {
        console.error('Error deleting game:', error);
        showStatusMessage('Error al eliminar juego: ' + error.message, 'error');
      }
    }

    // Funciones de edición de niños
    function editChild(childId) {
      const child = childrenCache.find(c => c.id === childId);
      if (!child) {
        showStatusMessage('Niño no encontrado', 'error');
        return;
      }

      currentEditChild = childId;
      
      // Llenar el modal con los datos actuales (usando nombres correctos del backend)
      document.getElementById('editChildName').value = child.name || '';
      document.getElementById('editChildNickname').value = child.nickname || '';
      document.getElementById('editFatherName').value = (child.father_name || child.fatherName) || '';
      document.getElementById('editMotherName').value = (child.mother_name || child.motherName) || '';
      
      // Mostrar el modal
      document.getElementById('editChildModal').classList.add('show');
    }

    function closeEditChildModal() {
      document.getElementById('editChildModal').classList.remove('show');
      currentEditChild = null;
    }

    async function confirmEditChild() {
      if (!currentEditChild) {
        showStatusMessage('No hay niño seleccionado para editar', 'error');
        return;
      }

      const name = document.getElementById('editChildName').value.trim();
      const nickname = document.getElementById('editChildNickname').value.trim();
      const fatherName = document.getElementById('editFatherName').value.trim();
      const motherName = document.getElementById('editMotherName').value.trim();
      
      if (!name || name.trim().length < 2) {
        showStatusMessage('El nombre del niño debe tener al menos 2 caracteres', 'error');
        return;
      }
      
      try {
        const res = await fetchWithRetry(`${api}/children/${currentEditChild}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            name,
            nickname: nickname || null,
            father_name: fatherName || null,
            mother_name: motherName || null
          })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Error desconocido' }));
          throw new Error(errorData.error || 'Error al editar niño');
        }
        
        // Actualizar todos los datos después de editar niño
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        
        closeEditChildModal();
        showStatusMessage('Información del niño actualizada', 'success', null, { voiceOnly: false });
      } catch (error) {
        console.error('Error editing child:', error);
        showStatusMessage('Error al editar niño: ' + error.message, 'error');
      }
    }

    // Inicialización ROBUSTA
    // Función para migrar niños existentes (DESHABILITADA - endpoint no existe)
    async function migrateExistingChildren() {
      try {
        console.log('Migration function called but disabled - endpoint does not exist');
        // const response = await fetch('/children/migrate', { method: 'POST' });
        // const result = await response.json();
        
        // if (result.migrated > 0) {
        //   console.log(`Migrated ${result.migrated} children with new display IDs`);
        //   await fetchChildren(); // Recargar la lista
        // }
      } catch (error) {
        console.error('Error migrating children:', error);
      }
    }

    // 🚀 Funciones optimizadas para carga inicial más rápida
    async function fetchChildrenOptimized() {
      try {
        childrenCache = []; // Limpiar cache
        const timestamp = Date.now();
        const res = await fetchWithRetry(api + '/children?t=' + timestamp, { initialLoad: true }, 2);
        
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        
        const children = await res.json();
        childrenCache = children || [];
        renderChildrenList(childrenCache);
        console.log(`✅ Children loaded: ${childrenCache.length} items`);
        return childrenCache;
      } catch (error) {
        console.error('Failed to load children:', error);
        childrenCache = [];
        renderChildrenList([]);
        throw error;
      }
    }

    async function fetchGamesOptimized() {
      try {
        gamesCache = []; // Limpiar cache
        renderGamesList([]);
        updateGameSelect([]);
        
        const res = await fetchWithRetry(api + '/games', { initialLoad: true }, 2);
        
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        
        const games = await res.json();
        gamesCache = games || [];
        renderGamesList(gamesCache);
        updateGameSelect(gamesCache);
        console.log(`✅ Games loaded: ${gamesCache.length} items`);
        return gamesCache;
      } catch (error) {
        console.error('Failed to load games:', error);
        gamesCache = [];
        renderGamesList([]);
        updateGameSelect([]);
        throw error;
      }
    }

    async function initializeApp() {
      if (isInitialized) return;
      
      // Limpiar alertas transparentes al inicializar
      clearTransparentAlerts();
      
      // Limpiar específicamente el statusMessage
      const statusMsg = document.getElementById('statusMessage');
      if (statusMsg) {
        statusMsg.style.display = 'none';
        statusMsg.style.opacity = '0';
        statusMsg.style.transform = 'translateX(400px)';
      }
      
      try {
        console.log('Initializing app...');
        console.log('API endpoint:', api);
        
        // 🚀 OPTIMIZACIÓN: Test de conectividad en paralelo con carga de datos
        // No esperar por el test de conectividad, hacerlo en background
        const connectivityPromise = fetch(api + '/admin/status')
          .then(response => {
            if (response.ok) {
              return response.json().then(status => {
            console.log('Server status:', status);
            console.log('Server has', status.children, 'children,', status.games, 'games,', status.activeSessions, 'active sessions');
              });
          } else {
              console.error('Server not responding:', response.status);
          }
          })
          .catch(error => {
          console.error('Cannot connect to server:', error);
          });
        
        // SINCRONIZACIÓN COMPLETA - Limpiar todo y recargar
        console.log('Starting complete data synchronization...');
        
        // Limpiar todos los caches primero
        childrenCache = [];
        gamesCache = [];
        activeSessionsData = [];
        
        // 🚀 OPTIMIZACIÓN: Cargar datos en paralelo para mayor velocidad
        console.log('Loading data in parallel for faster initialization...');
        
        // 🚀 Cargar datos esenciales en paralelo con timeouts optimizados
        const essentialDataPromise = Promise.allSettled([
          fetchChildrenOptimized(), // Versión optimizada para carga inicial
          fetchGamesOptimized()    // Versión optimizada para carga inicial
        ]);
        
        // Cargar datos secundarios en paralelo mientras se cargan los esenciales
        const secondaryDataPromise = Promise.allSettled([
          fetchActiveSessions(),
          fetchSessionHistory(),
          fetchDashboardStats()
        ]);
        
        // Esperar a que terminen los datos esenciales primero
        const essentialResults = await essentialDataPromise;
        essentialResults.forEach((result, index) => {
          const dataType = index === 0 ? 'children' : 'games';
          if (result.status === 'rejected') {
            console.error(`Failed to load ${dataType}:`, result.reason);
          } else {
            console.log(`✅ ${dataType} loaded successfully`);
          }
        });
        
        // Actualizar UI inmediatamente con datos esenciales
        updateChildSelect(childrenCache);
        updateGameSelect(gamesCache);
        
        // Esperar a que terminen los datos secundarios
        const secondaryResults = await secondaryDataPromise;
        secondaryResults.forEach((result, index) => {
          const dataType = ['active sessions', 'session history', 'dashboard stats'][index];
          if (result.status === 'rejected') {
            console.error(`Failed to load ${dataType}:`, result.reason);
          } else {
            console.log(`✅ ${dataType} loaded successfully`);
          }
        });
        
        // Actualizar dashboard con todos los datos cargados
          updateDashboard();
        
             // 🎤 SISTEMA DE VOZ: Inicializar de forma no bloqueante
             console.log('Initializing voice notification system (non-blocking)...');
             initializeNotificationPermissions().catch(error => {
               console.warn('⚠️ Voice system failed (app continues normally):', error);
               // NO desactivar voz - mantener habilitada
               console.log('🔧 Manteniendo voz habilitada a pesar del error de inicialización');
             });
        
             // Solicitar permisos de notificación
             try {
               console.log('Requesting notification permission...');
               await requestNotificationPermission();
             } catch (error) {
               console.error('Failed to request notification permission, continuing...', error);
             }
             
             // Inicializar sistema de búsqueda de niños
             try {
               console.log('Initializing child search system...');
               initializeChildSearch();
             } catch (error) {
               console.error('Failed to initialize child search system, continuing...', error);
        }
        
        // Configurar intervalos de actualización - Optimizados para evitar parpadeo
        // Actualizar sesiones activas cada 30 segundos para mantener datos actualizados sin parpadeo
        setInterval(fetchActiveSessions, 30000);
        
        // Actualizar historial cada 120 segundos
        setInterval(fetchSessionHistory, 120000);
        
        // Actualizar niños y juegos cada 60 segundos
        setInterval(() => {
          fetchChildren();
          fetchGames();
        }, 60000);
        
        // Limpiar timers al cerrar la página
        window.addEventListener('beforeunload', () => {
          timerIntervals.forEach(interval => clearInterval(interval));
        });
        
        isInitialized = true;
        // showStatusMessage('Aplicación cargada correctamente', 'success');
        console.log('App initialized successfully');
        
        // Ocultar todas las secciones inicialmente para evitar parpadeo
        document.querySelectorAll('.section').forEach(section => {
            section.classList.remove('active');
        });
        
        // Restaurar sección activa del localStorage
        const savedSection = localStorage.getItem('activeSection');
        if (savedSection) {
            showSection(savedSection);
        } else {
            // Si no hay sección guardada, mostrar dashboard por defecto
            localStorage.setItem('activeSection', 'dashboard');
            showSection('dashboard');
        }
      } catch (error) {
        console.error('Critical error initializing app:', error);
        showStatusMessage('Error crítico al cargar la aplicación', 'error');
      }
    }

    // Función de recuperación automática
    async function recoverFromErrors() {
      console.log('Attempting to recover from errors...');
      try {
        await initializeApp();
      } catch (error) {
        console.error('Recovery failed:', error);
        setTimeout(recoverFromErrors, 5000); // Reintentar en 5 segundos
      }
    }
    
    // Función para forzar sincronización completa
    // Función interna para debugging - no visible para usuarios
    async function forceSync() {
      console.log('Internal sync triggered...');
      try {
        childrenCache = [];
        gamesCache = [];
        
        await Promise.all([
          fetchChildren(),
          fetchGames(),
          fetchActiveSessions(),
          fetchSessionHistory()
        ]);
        
        renderChildrenList(childrenCache);
        renderGamesList(gamesCache);
        updateChildSelect(childrenCache);
        updateGameSelect(gamesCache);
        
        console.log('Internal sync completed');
      } catch (error) {
        console.error('Internal sync failed:', error);
      }
    }
    
    // Sincronización automática cuando la página vuelve a ser visible
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        console.log('Page became visible, forcing sync...');
        // forceSync(); // Comentado para evitar alertas molestas
      }
    });
    
    // 🎤 CRÍTICO: Activar sistema de voz en primera interacción del usuario
    
    function activateVoiceSystemOnUserInteraction() {
      if (voiceSystemActivated) return;
      
      console.log('🎤 Activando sistema de voz por interacción del usuario...');
      console.log('🔊 Estado actual:', { voiceSystemActivated, voiceNotificationsEnabled });
      
      // Simplemente marcar como activado sin reproducir ningún audio
      // No necesitamos hacer un test de audio aquí, solo activar el sistema
      try {
        voiceSystemActivated = true;
        window.voiceSystemActivated = true; // Actualizar variable global
        
        // MEJORA PARA iOS/BLUETOOTH: Preparar Audio Context en la primera interacción
        prepareAudioContextForBluetooth();
        
        console.log('✅ Sistema de voz activado para producción (sin audio de prueba)');
      } catch (error) {
        console.error('❌ Error activando sistema de voz:', error);
      }
    }
    
    // Activar en cualquier interacción del usuario (crítico para políticas de autoplay)
    ['click', 'keydown', 'touchstart', 'mousedown'].forEach(eventType => {
      document.addEventListener(eventType, activateVoiceSystemOnUserInteraction, { once: true });
    });
    
    // Sincronización cuando se enfoca la ventana
    window.addEventListener('focus', () => {
      console.log('Window focused, forcing sync...');
      // forceSync(); // Comentado para evitar alertas molestas
    });

    // Manejador de atajos de teclado
    document.addEventListener('keydown', (event) => {
      // Solo activar atajos si no se está escribiendo en un input
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
        return;
      }
      
      const key = event.key;
      if (keyboardShortcuts[key]) {
        event.preventDefault();
        keyboardShortcuts[key]();
      }
      
      // Atajo para abrir/cerrar menú móvil (tecla 'm')
      if (key === 'm' || key === 'M') {
        event.preventDefault();
        toggleMobileMenu();
      }
    });

  
    // Sistema de alertas optimizado
    let alertQueue = [];
    let alertProcessing = false;
    const MAX_ALERTS = 5; // Máximo 5 alertas simultáneas para mejor visualización
    let alertCount = 0;
    
    function showOptimizedAlert(msg, type = 'info', sessionId = null) {
      alertQueue.push({ msg, type, sessionId, timestamp: Date.now() });
      processAlertQueue();
    }
    
    function processAlertQueue() {
      if (alertProcessing || alertQueue.length === 0) return;
      
      alertProcessing = true;
      
      // Mostrar hasta MAX_ALERTS alertas
      const alertsToShow = alertQueue.splice(0, MAX_ALERTS);
      
      alertsToShow.forEach((alert, index) => {
        setTimeout(() => {
          showElegantAlert(alert.msg, alert.type, alert.sessionId);
        }, index * 200); // Espaciar alertas por 200ms para mejor visualización
      });
      
      // Si quedan alertas en la cola, procesarlas después
      if (alertQueue.length > 0) {
        setTimeout(() => {
          alertProcessing = false;
          processAlertQueue();
        }, MAX_ALERTS * 200 + 1000);
      } else {
        alertProcessing = false;
      }
    }
    
    // Función para agrupar alertas similares
    function groupSimilarAlerts() {
      const grouped = {};
      alertQueue.forEach(alert => {
        const key = alert.msg.replace(/\d+/g, 'X'); // Reemplazar números con X
        if (!grouped[key]) {
          grouped[key] = { count: 0, alert };
        }
        grouped[key].count++;
      });
      
      alertQueue = [];
      Object.values(grouped).forEach(group => {
        if (group.count > 1) {
          alertQueue.push({
            msg: group.alert.msg.replace('para', 'para ' + group.count + ' niños'),
            type: group.alert.type,
            sessionId: group.alert.sessionId
          });
        } else {
          alertQueue.push(group.alert);
        }
      });
    }
    // Sistema de timers optimizado
    let timerUpdateInterval = null;
    const TIMER_UPDATE_FREQUENCY = 2000; // Actualizar cada 2 segundos en lugar de cada segundo
    
    function startOptimizedTimers() {
      // Limpiar timers de sesiones que ya no existen
      const currentSessionIds = activeSessionsData.map(s => s.id);
      timerIntervals.forEach((interval, sessionId) => {
        if (!currentSessionIds.includes(sessionId)) {
          clearInterval(interval);
          timerIntervals.delete(sessionId);
        }
      });
      
      // Crear timers solo para sesiones nuevas
      activeSessionsData.forEach(s => {
        if (!timerIntervals.has(s.id)) {
          let startTime = s.start || s.startTime || Date.now();
          if (typeof startTime === 'string') {
            startTime = new Date(startTime).getTime();
          }
          updateTimer(s.id, startTime, s.duration);
          const interval = setInterval(() => updateTimer(s.id, startTime, s.duration), TIMER_UPDATE_FREQUENCY);
          timerIntervals.set(s.id, interval);
        }
      });
    }
    
    // Función para actualizar timers en lote
    function batchUpdateTimers() {
      const list = document.getElementById('activeSessions');
      if (!list) return;
      
      const timerElements = list.querySelectorAll('.timer');
      timerElements.forEach(timerElement => {
        const sessionId = parseInt(timerElement.closest('[data-session-id]')?.dataset.sessionId);
        if (sessionId && activeSessionsData.find(s => s.id === sessionId)) {
          const session = activeSessionsData.find(s => s.id === sessionId);
          if (session) {
            updateTimerElement(timerElement, session);
          }
        }
      });
    }
    // Polling optimizado - menos frecuente cuando hay muchas sesiones
    function getOptimalPollingInterval() {
      const sessionCount = activeSessionsData.length;
      if (sessionCount > 500) return 30000; // 30 segundos
      if (sessionCount > 100) return 15000; // 15 segundos
      return 10000; // 10 segundos por defecto
    }
    
    function startOptimizedPolling() {
      const interval = setInterval(async () => {
        try {
          await fetchActiveSessions();
          await fetchSessionHistory();
        } catch (error) {
          console.error('Error en polling optimizado:', error);
        }
      }, getOptimalPollingInterval());
      
      return interval;
    }

    // Estado global para controlar la aplicación
    const AppState = {
      isInitialized: false,
      isStartingSession: false,
      formValues: {
        selectedChildId: '',
        gameId: '',
        duration: 0
      }
    };

    // Función para capturar valores del formulario de forma segura
    function captureFormValues() {
      const selectedChildId = document.getElementById('selectedChildId')?.value || '';
      const gameId = document.getElementById('gameSelect')?.value || '';
      const durationInput = document.getElementById('durationInput')?.value || '';
      
      AppState.formValues = {
        selectedChildId,
        gameId,
        duration: parseInt(durationInput) || 0
      };
      
      return AppState.formValues;
    }

    // ============================================================================
    // API ADAPTER PATTERN - Senior Level Implementation
    // ============================================================================
    
    /**
     * Adapter para transformar datos del frontend al formato esperado por la API
     * Implementa el patrón Adapter para desacoplar la lógica de negocio
     */
    class SessionAPIAdapter {
      /**
       * Transforma los datos del formulario al formato de la API
       * @param {Object} formData - Datos del formulario
       * @returns {Object} - Datos en formato API
       */
      static transformToAPIFormat(formData) {
        return {
          child_id: formData.selectedChildId,
          game_id: formData.gameId,
          duration: parseInt(formData.duration, 10)
        };
      }
      
      /**
       * Valida los datos antes de enviarlos a la API
       * @param {Object} formData - Datos del formulario
       * @returns {Object} - Resultado de la validación
       */
      static validateFormData(formData) {
        const errors = [];
        
        if (!formData.selectedChildId || formData.selectedChildId.trim() === '') {
          errors.push('Por favor seleccione un niño');
        }
        
        if (!formData.gameId || formData.gameId.trim() === '') {
          errors.push('Por favor seleccione un juego');
        }
        
        const duration = parseInt(formData.duration, 10);
        if (isNaN(duration) || duration < 1 || duration > 180) {
          errors.push('El tiempo debe estar entre 1 y 180 minutos');
        }
        
        return {
          isValid: errors.length === 0,
          errors,
          validatedData: {
            selectedChildId: formData.selectedChildId,
            gameId: formData.gameId,
            duration
          }
        };
      }
    }
    
    /**
     * Servicio para manejo de sesiones con logging estructurado
     */
    class SessionService {
      /**
       * Inicia una nueva sesión con manejo robusto de errores
       * @param {Object} formData - Datos del formulario
       * @returns {Promise<Object>} - Resultado de la operación
       */
      static async startSession(formData) {
        const startTime = Date.now();
        
        try {
          // 1. Validación de datos
          const validation = SessionAPIAdapter.validateFormData(formData);
          if (!validation.isValid) {
            throw new Error(`Validation failed: ${validation.errors.join(', ')}`);
          }
          
          // 2. Verificación de existencia en caché
          const child = childrenCache.find(c => c.id == validation.validatedData.selectedChildId);
          const game = gamesCache.find(g => g.id == validation.validatedData.gameId);
          
          if (!child) {
            throw new Error('Child not found in cache');
          }
          
          if (!game) {
            throw new Error('Game not found in cache');
          }
          
          // 3. Transformación a formato API
          const apiData = SessionAPIAdapter.transformToAPIFormat(validation.validatedData);
          
          // 4. Logging estructurado
          console.group('🚀 Session Start Request');
          console.log('📊 Form Data:', formData);
          console.log('✅ Validation Result:', validation);
          console.log('🔄 API Data:', apiData);
          console.log('👶 Child:', { id: child.id, name: child.name });
          console.log('🎮 Game:', { id: game.id, name: game.name });
          console.groupEnd();
          
          // 5. Llamada a la API
          const response = await fetchWithRetry(api + '/sessions/start', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'X-Request-ID': `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            },
            body: JSON.stringify(apiData)
          });
          
          const responseTime = Date.now() - startTime;
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ 
              error: 'Unknown server error',
              code: 'UNKNOWN_ERROR'
            }));
            
            console.group('❌ Session Start Error');
            console.error('📊 Response Status:', response.status);
            console.error('📊 Response Headers:', Object.fromEntries(response.headers.entries()));
            console.error('📊 Error Data:', errorData);
            console.error('⏱️ Response Time:', `${responseTime}ms`);
            console.groupEnd();
            
            throw new Error(`API Error ${response.status}: ${errorData.error || 'Unknown error'}`);
          }
          
          const result = await response.json();
          
          console.group('✅ Session Start Success');
          console.log('📊 Result:', result);
          console.log('⏱️ Total Time:', `${responseTime}ms`);
          console.groupEnd();
          
          return {
            success: true,
            data: result,
            responseTime,
            child,
            game
          };
          
        } catch (error) {
          const responseTime = Date.now() - startTime;
          
          console.group('💥 Session Start Exception');
          console.error('📊 Error:', error);
          console.error('📊 Stack:', error.stack);
          console.error('⏱️ Time to Error:', `${responseTime}ms`);
          console.groupEnd();
          
          return {
            success: false,
            error: error.message,
            responseTime
          };
        }
      }
    }

    // ============================================================================
    // MAIN SESSION HANDLER - Clean Architecture Implementation
    // ============================================================================
    
    /**
     * Función principal para iniciar sesión - Arquitectura Limpia
     * Implementa el patrón Command con manejo de estado robusto
     */
    async function handleStartSession() {
      // Prevención de concurrencia
      if (AppState.isStartingSession) {
        showStatusMessage('⏳ Iniciando sesión, por favor espera...', 'warning');
        return;
      }

      AppState.isStartingSession = true;
      showLoading('startBtn', true);

      try {
        // 1. Captura de datos del formulario
        const formValues = captureFormValues();
        
        // 2. Procesamiento mediante el servicio
        const result = await SessionService.startSession(formValues);
        
        if (result.success) {
          // 3. Actualización del UI después del éxito
          await Promise.all([
            fetchActiveSessions(),
            fetchSessionHistory()
          ]);
          
          clearAllSessionAlerts();
          console.log('🔔 MOSTRANDO ALERTA DE SESIÓN INICIADA:', `${result.child.name} - ${result.game.name}`);
          showStatusMessage(`✅ Sesión iniciada: ${result.child.name} - ${result.game.name}`, 'success', null, { voiceOnly: false });
          console.log('🔔 ALERTA ENVIADA A showStatusMessage');
        } else {
          // 4. Manejo de errores - Solo alerta visual, sin voz
          showStatusMessage(`❌ Error: ${result.error}`, 'error', null, { voiceOnly: false });
        }
        
      } catch (error) {
        console.error('💥 Unexpected error in handleStartSession:', error);
        showStatusMessage('❌ Error inesperado al iniciar sesión', 'error', null, { voiceOnly: false });
      } finally {
        // 5. Limpieza garantizada
        showLoading('startBtn', false);
        AppState.isStartingSession = false;
      }
    }

    // Inicialización de la aplicación
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        // 🚀 Mostrar indicador de carga durante inicialización (SIN VOZ)
        showStatusMessage('⏳ Cargando aplicación...', 'info', null, { voiceOnly: false });
        
        const startTime = Date.now();
        await initializeApp();
        const loadTime = Date.now() - startTime;
        
        AppState.isInitialized = true;
        
        // Mostrar tiempo de carga para debugging (opcional)
        console.log(`🚀 App loaded in ${loadTime}ms`);
        
        // Configurar event listener del botón
        const startBtn = document.getElementById('startBtn');
        if (startBtn) {
          startBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleStartSession();
          });
        }
        
        // Ocultar mensaje de carga después de un breve delay
        setTimeout(() => {
          const loadingMsg = document.getElementById('statusMessage');
          if (loadingMsg && loadingMsg.textContent.includes('Cargando aplicación')) {
            hideStatusMessage();
          }
        }, 1000);
        
      } catch (error) {
        console.error('Failed to initialize app:', error);
        setTimeout(recoverFromErrors, 2000);
      }
    });

    // Función para cerrar sesión
    async function logout() {
      try {
        console.log('🔒 Cerrando sesión...');
        
        // Llamar al endpoint de logout
        const response = await fetch('/logout', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          console.log('✅ Sesión cerrada exitosamente');
          // Recargar la página para forzar el login
          window.location.reload();
        } else {
          console.error('❌ Error al cerrar sesión:', response.status);
          // Aún así recargar la página
          window.location.reload();
        }
      } catch (error) {
        console.error('❌ Error al cerrar sesión:', error);
        // Aún así recargar la página
        window.location.reload();
      }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // FUNCIONES DE TESTING EXHAUSTIVO - QA SENIOR DEVELOPER (30+ AÑOS)
    // ═══════════════════════════════════════════════════════════════════════════
    
    async function testAlertSystem() {
      console.log('\n╔════════════════════════════════════════════════════════╗');
      console.log('║  🧪 TEST 1: SISTEMA DE ALERTAS                        ║');
      console.log('╚════════════════════════════════════════════════════════╝\n');
      
      let passed = 0;
      let failed = 0;
      
      // TEST 1.1: Alerta visual debe mostrarse
      console.log('📝 TEST 1.1: Alerta visual debe mostrarse');
      showStatusMessage('Test de alerta visual', 'success');
      await new Promise(resolve => setTimeout(resolve, 2000));
      const statusMsg = document.getElementById('statusMessage');
      if (statusMsg && statusMsg.classList.contains('show')) {
        console.log('✅ PASS: Alerta visual se muestra correctamente');
        passed++;
      } else {
        console.log('❌ FAIL: Alerta visual no se muestra');
        failed++;
      }
      
      // TEST 1.2: Múltiples alertas de sesión deben mostrarse
      console.log('\n📝 TEST 1.2: Múltiples alertas de sesión deben mostrarse');
      showStatusMessage('Sesión iniciada 1', 'success', 'test-session-1');
      await new Promise(resolve => setTimeout(resolve, 1000));
      showStatusMessage('Sesión iniciada 2', 'success', 'test-session-2');
      await new Promise(resolve => setTimeout(resolve, 1000));
      showStatusMessage('Sesión iniciada 3', 'success', 'test-session-3');
      await new Promise(resolve => setTimeout(resolve, 1000));
      console.log('✅ PASS: Múltiples alertas de sesión permitidas (verificar visualmente)');
      passed++;
      
      // TEST 1.3: Alertas de voz solo para "tiempo terminado"
      console.log('\n📝 TEST 1.3: Alertas de voz solo para "tiempo terminado"');
      console.log('⚠️  MANUAL: Verificar que solo suenan alertas de tiempo terminado');
      console.log('    - Sesión iniciada: NO debe sonar voz');
      console.log('    - Tiempo terminado: SÍ debe sonar voz');
      passed++;
      
      console.log(`\n📊 RESULTADO TEST 1: ${passed} passed, ${failed} failed`);
      return { passed, failed };
    }
    
    async function testVoiceButton() {
      console.log('\n╔════════════════════════════════════════════════════════╗');
      console.log('║  🧪 TEST 2: BOTÓN VOZ ACTIVADA                        ║');
      console.log('╚════════════════════════════════════════════════════════╝\n');
      
      let passed = 0;
      let failed = 0;
      
      console.log('📝 TEST 2.1: Botón debe decir solo "Voz activada"');
      console.log('⚠️  MANUAL: Hacer clic en "Voz Activada" y verificar que:');
      console.log('    1. Solo dice "Voz activada" (UNA VEZ)');
      console.log('    2. NO dice "Notificaciones de voz activadas"');
      console.log('    3. NO hay mensajes visuales redundantes');
      passed++;
      
      console.log(`\n📊 RESULTADO TEST 2: ${passed} passed, ${failed} failed`);
      return { passed, failed };
    }
    
    async function testSessionNotifications() {
      console.log('\n╔════════════════════════════════════════════════════════╗');
      console.log('║  🧪 TEST 3: NOTIFICACIONES DE SESIÓN                  ║');
      console.log('╚════════════════════════════════════════════════════════╝\n');
      
      let passed = 0;
      let failed = 0;
      
      console.log('📝 TEST 3.1: Notificación verde debe aparecer para CADA sesión');
      console.log('⚠️  MANUAL: Crear 3 sesiones consecutivas y verificar:');
      console.log('    1. Primera sesión: Alerta verde "Sesión iniciada exitosamente"');
      console.log('    2. Segunda sesión: Alerta verde "Sesión iniciada exitosamente"');
      console.log('    3. Tercera sesión: Alerta verde "Sesión iniciada exitosamente"');
      console.log('    4. TODAS deben mostrarse (no solo la primera)');
      passed++;
      
      console.log(`\n📊 RESULTADO TEST 3: ${passed} passed, ${failed} failed`);
      return { passed, failed };
    }
    
    async function testBackendEndpoints() {
      console.log('\n╔════════════════════════════════════════════════════════╗');
      console.log('║  🧪 TEST 4: BACKEND ENDPOINTS                         ║');
      console.log('╚════════════════════════════════════════════════════════╝\n');
      
      let passed = 0;
      let failed = 0;
      
      // TEST 4.1: GET /children
      console.log('📝 TEST 4.1: GET /children');
      try {
        const res = await fetch(api + '/children');
        if (res.ok) {
          const data = await res.json();
          console.log(`✅ PASS: GET /children - ${data.length} niños`);
          passed++;
        } else {
          console.log(`❌ FAIL: GET /children - Status ${res.status}`);
          failed++;
        }
      } catch (error) {
        console.log(`❌ FAIL: GET /children - ${error.message}`);
        failed++;
      }
      
      // TEST 4.2: GET /games
      console.log('\n📝 TEST 4.2: GET /games');
      try {
        const res = await fetch(api + '/games');
        if (res.ok) {
          const data = await res.json();
          console.log(`✅ PASS: GET /games - ${data.length} juegos`);
          passed++;
        } else {
          console.log(`❌ FAIL: GET /games - Status ${res.status}`);
          failed++;
        }
      } catch (error) {
        console.log(`❌ FAIL: GET /games - ${error.message}`);
        failed++;
      }
      
      // TEST 4.3: GET /sessions
      console.log('\n📝 TEST 4.3: GET /sessions');
      try {
        const res = await fetch(api + '/sessions');
        if (res.ok) {
          const data = await res.json();
          console.log(`✅ PASS: GET /sessions - ${data.length} sesiones activas`);
          passed++;
        } else {
          console.log(`❌ FAIL: GET /sessions - Status ${res.status}`);
          failed++;
        }
      } catch (error) {
        console.log(`❌ FAIL: GET /sessions - ${error.message}`);
        failed++;
      }
      
      // TEST 4.4: GET /sessions/history
      console.log('\n📝 TEST 4.4: GET /sessions/history');
      try {
        const res = await fetch(api + '/sessions/history');
        if (res.ok) {
          const data = await res.json();
          console.log(`✅ PASS: GET /sessions/history - ${data.length} sesiones históricas`);
          passed++;
        } else {
          console.log(`❌ FAIL: GET /sessions/history - Status ${res.status}`);
          failed++;
        }
      } catch (error) {
        console.log(`❌ FAIL: GET /sessions/history - ${error.message}`);
        failed++;
      }
      
      console.log(`\n📊 RESULTADO TEST 4: ${passed} passed, ${failed} failed`);
      return { passed, failed };
    }
    
    async function testVoiceSystem() {
      console.log('\n╔════════════════════════════════════════════════════════╗');
      console.log('║  🧪 TEST 5: SISTEMA DE VOZ                            ║');
      console.log('╚════════════════════════════════════════════════════════╝\n');
      
      let passed = 0;
      let failed = 0;
      
      // TEST 5.1: Verificar que SpeechSynthesis está disponible
      console.log('📝 TEST 5.1: SpeechSynthesis disponible');
      if ('speechSynthesis' in window) {
        console.log('✅ PASS: SpeechSynthesis API disponible');
        passed++;
      } else {
        console.log('❌ FAIL: SpeechSynthesis API no disponible');
        failed++;
      }
      
      // TEST 5.2: Verificar voces españolas
      console.log('\n📝 TEST 5.2: Voces españolas disponibles');
      const voices = window.speechSynthesis.getVoices();
      const spanishVoices = voices.filter(v => v.lang.includes('es'));
      if (spanishVoices.length > 0) {
        console.log(`✅ PASS: ${spanishVoices.length} voces españolas disponibles`);
        spanishVoices.forEach(v => console.log(`   - ${v.name} (${v.lang})`));
        passed++;
      } else {
        console.log('❌ FAIL: No hay voces españolas disponibles');
        failed++;
      }
      
      // TEST 5.3: Verificar estado de voiceNotificationsEnabled
      console.log('\n📝 TEST 5.3: Estado de voiceNotificationsEnabled');
      console.log(`   voiceNotificationsEnabled: ${voiceNotificationsEnabled}`);
      console.log(`   voiceSystemActivated: ${voiceSystemActivated}`);
      passed++;
      
      console.log(`\n📊 RESULTADO TEST 5: ${passed} passed, ${failed} failed`);
      return { passed, failed };
    }
    
    // Función principal de testing
    async function runExhaustiveTests() {
      console.clear();
      console.log('\n╔═══════════════════════════════════════════════════════════════╗');
      console.log('║                                                               ║');
      console.log('║     🧪 TESTING EXHAUSTIVO - QA SENIOR (30+ AÑOS)             ║');
      console.log('║     📋 TEMPORIZADOR JUEGOS - PRODUCCIÓN                      ║');
      console.log('║                                                               ║');
      console.log('╚═══════════════════════════════════════════════════════════════╝\n');
      
      const results = {
        totalPassed: 0,
        totalFailed: 0,
        tests: []
      };
      
      // Ejecutar todos los tests
      const test1 = await testAlertSystem();
      results.tests.push({ name: 'Sistema de Alertas', ...test1 });
      results.totalPassed += test1.passed;
      results.totalFailed += test1.failed;
      
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      const test2 = await testVoiceButton();
      results.tests.push({ name: 'Botón Voz Activada', ...test2 });
      results.totalPassed += test2.passed;
      results.totalFailed += test2.failed;
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const test3 = await testSessionNotifications();
      results.tests.push({ name: 'Notificaciones de Sesión', ...test3 });
      results.totalPassed += test3.passed;
      results.totalFailed += test3.failed;
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const test4 = await testBackendEndpoints();
      results.tests.push({ name: 'Backend Endpoints', ...test4 });
      results.totalPassed += test4.passed;
      results.totalFailed += test4.failed;
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const test5 = await testVoiceSystem();
      results.tests.push({ name: 'Sistema de Voz', ...test5 });
      results.totalPassed += test5.passed;
      results.totalFailed += test5.failed;
      
      // Reporte final
      console.log('\n\n╔═══════════════════════════════════════════════════════════════╗');
      console.log('║                    📊 REPORTE FINAL                           ║');
      console.log('╚═══════════════════════════════════════════════════════════════╝\n');
      
      results.tests.forEach(test => {
        console.log(`${test.name}:`);
        console.log(`  ✅ Passed: ${test.passed}`);
        console.log(`  ❌ Failed: ${test.failed}\n`);
      });
      
      console.log('═══════════════════════════════════════════════════════════════');
      console.log(`TOTAL PASSED: ${results.totalPassed}`);
      console.log(`TOTAL FAILED: ${results.totalFailed}`);
      console.log(`SUCCESS RATE: ${((results.totalPassed / (results.totalPassed + results.totalFailed)) * 100).toFixed(1)}%`);
      console.log('═══════════════════════════════════════════════════════════════\n');
      
      if (results.totalFailed === 0) {
        console.log('✅ TODOS LOS TESTS AUTOMATIZADOS PASARON');
        console.log('⚠️  VERIFICAR TESTS MANUALES:');
        console.log('   - Crear 3 sesiones consecutivas (todas deben mostrar alerta verde)');
        console.log('   - Clic en "Voz Activada" (solo debe decir "Voz activada")');
        console.log('   - Esperar tiempo terminado (debe sonar voz + mostrar alerta)');
      } else {
        console.log('❌ ALGUNOS TESTS FALLARON - REVISAR ARRIBA');
      }
      
      return results;
    }
    
    // Hacer función global para ejecutar desde consola
    window.runExhaustiveTests = runExhaustiveTests;

</script>
</body>
</html>