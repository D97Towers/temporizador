<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pruebas Exhaustivas del Frontend</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border-left: 4px solid #007bff;
            background: #f8f9fa;
        }
        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .console-output {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>üß™ PRUEBAS EXHAUSTIVAS DEL FRONTEND</h1>
    
    <div class="test-container">
        <h2>üìä Resumen de Pruebas</h2>
        <div id="testSummary">
            <div class="test-result info">
                <strong>Total de pruebas:</strong> <span id="totalTests">0</span><br>
                <strong>Exitosas:</strong> <span id="passedTests">0</span><br>
                <strong>Fallidas:</strong> <span id="failedTests">0</span><br>
                <strong>Advertencias:</strong> <span id="warningTests">0</span>
            </div>
        </div>
        <button onclick="runAllTests()">üöÄ Ejecutar Todas las Pruebas</button>
        <button onclick="clearResults()">üóëÔ∏è Limpiar Resultados</button>
    </div>

    <div class="test-grid">
        <!-- Pruebas de Conectividad -->
        <div class="test-section">
            <h3>üåê Pruebas de Conectividad</h3>
            <button onclick="testConnectivity()">Probar Conectividad</button>
            <div id="connectivityResults"></div>
        </div>

        <!-- Pruebas de Validaci√≥n -->
        <div class="test-section">
            <h3>‚úÖ Pruebas de Validaci√≥n</h3>
            <button onclick="testValidation()">Probar Validaciones</button>
            <div id="validationResults"></div>
        </div>

        <!-- Pruebas de Timeouts -->
        <div class="test-section">
            <h3>‚è∞ Pruebas de Timeouts</h3>
            <button onclick="testTimeouts()">Probar Timeouts</button>
            <div id="timeoutResults"></div>
        </div>

        <!-- Pruebas de Rate Limiting -->
        <div class="test-section">
            <h3>üö¶ Pruebas de Rate Limiting</h3>
            <button onclick="testRateLimiting()">Probar Rate Limiting</button>
            <div id="rateLimitResults"></div>
        </div>

        <!-- Pruebas de Manejo de Errores -->
        <div class="test-section">
            <h3>‚ùå Pruebas de Manejo de Errores</h3>
            <button onclick="testErrorHandling()">Probar Manejo de Errores</button>
            <div id="errorHandlingResults"></div>
        </div>

        <!-- Pruebas de Concurrencia -->
        <div class="test-section">
            <h3>‚ö° Pruebas de Concurrencia</h3>
            <button onclick="testConcurrency()">Probar Concurrencia</button>
            <div id="concurrencyResults"></div>
        </div>

        <!-- Pruebas de Funcionalidad -->
        <div class="test-section">
            <h3>üîß Pruebas de Funcionalidad</h3>
            <button onclick="testFunctionality()">Probar Funcionalidad</button>
            <div id="functionalityResults"></div>
        </div>

        <!-- Pruebas de Seguridad -->
        <div class="test-section">
            <h3>üîí Pruebas de Seguridad</h3>
            <button onclick="testSecurity()">Probar Seguridad</button>
            <div id="securityResults"></div>
        </div>
    </div>

    <div class="test-container">
        <h3>üìù Console Output</h3>
        <div id="consoleOutput" class="console-output"></div>
    </div>

    <script>
        // Variables globales para las pruebas
        let testResults = {
            total: 0,
            passed: 0,
            failed: 0,
            warnings: 0
        };

        const API_URL = 'https://temporizador-jade.vercel.app';

        // Funci√≥n para agregar resultado de prueba
        function addTestResult(containerId, type, message, details = '') {
            const container = document.getElementById(containerId);
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${type}`;
            resultDiv.innerHTML = `<strong>${message}</strong>${details ? '<br>' + details : ''}`;
            container.appendChild(resultDiv);
            
            // Actualizar contadores
            testResults.total++;
            if (type === 'success') testResults.passed++;
            else if (type === 'error') testResults.failed++;
            else if (type === 'warning') testResults.warnings++;
            
            updateTestSummary();
        }

        // Funci√≥n para actualizar el resumen
        function updateTestSummary() {
            document.getElementById('totalTests').textContent = testResults.total;
            document.getElementById('passedTests').textContent = testResults.passed;
            document.getElementById('failedTests').textContent = testResults.failed;
            document.getElementById('warningTests').textContent = testResults.warnings;
        }

        // Funci√≥n para limpiar resultados
        function clearResults() {
            testResults = { total: 0, passed: 0, failed: 0, warnings: 0 };
            updateTestSummary();
            
            const containers = [
                'connectivityResults', 'validationResults', 'timeoutResults',
                'rateLimitResults', 'errorHandlingResults', 'concurrencyResults',
                'functionalityResults', 'securityResults', 'consoleOutput'
            ];
            
            containers.forEach(id => {
                document.getElementById(id).innerHTML = '';
            });
        }

        // Funci√≥n para hacer requests con timeout
        async function makeRequest(url, options = {}, timeout = 10000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }

        // Pruebas de Conectividad
        async function testConnectivity() {
            const container = 'connectivityResults';
            document.getElementById(container).innerHTML = '';
            
            try {
                // Probar endpoint b√°sico
                const response = await makeRequest(`${API_URL}/admin/status`);
                if (response.ok) {
                    const data = await response.json();
                    addTestResult(container, 'success', '‚úÖ Conectividad b√°sica OK', 
                        `Status: ${response.status}, Children: ${data.children}`);
                } else {
                    addTestResult(container, 'error', '‚ùå Error de conectividad', 
                        `Status: ${response.status}`);
                }
            } catch (error) {
                addTestResult(container, 'error', '‚ùå Error de red', error.message);
            }

            // Probar todos los endpoints
            const endpoints = ['/children', '/games', '/sessions/active', '/sessions'];
            for (const endpoint of endpoints) {
                try {
                    const response = await makeRequest(`${API_URL}${endpoint}`);
                    if (response.ok) {
                        addTestResult(container, 'success', `‚úÖ ${endpoint} OK`, 
                            `Status: ${response.status}`);
                    } else {
                        addTestResult(container, 'error', `‚ùå ${endpoint} Error`, 
                            `Status: ${response.status}`);
                    }
                } catch (error) {
                    addTestResult(container, 'error', `‚ùå ${endpoint} Fallo`, error.message);
                }
            }
        }

        // Pruebas de Validaci√≥n
        async function testValidation() {
            const container = 'validationResults';
            document.getElementById(container).innerHTML = '';
            
            // Probar validaci√≥n de ni√±os
            const invalidChildren = [
                { name: '', description: 'Nombre vac√≠o' },
                { name: 'A', description: 'Nombre muy corto' },
                { name: 'A'.repeat(60), description: 'Nombre muy largo' },
                { name: 'Juan<script>alert("xss")</script>', description: 'XSS attempt' },
                { name: 'Juan123!@#', description: 'Caracteres especiales' }
            ];

            for (const child of invalidChildren) {
                try {
                    const response = await makeRequest(`${API_URL}/children`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: child.name })
                    });
                    
                    if (response.status === 400) {
                        addTestResult(container, 'success', `‚úÖ Validaci√≥n ${child.description}`, 
                            'Correctamente rechazado');
                    } else {
                        addTestResult(container, 'error', `‚ùå Validaci√≥n ${child.description}`, 
                            'No fue rechazado como esperado');
                    }
                } catch (error) {
                    addTestResult(container, 'warning', `‚ö†Ô∏è Validaci√≥n ${child.description}`, 
                        'Error de red');
                }
            }

            // Probar validaci√≥n de sesiones
            const invalidSessions = [
                { childId: 'invalid', gameId: 1, duration: 30, description: 'childId inv√°lido' },
                { childId: 1, gameId: 'invalid', duration: 30, description: 'gameId inv√°lido' },
                { childId: 1, gameId: 1, duration: -5, description: 'duraci√≥n negativa' },
                { childId: 1, gameId: 1, duration: 200, description: 'duraci√≥n muy alta' },
                { childId: 999999, gameId: 1, duration: 30, description: 'childId inexistente' }
            ];

            for (const session of invalidSessions) {
                try {
                    const response = await makeRequest(`${API_URL}/sessions/start`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(session)
                    });
                    
                    if (response.status === 400 || response.status === 404) {
                        addTestResult(container, 'success', `‚úÖ Validaci√≥n sesi√≥n ${session.description}`, 
                            'Correctamente rechazado');
                    } else {
                        addTestResult(container, 'error', `‚ùå Validaci√≥n sesi√≥n ${session.description}`, 
                            'No fue rechazado como esperado');
                    }
                } catch (error) {
                    addTestResult(container, 'warning', `‚ö†Ô∏è Validaci√≥n sesi√≥n ${session.description}`, 
                        'Error de red');
                }
            }
        }

        // Pruebas de Timeouts
        async function testTimeouts() {
            const container = 'timeoutResults';
            document.getElementById(container).innerHTML = '';
            
            // Probar timeout con request muy r√°pida
            const startTime = Date.now();
            try {
                const response = await makeRequest(`${API_URL}/admin/status`, {}, 5000);
                const endTime = Date.now();
                const duration = endTime - startTime;
                
                if (duration < 5000) {
                    addTestResult(container, 'success', '‚úÖ Timeout funcionando', 
                        `Duraci√≥n: ${duration}ms`);
                } else {
                    addTestResult(container, 'error', '‚ùå Timeout no funcionando', 
                        `Duraci√≥n: ${duration}ms`);
                }
            } catch (error) {
                addTestResult(container, 'error', '‚ùå Error en prueba de timeout', error.message);
            }

            // Probar timeout con request que deber√≠a fallar
            try {
                await makeRequest(`${API_URL}/nonexistent`, {}, 2000);
                addTestResult(container, 'error', '‚ùå Timeout no detectado', 
                    'Request no existente deber√≠a fallar');
            } catch (error) {
                if (error.name === 'AbortError') {
                    addTestResult(container, 'success', '‚úÖ Timeout detectado correctamente', 
                        'Request abortado por timeout');
                } else {
                    addTestResult(container, 'info', '‚ÑπÔ∏è Error esperado', 
                        error.message);
                }
            }
        }

        // Pruebas de Rate Limiting
        async function testRateLimiting() {
            const container = 'rateLimitResults';
            document.getElementById(container).innerHTML = '';
            
            const requests = [];
            const startTime = Date.now();
            
            // Hacer 15 requests r√°pidamente (m√°s del l√≠mite de 10)
            for (let i = 0; i < 15; i++) {
                requests.push(
                    makeRequest(`${API_URL}/admin/status`)
                        .then(response => ({ success: response.ok, status: response.status }))
                        .catch(error => ({ success: false, error: error.message }))
                );
            }
            
            try {
                const results = await Promise.all(requests);
                const endTime = Date.now();
                const duration = endTime - startTime;
                
                const successful = results.filter(r => r.success).length;
                const rateLimited = results.filter(r => r.status === 429).length;
                
                addTestResult(container, 'info', 'üìä Resultados de Rate Limiting', 
                    `Duraci√≥n: ${duration}ms, Exitosos: ${successful}, Limitados: ${rateLimited}`);
                
                if (rateLimited > 0) {
                    addTestResult(container, 'success', '‚úÖ Rate limiting funcionando', 
                        `${rateLimited} requests fueron limitados`);
                } else {
                    addTestResult(container, 'warning', '‚ö†Ô∏è Rate limiting no detectado', 
                        'Ning√∫n request fue limitado');
                }
            } catch (error) {
                addTestResult(container, 'error', '‚ùå Error en prueba de rate limiting', error.message);
            }
        }

        // Pruebas de Manejo de Errores
        async function testErrorHandling() {
            const container = 'errorHandlingResults';
            document.getElementById(container).innerHTML = '';
            
            // Probar endpoints inexistentes
            try {
                const response = await makeRequest(`${API_URL}/nonexistent`);
                addTestResult(container, 'error', '‚ùå Endpoint inexistente', 
                    'Deber√≠a devolver 404');
            } catch (error) {
                addTestResult(container, 'success', '‚úÖ Error manejado correctamente', 
                    error.message);
            }

            // Probar m√©todo no permitido
            try {
                const response = await makeRequest(`${API_URL}/admin/status`, {
                    method: 'DELETE'
                });
                if (response.status === 405) {
                    addTestResult(container, 'success', '‚úÖ M√©todo no permitido', 
                        'Correctamente rechazado');
                } else {
                    addTestResult(container, 'warning', '‚ö†Ô∏è M√©todo no permitido', 
                        `Status: ${response.status}`);
                }
            } catch (error) {
                addTestResult(container, 'info', '‚ÑπÔ∏è Error de m√©todo', error.message);
            }

            // Probar JSON inv√°lido
            try {
                const response = await makeRequest(`${API_URL}/children`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: 'invalid json'
                });
                addTestResult(container, 'warning', '‚ö†Ô∏è JSON inv√°lido', 
                    `Status: ${response.status}`);
            } catch (error) {
                addTestResult(container, 'success', '‚úÖ JSON inv√°lido manejado', 
                    'Error parseado correctamente');
            }
        }

        // Pruebas de Concurrencia
        async function testConcurrency() {
            const container = 'concurrencyResults';
            document.getElementById(container).innerHTML = '';
            
            // Crear un ni√±o para las pruebas
            let childId;
            try {
                const createResponse = await makeRequest(`${API_URL}/children`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: 'Concurrency Test',
                        nickname: 'ConTest'
                    })
                });
                
                if (createResponse.ok) {
                    const child = await createResponse.json();
                    childId = child.id;
                    addTestResult(container, 'success', '‚úÖ Ni√±o creado para pruebas', 
                        `ID: ${childId}`);
                } else {
                    addTestResult(container, 'error', '‚ùå No se pudo crear ni√±o', 
                        'Abortando pruebas de concurrencia');
                    return;
                }
            } catch (error) {
                addTestResult(container, 'error', '‚ùå Error creando ni√±o', error.message);
                return;
            }

            // Probar ediciones concurrentes
            const editPromises = [];
            for (let i = 0; i < 5; i++) {
                editPromises.push(
                    makeRequest(`${API_URL}/children/${childId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: `Concurrency Test ${i}`,
                            nickname: `ConTest${i}`
                        })
                    })
                );
            }

            try {
                const results = await Promise.all(editPromises);
                const successful = results.filter(r => r.ok).length;
                const locked = results.filter(r => r.status === 429).length;
                
                addTestResult(container, 'info', 'üìä Resultados de Concurrencia', 
                    `Exitosos: ${successful}, Bloqueados: ${locked}`);
                
                if (locked > 0) {
                    addTestResult(container, 'success', '‚úÖ Control de concurrencia funcionando', 
                        `${locked} operaciones fueron bloqueadas`);
                } else {
                    addTestResult(container, 'warning', '‚ö†Ô∏è Control de concurrencia', 
                        'No se detectaron bloqueos');
                }
            } catch (error) {
                addTestResult(container, 'error', '‚ùå Error en pruebas de concurrencia', error.message);
            }

            // Limpiar
            try {
                await makeRequest(`${API_URL}/children/${childId}`, {
                    method: 'DELETE'
                });
                addTestResult(container, 'success', '‚úÖ Ni√±o de prueba eliminado');
            } catch (error) {
                addTestResult(container, 'warning', '‚ö†Ô∏è Error limpiando ni√±o', error.message);
            }
        }

        // Pruebas de Funcionalidad
        async function testFunctionality() {
            const container = 'functionalityResults';
            document.getElementById(container).innerHTML = '';
            
            let childId, gameId, sessionId;
            
            try {
                // Crear ni√±o
                const childResponse = await makeRequest(`${API_URL}/children`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: 'Test Funcionalidad',
                        nickname: 'TestFunc',
                        fatherName: 'Padre Test',
                        motherName: 'Madre Test'
                    })
                });
                
                if (childResponse.ok) {
                    const child = await childResponse.json();
                    childId = child.id;
                    addTestResult(container, 'success', '‚úÖ Ni√±o creado', `ID: ${childId}`);
                } else {
                    addTestResult(container, 'error', '‚ùå Error creando ni√±o');
                    return;
                }

                // Crear juego
                const gameResponse = await makeRequest(`${API_URL}/games`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: 'Test Juego' })
                });
                
                if (gameResponse.ok) {
                    const game = await gameResponse.json();
                    gameId = game.id;
                    addTestResult(container, 'success', '‚úÖ Juego creado', `ID: ${gameId}`);
                } else {
                    addTestResult(container, 'error', '‚ùå Error creando juego');
                    return;
                }

                // Crear sesi√≥n
                const sessionResponse = await makeRequest(`${API_URL}/sessions/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        childId: childId,
                        gameId: gameId,
                        duration: 10
                    })
                });
                
                if (sessionResponse.ok) {
                    const session = await sessionResponse.json();
                    sessionId = session.id;
                    addTestResult(container, 'success', '‚úÖ Sesi√≥n creada', `ID: ${sessionId}`);
                } else {
                    addTestResult(container, 'error', '‚ùå Error creando sesi√≥n');
                    return;
                }

                // Extender sesi√≥n
                const extendResponse = await makeRequest(`${API_URL}/sessions/extend`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: sessionId,
                        additionalTime: 5
                    })
                });
                
                if (extendResponse.ok) {
                    addTestResult(container, 'success', '‚úÖ Sesi√≥n extendida');
                } else {
                    addTestResult(container, 'warning', '‚ö†Ô∏è Error extendiendo sesi√≥n');
                }

                // Finalizar sesi√≥n
                const endResponse = await makeRequest(`${API_URL}/sessions/${sessionId}/end`, {
                    method: 'POST'
                });
                
                if (endResponse.ok) {
                    addTestResult(container, 'success', '‚úÖ Sesi√≥n finalizada');
                } else {
                    addTestResult(container, 'warning', '‚ö†Ô∏è Error finalizando sesi√≥n');
                }

                // Editar ni√±o
                const editResponse = await makeRequest(`${API_URL}/children/${childId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: 'Test Funcionalidad Editado',
                        nickname: 'TestFuncEdit'
                    })
                });
                
                if (editResponse.ok) {
                    addTestResult(container, 'success', '‚úÖ Ni√±o editado');
                } else {
                    addTestResult(container, 'warning', '‚ö†Ô∏è Error editando ni√±o');
                }

            } catch (error) {
                addTestResult(container, 'error', '‚ùå Error en pruebas de funcionalidad', error.message);
            } finally {
                // Limpiar
                if (gameId) {
                    try {
                        await makeRequest(`${API_URL}/games/${gameId}`, { method: 'DELETE' });
                        addTestResult(container, 'success', '‚úÖ Juego eliminado');
                    } catch (error) {
                        addTestResult(container, 'warning', '‚ö†Ô∏è Error eliminando juego');
                    }
                }
                
                if (childId) {
                    try {
                        await makeRequest(`${API_URL}/children/${childId}`, { method: 'DELETE' });
                        addTestResult(container, 'success', '‚úÖ Ni√±o eliminado');
                    } catch (error) {
                        addTestResult(container, 'warning', '‚ö†Ô∏è Error eliminando ni√±o');
                    }
                }
            }
        }

        // Pruebas de Seguridad
        async function testSecurity() {
            const container = 'securityResults';
            document.getElementById(container).innerHTML = '';
            
            // Probar endpoint admin sin informaci√≥n sensible
            try {
                const response = await makeRequest(`${API_URL}/admin/status`);
                if (response.ok) {
                    const data = await response.json();
                    
                    // Verificar que no expone informaci√≥n sensible
                    const hasSensitiveInfo = data.environment || data.storage;
                    if (hasSensitiveInfo) {
                        addTestResult(container, 'error', '‚ùå Informaci√≥n sensible expuesta', 
                            'Endpoint admin expone environment/storage');
                    } else {
                        addTestResult(container, 'success', '‚úÖ Endpoint admin securizado', 
                            'No expone informaci√≥n sensible');
                    }
                } else {
                    addTestResult(container, 'error', '‚ùå Endpoint admin no accesible');
                }
            } catch (error) {
                addTestResult(container, 'error', '‚ùå Error probando endpoint admin', error.message);
            }

            // Probar inyecci√≥n SQL (aunque no usamos SQL)
            try {
                const response = await makeRequest(`${API_URL}/children`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: "'; DROP TABLE children; --" })
                });
                
                if (response.status === 400) {
                    addTestResult(container, 'success', '‚úÖ Inyecci√≥n SQL bloqueada', 
                        'Correctamente rechazado');
                } else {
                    addTestResult(container, 'warning', '‚ö†Ô∏è Inyecci√≥n SQL', 
                        'No fue rechazado como esperado');
                }
            } catch (error) {
                addTestResult(container, 'info', '‚ÑπÔ∏è Inyecci√≥n SQL', 'Error de red');
            }

            // Probar XSS en nombres
            try {
                const response = await makeRequest(`${API_URL}/children`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: '<script>alert("xss")</script>' })
                });
                
                if (response.status === 400) {
                    addTestResult(container, 'success', '‚úÖ XSS bloqueado', 
                        'Correctamente rechazado');
                } else {
                    addTestResult(container, 'warning', '‚ö†Ô∏è XSS', 
                        'No fue rechazado como esperado');
                }
            } catch (error) {
                addTestResult(container, 'info', '‚ÑπÔ∏è XSS', 'Error de red');
            }
        }

        // Ejecutar todas las pruebas
        async function runAllTests() {
            clearResults();
            addTestResult('consoleOutput', 'info', 'üöÄ Iniciando todas las pruebas...');
            
            const tests = [
                { name: 'Conectividad', fn: testConnectivity },
                { name: 'Validaci√≥n', fn: testValidation },
                { name: 'Timeouts', fn: testTimeouts },
                { name: 'Rate Limiting', fn: testRateLimiting },
                { name: 'Manejo de Errores', fn: testErrorHandling },
                { name: 'Concurrencia', fn: testConcurrency },
                { name: 'Funcionalidad', fn: testFunctionality },
                { name: 'Seguridad', fn: testSecurity }
            ];
            
            for (const test of tests) {
                try {
                    addTestResult('consoleOutput', 'info', `üìã Ejecutando: ${test.name}`);
                    await test.fn();
                    addTestResult('consoleOutput', 'success', `‚úÖ Completado: ${test.name}`);
                } catch (error) {
                    addTestResult('consoleOutput', 'error', `‚ùå Error en: ${test.name}`, error.message);
                }
                
                // Peque√±a pausa entre pruebas
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            addTestResult('consoleOutput', 'success', 'üéâ Todas las pruebas completadas');
            
            // Resumen final
            const successRate = Math.round((testResults.passed / testResults.total) * 100);
            addTestResult('consoleOutput', 'info', 
                `üìä Resumen Final: ${successRate}% de √©xito (${testResults.passed}/${testResults.total})`);
        }

        // Interceptar console.log para mostrar en la interfaz
        const originalConsoleLog = console.log;
        console.log = function(...args) {
            originalConsoleLog.apply(console, args);
            const output = document.getElementById('consoleOutput');
            const message = args.map(arg => 
                typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
            ).join(' ');
            output.innerHTML += `<div>${new Date().toLocaleTimeString()}: ${message}</div>`;
            output.scrollTop = output.scrollHeight;
        };
    </script>
</body>
</html>
